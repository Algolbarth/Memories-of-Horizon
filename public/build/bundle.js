
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value == null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     */
    function flush_render_callbacks(fns) {
        const filtered = [];
        const targets = [];
        render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
        targets.forEach((c) => c());
        render_callbacks = filtered;
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            flush_render_callbacks($$.after_update);
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        if (has_stop_immediate_propagation)
            modifiers.push('stopImmediatePropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    function construct_svelte_component_dev(component, props) {
        const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
        try {
            const instance = new component(props);
            if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
                throw new Error(error_message);
            }
            return instance;
        }
        catch (err) {
            const { message } = err;
            if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
                throw new Error(error_message);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    class Train {
        deck = undefined;
        add = {
            entity: undefined,
            zone: undefined,
            reset: function () {
                this.zone = undefined;
            },
        };

        constructor() {
            this.player = this.entity();
            this.player.gold = 200;
            this.player.flux = 200;

            this.bot = this.entity();
        };

        entity = function () {
            return {
                life: 100,
                gold : 0,
                flux : 0,
                zones: [
                    {
                        name: "Lieux",
                        cards: ["Plaine"],
                    },
                    {
                        name: "Boutique",
                        cards: [],
                        level: 1,
                    },
                    {
                        name: "Main",
                        cards: [],
                    },
                    {
                        name: "Terrain",
                        cards: [],
                    },
                    {
                        name: "D√©fausse",
                        cards: [],
                    },
                ],
            };
        };
    }

    class Card {
        name = "Carte";
        cout = [];
        vente = [];
        elements = [];
        familles = {
            base : [],
            add : [],
            step : [],
            total :  function () {
                let array = [];
                for (const b of this.base) {
                    array.push(b);
                }
                for (const a of this.add) {
                    array.push(a);
                }
                for (const s of this.step) {
                    array.push(s);
                }
                return array;
            }
        };
        traits = [];
        stats = [];

        verrou = false;

        constructor(System) {
            this.System = System;

            this.addTrait("L√©gendaire", false);

            this.addTrait("Rare", false);

            this.addStat("Perp√©tuit√©", 0);
            this.stat("Perp√©tuit√©").current = 0;

            for (const ressource of System.ressources) {
                this.cout.push(new Cout(ressource, 0, this));
                this.vente.push(new Cout(ressource, 0, this));
            }
        };

        init = function (array) {
            let total = 0;
            for (const element of array) {
                this.getCout(element[0]).base += element[1];
                total += element[1];
                if (element[0] != "Or") {
                    this.elements.push(element[0]);
                }
            }

            this.level = parseInt((total - 1) / 10) + 1;
            if (this.level > 20) {
                this.level = 20;
            }
            if (this.elements.length == 0) {
                this.elements.push("Neutre");
            }

            let total_vente = 0;
            for (const element of array) {
                this.getVente(element[0]).base += parseInt(element[1] / 2);
                total_vente += parseInt(element[1] / 2);
            }
            if (total_vente * 2 + 1 < total) {
                this.getVente("Or").base++;
            }
        };

        getCout = function (name) {
            for (const c of this.cout) {
                if (c.name == name) {
                    return c;
                }
            }
            return undefined;
        };

        getVente = function (name) {
            for (const v of this.vente) {
                if (v.name == name) {
                    return v;
                }
            }
            return undefined;
        };

        coutTotal = function () {
            let total = 0;
            for (const cout of this.cout) {
                total += cout.value();
            }
            return total;
        };

        coutReduce = function (value) {
            let best = this.getCout("Or");
            for (const cout of this.cout) {
                if (cout.value() > best.value()) {
                    best = cout;
                }
            }
            best.base--;
            value--;

            if (value > 0) {
                this.coutReduce(value);
            }
        };

        venteTotal = function () {
            let total = 0;
            for (const vente of this.vente) {
                total += vente.value();
            }
            return total;
        };

        remove = function () {
            if (this.isUnit() && this.zone.name == "Terrain") {
                this.owner.ressource("Mana").max -= this.stat("Magie").value();
            }

            this.removeEffect(this.zone.name);

            this.zone.cards.splice(this.slot, 1);
            for (let i = this.slot; i < this.zone.cards.length; i++) {
                this.zone.cards[i].slot--;
            }
            this.zone = undefined;
            this.slot = undefined;
        };

        removeEffect = function () {

        };

        add = function (zone, entity = this.owner) {
            this.owner = entity;
            this.zone = entity.zone(zone);
            this.slot = entity.zone(zone).cards.length;

            if (zone == "D√©fausse") {
                this.stat("Perp√©tuit√©").current = 2;
            }
            else {
                this.stat("Perp√©tuit√©").current = 0;
            }

            if (!["Main", "Boutique"].includes(zone)) {
                this.cache = false;
            }

            if (this.isUnit() && zone == "Terrain") {
                entity.ressource("Mana").current += this.stat("Magie").value();
                entity.ressource("Mana").max += this.stat("Magie").value();
            }

            this.addEffect(zone);

            entity.zone(zone).cards.push(this);
        };

        addEffect = function () {

        };

        move = function (zone, entity = this.owner) {
            this.remove();
            this.add(zone, entity);
        };

        up = function () {
            let temp = this.zone.cards[this.slot - 1];

            this.zone.cards[this.slot - 1] = this;
            this.zone.cards[this.slot] = temp;

            temp.slot++;
            this.slot--;
        };

        down = function () {
            let temp = this.zone.cards[this.slot + 1];

            this.zone.cards[this.slot + 1] = this;
            this.zone.cards[this.slot] = temp;

            temp.slot--;
            this.slot++;
        };

        canBuy = function () {
            for (const c of this.cout) {
                if (c.value() > this.owner.ressource(c.name).total()) {
                    return false;
                }
            }
            return true;
        };

        buy = function () {
            if (this.canBuy()) {
                for (const c of this.cout) {
                    this.owner.ressource(c.name).spend(c.value());
                }
                this.verrou = false;
                this.move("Main");
                this.System.pages.change("Game");
            }
        };

        lock = function (state) {
            this.verrou = state;
        };

        sell = function () {
            for (const v of this.vente) {
                this.owner.ressource(v.name).current += v.value();
            }
            this.remove();
            this.System.pages.change("Game");
        };

        use = function () {
            this.useEffect();
        };

        useEffect = function () {
            this.move("D√©fausse");
            this.pose();
        };

        pose = function () {
            this.cache = false;

            for (const entity of [this.System.game.player, this.System.game.bot]) {
                for (const zone of entity.zones) {
                    let cpy = this.System.copy(zone.cards);
                    for (const card of cpy) {
                        if (card != this) {
                            card.otherPoseEffect(this);
                            if (card.type == "Cr√©ature") {
                                for (const e of card.equipments) {
                                    e.otherPoseEffect(this);
                                }
                            }
                        }
                    }
                }
            }

            this.System.pages.change("Game");
        };

        otherPoseEffect = function () {

        };

        detroy = function () {
            if (!this.trait("L√©gendaire")) {
                this.move("D√©fausse");
            }
        };

        otherDieEffect = function () {

        };

        startStepEffect = function () {

        };

        turnEffect = function () {

        };

        text = undefined;

        description = function () {
            return "...";
        };

        stat = function (name) {
            for (const s of this.stats) {
                if (name == s.name) {
                    return s;
                }
            }
        };

        addStat = function (name, value) {
            this.stats.push(new Stat$1(name, value, this));
        };

        hasStat = function () {
            for (const s of this.stats) {
                if (s.value() > 0 || s.current > 0) {
                    return true;
                }
            }
            return false;
        };

        trait = function (name) {
            for (const t of this.traits) {
                if (name == t.name) {
                    return t;
                }
            }
        };

        addTrait = function (name, value) {
            this.traits.push(new Trait$1(name, value, this));
        };

        hasTrait = function () {
            for (const t of this.traits) {
                if (t.value()) {
                    return true;
                }
            }
            return false;
        };

        isUnit = function () {
            if (this.type == "Cr√©ature" || this.type == "B√¢timent") {
                return true;
            }
            return false;
        };

        transform = function (name) {
            let newCard = this.System.cards.getByName(name);
            this.zone.cards[this.slot] = newCard;
            
            this.zone.cards[this.slot].owner = this.owner;
            this.zone.cards[this.slot].zone = this.zone;
            this.zone.cards[this.slot].slot = this.slot;

            for (const trait of this.traits) {
                newCard.trait(trait.name).add = trait.add;
            }
            for (const stat of this.stats) {
                newCard.stat(stat.name).add = stat.add;
                newCard.stat(stat.name).step = stat.step;
                newCard.stat(stat.name).current = stat.current + newCard.stat(stat.name).base - this.stat(stat.name).base;
            }
            for (const e of this.equipments) {
                newCard.equipments.push(e);
                e.bearer = newCard;
            }
        };
    }

    class Cout {
        constructor(name, value, card) {
            this.name = name;
            this.card = card;
            this.base = value;
        };

        value = function () {
            let total = this.base;
            return total;
        };
    }

    let Stat$1 = class Stat {
        add = 0;
        step = 0;
        turn = 0;

        constructor(name, value, card) {
            this.name = name;
            this.base = value;
            this.card = card;
        };

        value = function () {
            let total = this.base + this.add + this.step + this.turn;
            if (this.card.type == "Cr√©ature") {
                for (const equipment of this.card.equipments) {
                    total += equipment.equipStat(this.name).value();
                }
            }

            if (total > 0) {
                return total;
            }
            else {
                return 0;
            }
        };

        increase = function (value) {
            this.add += value;
        };

        fix = function (value) {
            if (this.value() < value) {
                this.add += value - this.value();
            }
        };

        remove = function (value) {
            while (value > 0) {
                if (this.turn > 0) {
                    this.turn--;
                }
                else if (this.step > 0) {
                    this.step--;
                }
                else {
                    this.add--;
                }
                value--;
            }
        };
    };

    let Trait$1 = class Trait {
        add = false;
        step = false;
        turn = false;

        constructor(name, value, card) {
            this.name = name;
            this.base = value;
            this.card = card;
        };

        value = function () {
            let total = this.base + this.add + this.step + this.turn;
            if (this.card.type == "Cr√©ature") {
                for (const equipment of this.card.equipments) {
                    total += equipment.equipStat(this.name).value();
                }
            }
            return total;
        };
    };

    class Action extends Card {
        type = "Action";
    }

    /* src/Cards/Actions/Ambidextrie/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3G(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 1 le Maniement d'une cr√©ature alli√©e sur le terrain ayant exactement un Maniement de 1.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$20 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3G, create_fragment$3G, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3G.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Preview.svelte generated by Svelte v3.59.2 */

    const file$1q = "src/Preview.svelte";

    // (16:8) {#if card.verrou}
    function create_if_block_13$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "üîí";
    			attr_dev(div, "id", "verrou");
    			attr_dev(div, "class", "svelte-176zf5k");
    			add_location(div, file$1q, 16, 12, 439);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13$1.name,
    		type: "if",
    		source: "(16:8) {#if card.verrou}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {:else}
    function create_else_block_3$1(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "???";
    			add_location(button, file$1q, 37, 12, 1113);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$1.name,
    		type: "else",
    		source: "(37:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:8) {#if !card.cache}
    function create_if_block_12$1(ctx) {
    	let button;
    	let t_value = /*card*/ ctx[1].name + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 19, 12, 523);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false, false),
    					listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[6], false, false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[7], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 2 && t_value !== (t_value = /*card*/ ctx[1].name + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12$1.name,
    		type: "if",
    		source: "(19:8) {#if !card.cache}",
    		ctx
    	});

    	return block;
    }

    // (42:4) {#if isPlayer || fonction != undefined}
    function create_if_block$v(ctx) {
    	let div;
    	let t;
    	let if_block0 = /*System*/ ctx[0].game.phase == "Pr√©paration" && /*fonction*/ ctx[3] == undefined && create_if_block_3$8(ctx);
    	let if_block1 = /*fonction*/ ctx[3] != undefined && create_if_block_1$h(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "id", "actions");
    			attr_dev(div, "class", "svelte-176zf5k");
    			add_location(div, file$1q, 42, 8, 1216);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*System*/ ctx[0].game.phase == "Pr√©paration" && /*fonction*/ ctx[3] == undefined) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$8(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*fonction*/ ctx[3] != undefined) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$h(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(42:4) {#if isPlayer || fonction != undefined}",
    		ctx
    	});

    	return block;
    }

    // (44:12) {#if System.game.phase == "Pr√©paration" && fonction == undefined}
    function create_if_block_3$8(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let if_block0 = (/*card*/ ctx[1].zone.name == "Main" || /*card*/ ctx[1].zone.name == "Terrain") && create_if_block_11$1(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*card*/ ctx[1].zone.name == "Boutique") return create_if_block_7$2;
    		if (/*card*/ ctx[1].zone.name == "Main") return create_if_block_8$1;
    		if (/*card*/ ctx[1].zone.name == "Lieux") return create_if_block_9$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block1 = current_block_type && current_block_type(ctx);
    	let if_block2 = (/*card*/ ctx[1].zone.name == "Main" || /*card*/ ctx[1].zone.name == "Terrain" && /*card*/ ctx[1].type == "Cr√©ature") && create_if_block_4$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*card*/ ctx[1].zone.name == "Main" || /*card*/ ctx[1].zone.name == "Terrain") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_11$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if (if_block1) if_block1.d(1);
    				if_block1 = current_block_type && current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			}

    			if (/*card*/ ctx[1].zone.name == "Main" || /*card*/ ctx[1].zone.name == "Terrain" && /*card*/ ctx[1].type == "Cr√©ature") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_4$6(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);

    			if (if_block1) {
    				if_block1.d(detaching);
    			}

    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(44:12) {#if System.game.phase == \\\"Pr√©paration\\\" && fonction == undefined}",
    		ctx
    	});

    	return block;
    }

    // (45:16) {#if card.zone.name == "Main" || card.zone.name == "Terrain"}
    function create_if_block_11$1(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Vendre";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 45, 20, 1411);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[8], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(45:16) {#if card.zone.name == \\\"Main\\\" || card.zone.name == \\\"Terrain\\\"}",
    		ctx
    	});

    	return block;
    }

    // (67:52) 
    function create_if_block_9$1(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*card*/ ctx[1] == /*card*/ ctx[1].owner.place) return create_if_block_10$1;
    		return create_else_block_2$1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(67:52) ",
    		ctx
    	});

    	return block;
    }

    // (60:51) 
    function create_if_block_8$1(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Poser";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 60, 20, 1966);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[10], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(60:51) ",
    		ctx
    	});

    	return block;
    }

    // (53:16) {#if card.zone.name == "Boutique"}
    function create_if_block_7$2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Acheter";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 53, 20, 1699);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[9], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(53:16) {#if card.zone.name == \\\"Boutique\\\"}",
    		ctx
    	});

    	return block;
    }

    // (70:20) {:else}
    function create_else_block_2$1(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Changer";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 70, 24, 2345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_4*/ ctx[11], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(70:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (68:20) {#if card == card.owner.place}
    function create_if_block_10$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Actif");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(68:20) {#if card == card.owner.place}",
    		ctx
    	});

    	return block;
    }

    // (80:16) {#if card.zone.name == "Main" || (card.zone.name == "Terrain" && card.type == "Cr√©ature")}
    function create_if_block_4$6(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type_3(ctx, dirty) {
    		if (/*card*/ ctx[1].slot > 0) return create_if_block_6$4;
    		return create_else_block_1$3;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_4(ctx, dirty) {
    		if (/*card*/ ctx[1].slot < /*card*/ ctx[1].zone.cards.length - 1) return create_if_block_5$5;
    		return create_else_block$b;
    	}

    	let current_block_type_1 = select_block_type_4(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_4(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(80:16) {#if card.zone.name == \\\"Main\\\" || (card.zone.name == \\\"Terrain\\\" && card.type == \\\"Cr√©ature\\\")}",
    		ctx
    	});

    	return block;
    }

    // (89:20) {:else}
    function create_else_block_1$3(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñ≤";
    			attr_dev(button, "class", "classic useless svelte-176zf5k");
    			add_location(button, file$1q, 89, 24, 3179);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(89:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (81:20) {#if card.slot > 0}
    function create_if_block_6$4(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñ≤";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 81, 24, 2853);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_5*/ ctx[12], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(81:20) {#if card.slot > 0}",
    		ctx
    	});

    	return block;
    }

    // (100:20) {:else}
    function create_else_block$b(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñº";
    			attr_dev(button, "class", "classic useless svelte-176zf5k");
    			add_location(button, file$1q, 100, 24, 3670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(100:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (92:20) {#if card.slot < card.zone.cards.length - 1}
    function create_if_block_5$5(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñº";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 92, 24, 3342);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_6*/ ctx[13], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(92:20) {#if card.slot < card.zone.cards.length - 1}",
    		ctx
    	});

    	return block;
    }

    // (105:12) {#if fonction != undefined}
    function create_if_block_1$h(ctx) {
    	let show_if = /*condition*/ ctx[2](/*card*/ ctx[1]);
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_2$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*condition, card*/ 6) show_if = /*condition*/ ctx[2](/*card*/ ctx[1]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(105:12) {#if fonction != undefined}",
    		ctx
    	});

    	return block;
    }

    // (106:16) {#if condition(card)}
    function create_if_block_2$a(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "S√©lectionner";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1q, 106, 20, 3882);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_7*/ ctx[14], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(106:16) {#if condition(card)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3F(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let div0_id_value;
    	let t1;
    	let div1_class_value;
    	let if_block0 = /*card*/ ctx[1].verrou && create_if_block_13$1(ctx);

    	function select_block_type(ctx, dirty) {
    		if (!/*card*/ ctx[1].cache) return create_if_block_12$1;
    		return create_else_block_3$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);
    	let if_block2 = (/*isPlayer*/ ctx[4] || /*fonction*/ ctx[3] != undefined) && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();

    			attr_dev(div0, "id", div0_id_value = /*isPlayer*/ ctx[4] || /*fonction*/ ctx[3] != undefined
    			? "infos"
    			: "");

    			attr_dev(div0, "class", "svelte-176zf5k");
    			add_location(div0, file$1q, 14, 4, 341);

    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty((/*isPlayer*/ ctx[4] || /*fonction*/ ctx[3] != undefined
    			? "container "
    			: "") + (/*card*/ ctx[1] == /*System*/ ctx[0].game.fighter
    			? "attacker "
    			: "") + "preview") + " svelte-176zf5k"));

    			add_location(div1, file$1q, 9, 0, 183);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if_block1.m(div0, null);
    			append_dev(div1, t1);
    			if (if_block2) if_block2.m(div1, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[1].verrou) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_13$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			}

    			if (dirty & /*isPlayer, fonction*/ 24 && div0_id_value !== (div0_id_value = /*isPlayer*/ ctx[4] || /*fonction*/ ctx[3] != undefined
    			? "infos"
    			: "")) {
    				attr_dev(div0, "id", div0_id_value);
    			}

    			if (/*isPlayer*/ ctx[4] || /*fonction*/ ctx[3] != undefined) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$v(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*isPlayer, fonction, card, System*/ 27 && div1_class_value !== (div1_class_value = "" + (null_to_empty((/*isPlayer*/ ctx[4] || /*fonction*/ ctx[3] != undefined
    			? "container "
    			: "") + (/*card*/ ctx[1] == /*System*/ ctx[0].game.fighter
    			? "attacker "
    			: "") + "preview") + " svelte-176zf5k"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3F($$self, $$props, $$invalidate) {
    	let isPlayer;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Preview', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;
    	let { condition } = $$props;
    	let { fonction } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Preview> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Preview> was created without expected prop 'card'");
    		}

    		if (condition === undefined && !('condition' in $$props || $$self.$$.bound[$$self.$$.props['condition']])) {
    			console.warn("<Preview> was created without expected prop 'condition'");
    		}

    		if (fonction === undefined && !('fonction' in $$props || $$self.$$.bound[$$self.$$.props['fonction']])) {
    			console.warn("<Preview> was created without expected prop 'fonction'");
    		}
    	});

    	const writable_props = ['System', 'card', 'condition', 'fonction'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Preview> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(0, System.view.card = card, System);
    		System.pages.change("Game");
    	};

    	const mouseenter_handler = () => {
    		$$invalidate(0, System.view.quick = card, System);
    		System.pages.change("Game");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Game");
    	};

    	const click_handler_1 = () => {
    		card.sell();
    	};

    	const click_handler_2 = () => {
    		card.buy();
    	};

    	const click_handler_3 = () => {
    		card.use();
    	};

    	const click_handler_4 = () => {
    		$$invalidate(1, card.owner.place = card, card);
    		System.pages.change("Game");
    	};

    	const click_handler_5 = () => {
    		card.up();
    		System.pages.change("Game");
    	};

    	const click_handler_6 = () => {
    		card.down();
    		System.pages.change("Game");
    	};

    	const click_handler_7 = () => {
    		fonction(card);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    		if ('condition' in $$props) $$invalidate(2, condition = $$props.condition);
    		if ('fonction' in $$props) $$invalidate(3, fonction = $$props.fonction);
    	};

    	$$self.$capture_state = () => ({
    		System,
    		card,
    		condition,
    		fonction,
    		isPlayer
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    		if ('condition' in $$props) $$invalidate(2, condition = $$props.condition);
    		if ('fonction' in $$props) $$invalidate(3, fonction = $$props.fonction);
    		if ('isPlayer' in $$props) $$invalidate(4, isPlayer = $$props.isPlayer);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*card, System*/ 3) {
    			$$invalidate(4, isPlayer = card.owner == System.game.player ? true : false);
    		}
    	};

    	return [
    		System,
    		card,
    		condition,
    		fonction,
    		isPlayer,
    		click_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7
    	];
    }

    class Preview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3F, create_fragment$3F, safe_not_equal, {
    			System: 0,
    			card: 1,
    			condition: 2,
    			fonction: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Preview",
    			options,
    			id: create_fragment$3F.name
    		});
    	}

    	get System() {
    		throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get condition() {
    		throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set condition(value) {
    		throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fonction() {
    		throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fonction(value) {
    		throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Zone.svelte generated by Svelte v3.59.2 */
    const file$1p = "src/Zone.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (12:4) {#if zone.name == "Boutique"}
    function create_if_block_6$3(ctx) {
    	let t0;
    	let t1_value = /*zone*/ ctx[1].level + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Nv ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*zone*/ 2 && t1_value !== (t1_value = /*zone*/ ctx[1].level + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(12:4) {#if zone.name == \\\"Boutique\\\"}",
    		ctx
    	});

    	return block;
    }

    // (15:4) {#if zone.name != "D√©fausse"}
    function create_if_block_5$4(ctx) {
    	let t0;
    	let t1_value = /*zone*/ ctx[1].cards.length + "";
    	let t1;
    	let t2;
    	let t3_value = /*zone*/ ctx[1].size + "";
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			t0 = text("-\n        (");
    			t1 = text(t1_value);
    			t2 = text(" / ");
    			t3 = text(t3_value);
    			t4 = text(")");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*zone*/ 2 && t1_value !== (t1_value = /*zone*/ ctx[1].cards.length + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*zone*/ 2 && t3_value !== (t3_value = /*zone*/ ctx[1].size + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(15:4) {#if zone.name != \\\"D√©fausse\\\"}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if zone.name == "Boutique"}
    function create_if_block_1$g(ctx) {
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let if_block0 = /*entity*/ ctx[2] == /*System*/ ctx[0].game.player && /*fonction*/ ctx[4] == undefined && /*System*/ ctx[0].game.phase == "Pr√©paration" && create_if_block_4$5(ctx);
    	let if_block1 = /*entity*/ ctx[2] == /*System*/ ctx[0].game.player && /*zone*/ ctx[1].level < 20 && /*fonction*/ ctx[4] == undefined && /*System*/ ctx[0].game.phase == "Pr√©paration" && create_if_block_3$7(ctx);
    	let if_block2 = /*entity*/ ctx[2] == /*System*/ ctx[0].game.player && /*fonction*/ ctx[4] == undefined && /*System*/ ctx[0].game.phase == "Pr√©paration" && create_if_block_2$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*entity*/ ctx[2] == /*System*/ ctx[0].game.player && /*fonction*/ ctx[4] == undefined && /*System*/ ctx[0].game.phase == "Pr√©paration") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$5(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*entity*/ ctx[2] == /*System*/ ctx[0].game.player && /*zone*/ ctx[1].level < 20 && /*fonction*/ ctx[4] == undefined && /*System*/ ctx[0].game.phase == "Pr√©paration") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$7(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*entity*/ ctx[2] == /*System*/ ctx[0].game.player && /*fonction*/ ctx[4] == undefined && /*System*/ ctx[0].game.phase == "Pr√©paration") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_2$9(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(19:4) {#if zone.name == \\\"Boutique\\\"}",
    		ctx
    	});

    	return block;
    }

    // (20:8) {#if entity == System.game.player && fonction == undefined && System.game.phase == "Pr√©paration"}
    function create_if_block_4$5(ctx) {
    	let t0;
    	let button;
    	let t2;
    	let t3_value = 10 + "";
    	let t3;
    	let t4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("-\n            ");
    			button = element("button");
    			button.textContent = "Actualiser";
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = text(" Or");
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1p, 21, 12, 546);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(20:8) {#if entity == System.game.player && fonction == undefined && System.game.phase == \\\"Pr√©paration\\\"}",
    		ctx
    	});

    	return block;
    }

    // (30:8) {#if entity == System.game.player && zone.level < 20 && fonction == undefined && System.game.phase == "Pr√©paration"}
    function create_if_block_3$7(ctx) {
    	let t0;
    	let button;
    	let t2;
    	let t3_value = /*zone*/ ctx[1].level * 10 + "";
    	let t3;
    	let t4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("-\n            ");
    			button = element("button");
    			button.textContent = "Am√©liorer";
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = text(" Or");
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1p, 31, 12, 901);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[6], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*zone*/ 2 && t3_value !== (t3_value = /*zone*/ ctx[1].level * 10 + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(30:8) {#if entity == System.game.player && zone.level < 20 && fonction == undefined && System.game.phase == \\\"Pr√©paration\\\"}",
    		ctx
    	});

    	return block;
    }

    // (40:8) {#if entity == System.game.player && fonction == undefined && System.game.phase == "Pr√©paration"}
    function create_if_block_2$9(ctx) {
    	let t0;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("-\n            ");
    			button = element("button");
    			button.textContent = "Verrouiller";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1p, 41, 12, 1242);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[7], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(40:8) {#if entity == System.game.player && fonction == undefined && System.game.phase == \\\"Pr√©paration\\\"}",
    		ctx
    	});

    	return block;
    }

    // (61:8) {:else}
    function create_else_block$a(ctx) {
    	let i;
    	let t1;
    	let br;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "Vide";
    			t1 = space();
    			br = element("br");
    			add_location(i, file$1p, 61, 12, 1778);
    			add_location(br, file$1p, 62, 12, 1802);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(61:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (51:8) {#if zone.cards.length > 0}
    function create_if_block$u(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*zone*/ ctx[1].cards;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Preview, System, zone, condition, fonction*/ 27) {
    				each_value = /*zone*/ ctx[1].cards;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(51:8) {#if zone.cards.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (52:12) {#each zone.cards as card}
    function create_each_block$d(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Preview;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				card: /*card*/ ctx[8],
    				condition: /*condition*/ ctx[3],
    				fonction: /*fonction*/ ctx[4]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*zone*/ 2) switch_instance_changes.card = /*card*/ ctx[8];
    			if (dirty & /*condition*/ 8) switch_instance_changes.condition = /*condition*/ ctx[3];
    			if (dirty & /*fonction*/ 16) switch_instance_changes.fonction = /*fonction*/ ctx[4];

    			if (switch_value !== (switch_value = Preview)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(52:12) {#each zone.cards as card}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3E(ctx) {
    	let div1;
    	let t0_value = /*zone*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let div0;
    	let current_block_type_index;
    	let if_block3;
    	let current;
    	let if_block0 = /*zone*/ ctx[1].name == "Boutique" && create_if_block_6$3(ctx);
    	let if_block1 = /*zone*/ ctx[1].name != "D√©fausse" && create_if_block_5$4(ctx);
    	let if_block2 = /*zone*/ ctx[1].name == "Boutique" && create_if_block_1$g(ctx);
    	const if_block_creators = [create_if_block$u, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*zone*/ ctx[1].cards.length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			div0 = element("div");
    			if_block3.c();
    			attr_dev(div0, "id", "list");
    			add_location(div0, file$1p, 49, 4, 1432);
    			attr_dev(div1, "id", "body");
    			attr_dev(div1, "class", "svelte-14rcaru");
    			add_location(div1, file$1p, 9, 0, 182);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t0);
    			append_dev(div1, t1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t2);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t4);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*zone*/ 2) && t0_value !== (t0_value = /*zone*/ ctx[1].name + "")) set_data_dev(t0, t0_value);

    			if (/*zone*/ ctx[1].name == "Boutique") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$3(ctx);
    					if_block0.c();
    					if_block0.m(div1, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*zone*/ ctx[1].name != "D√©fausse") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_5$4(ctx);
    					if_block1.c();
    					if_block1.m(div1, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*zone*/ ctx[1].name == "Boutique") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$g(ctx);
    					if_block2.c();
    					if_block2.m(div1, t4);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks[current_block_type_index];

    				if (!if_block3) {
    					if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block3.c();
    				} else {
    					if_block3.p(ctx, dirty);
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Zone', slots, []);
    	let { System } = $$props;
    	let { zone } = $$props;
    	let { entity } = $$props;
    	let { condition } = $$props;
    	let { fonction } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Zone> was created without expected prop 'System'");
    		}

    		if (zone === undefined && !('zone' in $$props || $$self.$$.bound[$$self.$$.props['zone']])) {
    			console.warn("<Zone> was created without expected prop 'zone'");
    		}

    		if (entity === undefined && !('entity' in $$props || $$self.$$.bound[$$self.$$.props['entity']])) {
    			console.warn("<Zone> was created without expected prop 'entity'");
    		}

    		if (condition === undefined && !('condition' in $$props || $$self.$$.bound[$$self.$$.props['condition']])) {
    			console.warn("<Zone> was created without expected prop 'condition'");
    		}

    		if (fonction === undefined && !('fonction' in $$props || $$self.$$.bound[$$self.$$.props['fonction']])) {
    			console.warn("<Zone> was created without expected prop 'fonction'");
    		}
    	});

    	const writable_props = ['System', 'zone', 'entity', 'condition', 'fonction'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Zone> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		entity.actualiseShop();
    	};

    	const click_handler_1 = () => {
    		entity.upShop();
    	};

    	const click_handler_2 = () => {
    		entity.lock();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('zone' in $$props) $$invalidate(1, zone = $$props.zone);
    		if ('entity' in $$props) $$invalidate(2, entity = $$props.entity);
    		if ('condition' in $$props) $$invalidate(3, condition = $$props.condition);
    		if ('fonction' in $$props) $$invalidate(4, fonction = $$props.fonction);
    	};

    	$$self.$capture_state = () => ({
    		Preview,
    		System,
    		zone,
    		entity,
    		condition,
    		fonction
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('zone' in $$props) $$invalidate(1, zone = $$props.zone);
    		if ('entity' in $$props) $$invalidate(2, entity = $$props.entity);
    		if ('condition' in $$props) $$invalidate(3, condition = $$props.condition);
    		if ('fonction' in $$props) $$invalidate(4, fonction = $$props.fonction);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		zone,
    		entity,
    		condition,
    		fonction,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    let Zone$1 = class Zone extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3E, create_fragment$3E, safe_not_equal, {
    			System: 0,
    			zone: 1,
    			entity: 2,
    			condition: 3,
    			fonction: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Zone",
    			options,
    			id: create_fragment$3E.name
    		});
    	}

    	get System() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zone() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zone(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get entity() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set entity(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get condition() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set condition(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fonction() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fonction(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Ambidextrie/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3D(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$W,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$W(card) {
    	if (card.type == "Cr√©ature" && card.stat("Maniement").value() == 1) {
    		return true;
    	}

    	return false;
    }

    function instance$3D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$W, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$13 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3D, create_fragment$3D, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3D.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Ambidextrie extends Action {
        name = "Ambidextrie";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);

            this.text = Text$20;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$13);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.stat("Maniement").value() == 1) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.stat("Maniement").add++;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Roulade/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3C(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 1 l'Esquive d'une cr√©ature alli√©e sur le terrain pendant cette √©tape.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1$ = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3C, create_fragment$3C, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3C.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Roulade/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3B(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$V,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$V(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$3B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$V, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$12 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3B, create_fragment$3B, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3B.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Roulade extends Action {
        name = "Roulade";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);

            this.text = Text$1$;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$12);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.stat("Esquive").step++;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Rappel/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3A(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Place dans la boutique une carte alli√©e situ√©e dans la d√©fausse. Si c'est une unit√©, fixe sa vie √† 1.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1_ = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3A, create_fragment$3A, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3A.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Rappel/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3z(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("D√©fausse"),
    				condition: condition$U,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("D√©fausse");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$U(card) {
    	return true;
    }

    function instance$3z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$U, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$11 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3z, create_fragment$3z, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3z.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Rappel extends Action {
        name = "Rappel";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);

            this.text = Text$1_;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$11);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("D√©fausse").cards) {
                    if (target == undefined) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.move("Boutique");
            if (target.isUnit()) {
                target.stat("Vie").current = 1;
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Restockage/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3y(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Actualise la boutique.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1Z = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3y, create_fragment$3y, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3y.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Restockage extends Action {
        name = "Restockage";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);

            this.text = Text$1Z;
        };

        useEffect = function () {
            this.owner.refreshShop();
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Entrainement/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3x(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 10 l'attaque et la vie d'une cr√©ature alli√©e sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1Y = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3x, create_fragment$3x, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3x.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Entrainement/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3w(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$T,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$T(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$3w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$T, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$10 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3w, create_fragment$3w, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3w.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Entrainement extends Action {
        name = "Entra√Ænement";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);

            this.text = Text$1Y;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$10);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.stat("Attaque").add += 10;
            target.stat("Vie").add += 10;
            target.stat("Vie").current += 10;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Elimination/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3v(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("D√©truis une cr√©ature adverse sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1X = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3v, create_fragment$3v, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3v.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Elimination/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3u(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$S,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$S(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$3u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$S, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$$ = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3u, create_fragment$3u, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3u.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Elimination extends Action {
        name = "√âlimination";

        constructor(System) {
            super(System);

            this.init([["Or", 50]]);

            this.text = Text$1X;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$$);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.adversary().zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.destroy();
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/PluieDeFleche/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3t(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 5 d√©g√¢ts √† toutes les unit√©s adverses sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1W = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3t, create_fragment$3t, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3t.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PluieDeFleche extends Action {
        name = "Pluie de fl√®che";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);

            this.text = Text$1W;
        };

        use = function () {
            if (this.owner == this.System.game.player || this.owner.adversary().zone("Terrain").cards.length > 0) {
                this.useEffect();
            }
        };

        useEffect = function () {
            let terrain = this.System.copy(this.owner.adversary().zone("Terrain").cards);
            for (const card of terrain) {
                card.damage(5);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Renforcement/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3s(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 15 la vie d'une unit√© alli√©e sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1V = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3s, create_fragment$3s, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3s.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Renforcement/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3r(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$R,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$R(card) {
    	return true;
    }

    function instance$3r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$R, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$_ = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3r, create_fragment$3r, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3r.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Renforcement extends Action {
        name = "Renforcement";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);

            this.text = Text$1V;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$_);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            target.stat("Vie").add += 15;
            target.stat("Vie").current += 15;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Sprint/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 2 la vitesse d'une cr√©ature alli√©e sur le terrain pendant cette √©tape.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1U = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3q, create_fragment$3q, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3q.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Sprint/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3p(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$Q,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$Q(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$3p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$Q, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$Z = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3p, create_fragment$3p, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3p.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Sprint extends Action {
        name = "Sprint";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);

            this.text = Text$1U;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$Z);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.stat("Vitesse").step += 2;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Forger/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("D√©couvre 1 carte de famille √âquipement.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1T = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3o, create_fragment$3o, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3o.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Forger extends Action {
        name = "Forger";

        constructor(System) {
            super(System);

            this.init([["Or", 8]]);

            this.text = Text$1T;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.familles.base.includes("√âquipement")) {
                    return true;
                }
                return false;
            };
            this.owner.discover(1, condition);
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Eruption/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 300 d√©g√¢ts √† une unit√© adverse sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1S = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3n, create_fragment$3n, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3n.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Eruption/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3m(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$P,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$P(card) {
    	return true;
    }

    function instance$3m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$P, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$Y = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3m, create_fragment$3m, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3m.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Eruption extends Action {
        name = "√âruption";

        constructor(System) {
            super(System);

            this.init([["Or", 75], ["Feu", 75]]);

            this.text = Text$1S;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$Y);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            target.damage(300);
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/TirHydraulique/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3l(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 30 d√©g√¢ts √† une unit√© adverse sur le terrain. D√©pense 15 eau pour infliger 60 d√©g√¢ts √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1R = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3l, create_fragment$3l, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3l.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/TirHydraulique/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3k(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$O,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$O(card) {
    	return true;
    }

    function instance$3k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$O, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$X = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3k, create_fragment$3k, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3k.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class TirHydraulique extends Action {
        name = "Tir hydraulique";

        constructor(System) {
            super(System);

            this.init([["Or", 8], ["Eau", 8]]);

            this.text = Text$1R;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$X);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            if (this.owner.ressource("Eau").total() >= 15) {
                this.owner.ressource("Eau").spend(15);
                target.damage(60);
            }
            else {
                target.damage(30);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/CanonAEau/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 100 d√©g√¢ts √† une unit√© adverse sur le terrain. D√©pense 200 eau pour infliger 100 d√©g√¢ts √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1Q = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3j, create_fragment$3j, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3j.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/CanonAEau/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3i(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$N,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$N(card) {
    	return true;
    }

    function instance$3i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$N, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$W = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3i, create_fragment$3i, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3i.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CanonAEau extends Action {
        name = "Canon √† eau";

        constructor(System) {
            super(System);

            this.init([["Or", 25], ["Eau", 25]]);

            this.text = Text$1Q;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$W);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            if (this.owner.ressource("Eau").total() >= 50) {
                this.owner.ressource("Eau").spend(50);
                target.damage(200);
            }
            else {
                target.damage(100);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Noyade/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("D√©truis une cr√©ature adverse qui n'est pas d'√©lement Eau sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1P = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3h, create_fragment$3h, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3h.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Noyade/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3g(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$M,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$M(card) {
    	if (card.type == "Cr√©ature" && !card.elements.includes("Eau")) {
    		return true;
    	}

    	return false;
    }

    function instance$3g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$M, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$V = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3g, create_fragment$3g, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3g.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Noyade extends Action {
        name = "Noyade";

        constructor(System) {
            super(System);

            this.init([["Or", 20], ["Eau", 20]]);

            this.text = Text$1P;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$V);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.adversary().zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.destroy();
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Actions/Metamorphose/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Transforme une cr√©ature alli√©e de famille druide sur le terrain en son autre forme.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1O = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3f, create_fragment$3f, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3f.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Actions/Metamorphose/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$3e(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$L,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$L(card) {
    	if (card.type == "Cr√©ature" && card.familles.base.includes("Druide")) {
    		return true;
    	}

    	return false;
    }

    function instance$3e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$L, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$U = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3e, create_fragment$3e, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$3e.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Metamorphose extends Action {
        name = "M√©tamorphose";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);
            this.familles.base.push("Druide");

            this.text = Text$1O;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$U);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.familles.base.includes("Druide")) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.transform(target.otherForm);
            this.move("D√©fausse");
            this.pose();
        };
    }

    class Unit extends Card {
        constructor(System) {
            super(System);

            this.addTrait("Inactif", false);
            this.trait("Inactif").value = function () {
                if (this.card.stat("Actions").value() == 0) {
                    return true;
                }
                return false;
            };

            this.addStat("D√©fense", 0);

            this.addStat("Vie", 1);
            this.stat("Vie").current = 1;

            this.addStat("Endurance", 0);

            this.addStat("Actions", 1);
            this.stat("Actions").current = 1;

            this.addStat("Multicoup", 1);

            this.addStat("Vitesse", 0);

            this.addStat("Protection", 0);

            this.addStat("Esquive", 0);

            this.addStat("Magie", 0);

            this.addStat("Intelligence", 0);
        };

        useEffect = function () {
            this.move("Terrain");
            this.pose();
        };

        heal = function (value) {
            this.stat("Vie").current += value;
            if (this.stat("Vie").current > this.stat("Vie").value()) {
                this.stat("Vie").current = this.stat("Vie").value();
            }
        };

        damage = function (value) {
            let result = {
                value: value,
                die: false
            };

            if (this.stat("Esquive").value() == 0) {
                if (this.stat("Endurance").value() > result.value) {
                    this.stat("Endurance").remove(result.value);
                    result.value = 0;
                }
                else {
                    result.value -= this.stat("Endurance").value();
                    this.stat("Endurance").add = 0;
                    this.stat("Endurance").step = 0;
                }

                this.stat("Vie").current -= result.value;

                if (this.stat("Vie").current <= 0) {
                    result.die = true;
                    this.die();
                }
            }
            else {
                result.value = 0;
                this.stat("Esquive").remove(1);
            }

            return result;
        };

        die = function () {
            this.stat("Vie").current = 0;

            this.dieGo();

            this.dieEffect();
            for (const entity of [this.System.game.player, this.System.game.bot]) {
                for (const zone of entity.zones) {
                    let cpy = this.System.copy(zone.cards);
                    for (const card of cpy) {
                        if (card != this) {
                            card.otherDieEffect(this);
                            if (card.type == "Cr√©ature") {
                                for (const e of card.equipments) {
                                    e.otherDieEffect(this);
                                }
                            }
                        }
                    }
                }
            }
        };

        dieGo = function () {
            this.move("D√©fausse");
        };

        dieEffect = function () {

        };

        destroy = function () {
            if (!this.trait("L√©gendaire").value()) {
                this.die();
            }
        };

        play = function () {
            this.stat("Actions").current--;
            this.playEffect();
        };

        playEffect = function () {

        };
    }

    class Batiment extends Unit {
        type = "B√¢timent";

        constructor (System) {
            super(System);

            this.stat("Actions").base = 0;
        }
    }

    class MurDeBrique extends Batiment {
        name = "Mur de brique";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);
            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;
        };
    }

    /* src/Cards/Batiments/Pont/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand une cr√©ature alli√©e est pos√©e : pioche 1 carte.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1N = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3d, create_fragment$3d, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3d.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Pont extends Batiment {
        name = "Pont";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;

            this.text = Text$1N;
        };

        otherPoseEffect = function (card) {
            if (this.zone.name == "Terrain" && card.type == "Cr√©ature" && this.owner == card.owner) {
                this.owner.draw(1);
            }
        };
    }

    /* src/Cards/Batiments/Charrette/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : pioche 5 cartes.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1M = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3c, create_fragment$3c, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3c.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Charrette extends Batiment {
        name = "Charrette";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;

            this.text = Text$1M;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.draw(5);
            }
        };
    }

    /* src/Cards/Batiments/Caserne/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : cr√©e 1 Soldat sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1L = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3b, create_fragment$3b, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3b.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Caserne extends Batiment {
        name = "Caserne";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;

            this.text = Text$1L;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.getCard("Soldat").add("Terrain");
            }
        };
    }

    class TourDeMage extends Batiment {
        name = "Tour de mage";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;
            this.stat("Magie").base = 10;
        };
    }

    /* src/Cards/Batiments/FeuDeCamp/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$3a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : soigne 5 blessures aux cr√©atures adjacentes.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1K = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3a, create_fragment$3a, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$3a.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class FeuDeCamp extends Batiment {
        name = "Feu de camp";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;

            this.text = Text$1K;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                if (this.slot > 0 && this.zone.cards[this.slot - 1].type == "Cr√©ature") {
                    this.zone.cards[this.slot - 1].heal(5);
                }
                if (this.slot < this.zone.cards.length - 1 && this.zone.cards[this.slot + 1].type == "Cr√©ature") {
                    this.zone.cards[this.slot + 1].heal(5);
                }
            }
        };
    }

    /* src/Cards/Batiments/Bivouac/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$39(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : soigne 10 blessures √† toutes les cr√©atures alli√©es sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$39.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$39($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1J = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$39, create_fragment$39, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$39.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Bivouac extends Batiment {
        name = "Bivouac";

        constructor(System) {
            super(System);

            this.init([["Or", 110]]);
            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;

            this.text = Text$1J;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                let terrain = this.System.copy(this.zone.cards);
                for (const card of terrain) {
                    if (card.type == "Cr√©ature") {
                        card.heal(10);
                    }
                }
            }
        };
    }

    class MurDeRoche extends Batiment {
        name = "Mur de roche";

        constructor(System) {
            super(System);

            this.init([["Or", 25], ["Terre", 25]]);
            this.stat("Vie").base = 100;
            this.stat("Vie").current = 100;
        };
    }

    class MurDePierre extends Batiment {
        name = "Mur de pierre";

        constructor(System) {
            super(System);

            this.init([["Or", 12], ["Terre", 12]]);
            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;
        };
    }

    class Biblioth√®que extends Batiment {
        name = "Biblioth√®que";

        constructor(System) {
            super(System);

            this.init([["Or", 30]]);
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Intelligence").base = 5;
        };
    }

    /* src/Cards/Batiments/BibliothequeElfique/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$38(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand une cr√©ature de famille Elfe est pos√©e : augmente de 1 son intelligence.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$38.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$38($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1I = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$38, create_fragment$38, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$38.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BibliothequeElfique extends Batiment {
        name = "Biblioth√®que elfique";

        constructor(System) {
            super(System);

            this.init([["Or", 25], ["V√©g√©tal", 25]]);
            this.familles.base.push("Elfe");

            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;

            this.text = Text$1I;
        };

        otherPoseEffect = function (card) {
            if (this.zone.name == "Terrain" && card.type == "Cr√©ature" && card.familles.base.includes("Elfe")) {
                this.stat("Intelligence").add += 1;
            }
        }
    }

    class Creature extends Unit {
        type = "Cr√©ature";
        equipments = [];

        constructor (System) {
            super(System);

            this.addStat("Attaque", 0);

            this.addStat("Maniement", 1);

            this.addStat("Adresse", 0);

            this.addStat("Critique", 0);
            this.stat("Critique").current = 0;
        };

        play = function () {
            this.stat("Actions").current--;
            this.playEffect();
            this.stat("Critique").current += this.stat("Adresse").value();
            if (this.stat("Critique").current > 100) {
                this.stat("Critique").current = 100;
            }
            this.fight();
        };

        fight = function () {
            this.fightEffect();
            
            let defender = this.findTarget();

            let isDie = false;
            let repeat = this.stat("Multicoup").value();
            while (!isDie && repeat > 0) {
                let difDamage = this.stat("Attaque").value() - defender.stat("D√©fense").value();
                if (this.stat("Critique").current == 100) {
                    this.stat("Critique").current = 0;
                    difDamage += difDamage;
                }
                if (difDamage < 0) {
                    difDamage = 0;
                }
                let damage_result = this.findTarget().damage(difDamage);
                if (damage_result.die) {
                    isDie = true;
                    this.killEffect();
                    for (const card of this.equipments) {
                        card.killEffect();
                    }
                }
                repeat--;
            }
        };

        fightEffect = function () {

        };

        killEffect = function () {

        };

        findTarget = function () {
            let target = undefined;
            for (const card of this.owner.adversary().zone("Terrain").cards) {
                if (target == undefined || card.stat("Protection").value() > target.stat("Protection").value()) {
                    target = card;
                }
            }
            return target;
        };

        canEquip = function () {
            if (this.equipments.length < this.stat("Maniement").value()) {
                return true;
            }
            return false;
        };

        equip = function (equipment) {
            this.equipments.push(equipment);
            equipment.remove();
            equipment.bearer = this;

            this.owner.ressource("Mana").current += equipment.equipStat("Magie").value();
            this.owner.ressource("Mana").max += equipment.equipStat("Magie").value();
        };
    }

    class Boss extends Creature {
        constructor(System) {
            super(System);

            this.trait("L√©gendaire").base = true;
        }
    }

    class Kanki extends Boss {
        name = "Kanki, roi des bandits";

        constructor(System) {
            super(System);

            this.level = 4;
            this.elements = ["Neutre"];
            this.familles.base.push("Humain");

            this.stat("Attaque").base = 25;
            this.stat("Vie").base = 100;
            this.stat("Vie").current = 100;
        };
    }

    /* src/Cards/Bosses/Raido/Text.svelte generated by Svelte v3.59.2 */

    const file$1o = "src/Cards/Bosses/Raido/Text.svelte";

    function create_fragment$37(ctx) {
    	let t0;
    	let br0;
    	let t1;
    	let br1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("Quand une cr√©ature alli√©e est pos√©e : augmente de 5 l'attaque et la vie de cette cr√©ature.\n");
    			br0 = element("br");
    			t1 = text("\nQuand une unit√© adverse meurt : produis autant d'or que la vie max de cette cr√©ature.\n");
    			br1 = element("br");
    			t2 = text("\nQuand joue : d√©pense en boucle 1 or et augmente de 1 son attaque et sa vie √† chaque fois.");
    			add_location(br0, file$1o, 6, 0, 155);
    			add_location(br1, file$1o, 8, 0, 247);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$37.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$37($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1H = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$37, create_fragment$37, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$37.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Raido extends Boss {
        name = "Raido, chef brutal";

        constructor(System) {
            super(System);

            this.level = 2;
            this.elements = ["Neutre"];
            this.familles.base.push("Humain");

            this.stat("Attaque").base = 10;
            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;

            this.text = Text$1H;
        };

        otherPoseEffect = function (card) {
            console.log(card.owner == this.owner);
            if (this.zone.name == "Terrain" && card.owner == this.owner && card.type == "Cr√©ature") {
                card.stat("Attaque").base += 5;
                card.stat("Vie").current += 5;
                card.stat("Vie").base += 5;
            }
        };

        otherDieEffect = function (card) {
            if (this.zone.name == "Terrain" && card.owner != this.owner) {
                this.owner.ressource("Or").current += card.stat("Vie").value(); 
            }
        };

        playEffect = function () {
            while (this.owner.ressource("Or").total() >= 1) {
                this.owner.ressource("Or").spend(1);
                this.stat("Attaque").base++;
                this.stat("Vie").current++;
                this.stat("Vie").base++;
            }
        };
    }

    class Gyoun extends Boss {
        name = "Gyoun, colosse de jade";

        constructor(System) {
            super(System);

            this.level = 6;
            this.elements = ["V√©g√©tal"];
            this.familles.base.push("Elfe");

            this.stat("Attaque").base = 50;
            this.stat("Vie").base = 250;
            this.stat("Vie").current = 250;
        };
    }

    class GoHoumei extends Boss {
        name = "Go Houmei, reine des tours";

        constructor(System) {
            super(System);

            this.level = 8;
            this.elements = ["Terre"];
            this.familles.base.push("Nain");

            this.stat("Attaque").base = 25;
            this.stat("Vie").base = 500;
            this.stat("Vie").current = 500;
        };
    }

    class Atlas extends Boss {
        name = "Atlas, marche-crat√®re";

        constructor(System) {
            super(System);

            this.level = 10;
            this.elements = ["Neutre"];
            this.familles.base.push("G√©ant");

            this.stat("Attaque").base = 100;
            this.stat("Vie").base = 1000;
            this.stat("Vie").current = 1000;
        };
    }

    class Humain extends Creature {
        name = "Humain";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
        };
    }

    class Soldat extends Creature {
        name = "Soldat";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;
        };
    }

    class Guerrier extends Creature {
        name = "Guerrier";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;
            this.stat("D√©fense").base = 5;
        };
    }

    class Cavalier extends Creature {
        name = "Cavalier";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;
            this.stat("Vitesse").base = 1;
        };
    }

    /* src/Cards/Creatures/Bandit/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$36(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : d√©pense 5 or pour augmenter de 5 son attaque et sa vie.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$36.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$36($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1G = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$36, create_fragment$36, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$36.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Bandit extends Creature {
        name = "Bandit";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1G;
        };

        useEffect = function () {
            if (this.owner.ressource("Or").total() >= 5) {
                this.owner.ressource("Or").spend(5);
                this.stat("Attaque").add += 5;
                this.stat("Vie").add += 5;
                this.stat("Vie").current += 5;
            }
            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/Marchand/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$35(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© et au d√©but de la phase de pr√©paration : augmente de 1 la capacit√© en or.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$35.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$35($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1F = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$35, create_fragment$35, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$35.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Marchand extends Creature {
        name = "Marchand";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1F;
        };

        useEffect = function () {
            this.owner.ressource("Or").max++;
            this.move("Terrain");
            this.pose();
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.ressource("Or").max++;
            }
        };
    }

    /* src/Cards/Creatures/Fermier/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$34(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : produis 5 or.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$34.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$34($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1E = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$34, create_fragment$34, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$34.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Fermier extends Creature {
        name = "Fermier";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1E;
        };
        
        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.ressource("Or").current += 5;
            }
        };
    }

    /* src/Cards/Creatures/Voleur/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$33(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand attaque : augmente de 2 la valeur de sa vente en or.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$33.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$33($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1D = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$33, create_fragment$33, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$33.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Voleur extends Creature {
        name = "Voleur";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1D;
        };

        fightEffect = function () {
            this.getVente("Or").base += 2;
        };
    }

    class LoupGris extends Creature {
        name = "Loup gris";

        constructor(System) {
            super(System);

            this.init([["Or", 8]]);
            this.familles.base.push("B√™te");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 10;
        };
    }

    class Chien extends Creature {
        name = "Chien";

        constructor(System) {
            super(System);

            this.init([["Or", 3]]);
            this.familles.base.push("B√™te");
            
            this.stat("Vie").base = 3;
            this.stat("Vie").current = 3;
            this.stat("Attaque").base = 3;
        };
    }

    class Vache extends Creature {
        name = "Vache";

        constructor(System) {
            super(System);

            this.init([["Or", 8]]);
            this.familles.base.push("B√™te");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Vie").base = 5;
        };
    }

    /* src/Cards/Creatures/Mimique/Text.svelte generated by Svelte v3.59.2 */

    const file$1n = "src/Cards/Creatures/Mimique/Text.svelte";

    function create_fragment$32(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Quand pos√© : se place sur le terrain adversaire.\n");
    			br = element("br");
    			t1 = text("\nQuand meurt : l'adversaire pioche 2 cartes.");
    			add_location(br, file$1n, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$32.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$32($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1C = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$32, create_fragment$32, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$32.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Mimique extends Creature {
        name = "Mimique";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1C;
        };

        useEffect = function () {
            this.move("Terrain", this.owner.adversary());
            this.pose();
        };

        dieEffect = function () {
            this.owner.adversary().draw(2);
        };
    }

    /* src/Cards/Creatures/Barbare/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$31(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand attaque : augmente de 2 son attaque.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$31.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$31($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1B = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$31, create_fragment$31, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$31.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Barbare extends Creature {
        name = "Barbare";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1B;
        };

        fightEffect = function () {
            this.stat("Attaque").add += 2;
        };
    }

    class Garde extends Creature {
        name = "Garde";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;
            this.stat("Protection").base = 1;
        };
    }

    /* src/Cards/Creatures/MaitreChien/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$30(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : cr√©e 2 Chien sur le terrain. Au d√©but de la phase de pr√©paration : cr√©e Chien sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$30.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$30($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1A = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$30, create_fragment$30, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$30.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class MaitreChien extends Creature {
        name = "Ma√Ætre chien";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1A;
        };

        useEffect = function () {
            this.owner.getCard("Chien").add("Terrain");
            this.owner.getCard("Chien").add("Terrain");
            this.move("Terrain");
            this.pose();
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.getCard("Chien").add("Terrain");
            }
        };
    }

    /* src/Cards/Creatures/Mendiant/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2$(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : d√©pense 2 or.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1z = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2$, create_fragment$2$, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2$.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Mendiant extends Creature {
        name = "Mendiant";

        constructor(System) {
            super(System);

            this.init([["Or", 1]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1z;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.ressource("Or").spend(2);
            }
        };
    }

    /* src/Cards/Creatures/Bagarreur/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2_(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand une cr√©ature alli√©e est pos√©e : augmente de 5 l'attaque de cette cr√©ature pendant cette √©tape.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1y = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2_, create_fragment$2_, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2_.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Bagarreur extends Creature {
        name = "Bagarreur";

        constructor(System) {
            super(System);

            this.init([["Or", 30]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1y;
        };

        otherPoseEffect = function (card) {
            if (this.zone.name == "Terrain" && card.type == "Cr√©ature" && card.owner == this.owner) {
                card.stat("Attaque").step += 5;
            }
        };
    }

    class Chevalier extends Creature {
        name = "Chevalier";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;
            this.stat("Attaque").base = 20;
            this.stat("D√©fense").base = 5;
        };
    }

    /* src/Cards/Creatures/ChevalierMonte/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2Z(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand meurt : Se tranforme en Chevalier, se soigne toutes ses blessures et reste sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1x = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2Z, create_fragment$2Z, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2Z.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ChevalierMonte extends Creature {
        name = "Chevalier mont√©";

        constructor(System) {
            super(System);

            this.init([["Or", 50]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 20;
            this.stat("Vitesse").base = 1;

            this.text = Text$1x;
        };

        dieEffect = function () {
            this.transform("Chevalier");
            this.zone.cards[this.slot].stat("Vie").current = this.zone.cards[this.slot].stat("Vie").value();
        };

        dieGo = function () {
            
        };
    }

    class Geant extends Creature {
        name = "G√©ant";

        constructor(System) {
            super(System);

            this.init([["Or", 50]]);
            this.familles.base.push("G√©ant");
            
            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;
            this.stat("Attaque").base = 50;
        };
    }

    /* src/Cards/Creatures/Forgeron/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2Y(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : pioche 3 cartes de famille √âquipement.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1w = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2Y, create_fragment$2Y, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2Y.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Forgeron extends Creature {
        name = "Forgeron";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1w;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.familles.base.includes("√âquipement")) {
                    return true;
                }
                return false;
            };
            this.owner.draw(3, condition);
            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/Pretre/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2X(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√©, au choix : augmente de 10 la vie OU soigne 20 blessures d'une cr√©ature alli√©e sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1v = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2X, create_fragment$2X, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2X.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/Pretre/Use.svelte generated by Svelte v3.59.2 */
    const file$1m = "src/Cards/Creatures/Pretre/Use.svelte";

    // (37:0) {:else}
    function create_else_block$9(ctx) {
    	let button;
    	let t1;
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$K,
    				fonction: /*fonction*/ ctx[2]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Retour";
    			t1 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1m, 37, 4, 818);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(37:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:0) {#if choice == undefined}
    function create_if_block$t(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Augmenter la vie de 10";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Soigner 20 blessures";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1m, 22, 8, 472);
    			add_location(br, file$1m, 28, 8, 631);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1m, 29, 8, 646);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1m, 21, 4, 417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(21:0) {#if choice == undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2W(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$t, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*choice*/ ctx[1] == undefined) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$K(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$2W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;
    	let choice = undefined;

    	function fonction(card) {
    		System.game.use.card.useEffect(card, choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(1, choice = "life");
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, choice = "heal");
    	};

    	const click_handler_2 = () => {
    		$$invalidate(1, choice = undefined);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Zone: Zone$1,
    		System,
    		choice,
    		condition: condition$K,
    		fonction
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('choice' in $$props) $$invalidate(1, choice = $$props.choice);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, choice, fonction, click_handler, click_handler_1, click_handler_2];
    }

    let Use$T = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2W, create_fragment$2W, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2W.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Pr√™tre extends Creature {
        name = "Pr√™tre";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1v;
        };
        
        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                let check = false;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (check == false && card.type == "Cr√©ature") {
                        check = true;
                    }
                }

                if (check) {
                    this.System.game.use.set(this, Use$T);
                    this.System.pages.change("Game");
                }
                else {
                    this.useEffect(undefined, undefined);
                }
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target, "life");
                }
                else {
                    this.useEffect(target, undefined);
                }
            }
        };

        useEffect = function (target, choice) {
            if (choice == "life") {
                target.stat("Vie").add += 10;
                target.stat("Vie").current += 10;
            }
            else if (choice == "heal") {
                target.heal(20);
            }
            this.move("Terrain");
            this.pose();
        };
    }

    class Mage extends Creature {
        name = "Mage";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
            this.stat("Magie").base = 5;
        };
    }

    /* src/Cards/Creatures/ElementaireDeFeu/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2V(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand arrive sur le terrain : diminue la capacit√© en feu de 1.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1u = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2V, create_fragment$2V, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2V.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireDeFeu extends Creature {
        name = "√âl√©mentaire de feu";

        constructor(System) {
            super(System);

            this.init([["Feu", 15]]);
            this.familles.base.push("√âl√©mentaire");

            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;
            this.stat("Attaque").base = 20;
            this.text = Text$1u;
        };

        addEffect = function (zone) {
            if (zone == "Terrain" && this.owner.ressource("Feu").max >= 1) {
                this.owner.ressource("Feu").max--;
            }
        };
    }

    /* src/Cards/Creatures/ElementaireDEau/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2U(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand arrive sur le terrain : d√©pense 5 eau pour augmenter de 5 son attaque et sa vie.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1t = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2U, create_fragment$2U, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2U.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireDEau extends Creature {
        name = "√âl√©mentaire d'eau";

        constructor(System) {
            super(System);

            this.init([["Eau", 15]]);
            this.familles.base.push("√âl√©mentaire");

            this.stat("Vie").base = 15;
            this.stat("Vie").current = 15;
            this.stat("Attaque").base = 15;

            this.text = Text$1t;
        };

        text = function () {
            return "";
        };

        addEffect = function (zone) {
            if (zone == "Terrain" && this.owner.ressource("Eau").total() >= 5) {
                this.owner.ressource("Eau").spend(5);
                this.stat("Attaque").add += 5;
                this.stat("Vie").add += 5;
                this.stat("Vie").current += 5;
            }
        };
    }

    /* src/Cards/Creatures/ElementaireDesHerbes/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2T(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand meurt : augmente de 5 l'attaque et la vie de la cr√©ature alli√©e sur le terrain la plus en avant.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1s = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2T, create_fragment$2T, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2T.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireDesHerbes extends Creature {
        name = "√âl√©mentaire des herbes";

        constructor(System) {
            super(System);

            this.init([["V√©g√©tal", 15]]);
            this.familles.base.push("√âl√©mentaire");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1s;
        };

        dieEffect = function () {
            let target = undefined;

            for (const card of this.owner.zone("Terrain").cards) {
                if (target == undefined && card.type == "Cr√©ature") {
                    target = card;
                }
            }

            if (target != undefined) {
                target.stat("Attaque").add += 5;
                target.stat("Vie").add += 5;
                target.stat("Vie").current += 5;
            }
        };
    }

    /* src/Cards/Creatures/ElementaireDeTerre/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2S(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√©, au choix : se place sur le terrain OU se d√©truis pour infliger 30 d√©g√¢ts √† une unit√© adverse sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1r = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2S, create_fragment$2S, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2S.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/ElementaireDeTerre/Use.svelte generated by Svelte v3.59.2 */
    const file$1l = "src/Cards/Creatures/ElementaireDeTerre/Use.svelte";

    // (34:0) {:else}
    function create_else_block$8(ctx) {
    	let button;
    	let t1;
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$J,
    				fonction: /*fonction*/ ctx[2]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Retour";
    			t1 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1l, 34, 4, 792);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(34:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#if choice == undefined}
    function create_if_block$s(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Se place sur le terrain";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Se d√©truis pour infliger 30 d√©g√¢ts √† une unit√© adverse sur le terrain";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1l, 19, 8, 390);
    			add_location(br, file$1l, 25, 8, 554);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1l, 26, 8, 569);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1l, 18, 4, 334);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(18:0) {#if choice == undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2R(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$s, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*choice*/ ctx[1] == undefined) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$J(card) {
    	return true;
    }

    function instance$2R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;
    	let choice = undefined;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction(undefined);
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, choice = "damage");
    	};

    	const click_handler_2 = () => {
    		$$invalidate(1, choice = undefined);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Zone: Zone$1,
    		System,
    		choice,
    		condition: condition$J,
    		fonction
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('choice' in $$props) $$invalidate(1, choice = $$props.choice);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, choice, fonction, click_handler, click_handler_1, click_handler_2];
    }

    let Use$S = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2R, create_fragment$2R, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2R.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireDeTerre extends Creature {
        name = "√âl√©mentaire de terre";

        constructor(System) {
            super(System);

            this.init([["Terre", 15]]);
            this.familles.base.push("√âl√©mentaire");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;
            this.stat("D√©fense").base = 5;

            this.text = Text$1r;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.System.game.use.set(this, Use$S);
                    this.System.pages.change("Game");
                }
                else {
                    this.useEffect(undefined);
                }
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
                else {
                    this.useEffect(undefined);
                }
            }
        };

        useEffect = function (target) {
            if (target != undefined) {
                target.damage(30);
                this.destroy();
            }
            else {
                this.move("Terrain");
            }
            this.pose();
        };
    }

    /* src/Cards/Creatures/Elementaliste/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2Q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : pioche 1 carte de famille √âl√©mentaire et r√©duis son co√ªt de 10.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1q = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2Q, create_fragment$2Q, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2Q.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Elementaliste extends Creature {
        name = "√âl√©mentaliste";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1q;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.familles.base.includes("√âl√©mentaire")) {
                    return true;
                }
                return false;
            };
            let cards = this.owner.draw(1, condition);

            if (cards[0] != undefined) {
                cards[0].coutReduce(10);
            }

            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/Cuisinier/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2P(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand une carte de famille Nourriture est pos√©e : produis 3 ressources de l'√©lement de cette carte.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1p = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2P, create_fragment$2P, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2P.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Cuisinier extends Creature {
        name = "Cuisinier";

        constructor(System) {
            super(System);

            this.init([["Or", 30]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1p;
        };

        otherPoseEffect = function (card) {
            if (this.zone.name == "Terrain" && card.familles.base.includes("Nourriture") && card.owner == this.owner) {
                for (const e of card.elements) {
                    if (e != "Neutre") {
                        this.owner.ressource(e).current += 3;
                    }
                    else {
                        this.owner.ressource("Or").current += 3;
                    }
                }
            }
        };
    }

    /* src/Cards/Creatures/ElementaireDeRoche/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2O(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√©, au choix : se place sur le terrain OU se d√©truis pour infliger 5 d√©g√¢ts √† toutes les unit√©s adverse sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1o = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2O, create_fragment$2O, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2O.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/ElementaireDeRoche/Use.svelte generated by Svelte v3.59.2 */

    const file$1k = "src/Cards/Creatures/ElementaireDeRoche/Use.svelte";

    function create_fragment$2N(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Se place sur le terrain";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Se d√©truis pour infliger 5 d√©g√¢ts √† toutes les unit√©s adverses";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1k, 11, 4, 226);
    			add_location(br, file$1k, 17, 4, 367);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1k, 18, 4, 378);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1k, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Cr√©ature");
    	};

    	const click_handler_1 = () => {
    		fonction("Effet");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$R = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2N, create_fragment$2N, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2N.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireDeRoche extends Creature {
        name = "√âl√©mentaire de roche";

        constructor(System) {
            super(System);

            this.init([["Terre", 50]]);
            this.familles.base.push("√âl√©mentaire");
            
            this.stat("Vie").base = 40;
            this.stat("Vie").current = 40;
            this.stat("Attaque").base = 40;
            this.stat("D√©fense").base = 10;

            this.text = Text$1o;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$R);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 5) {
                    this.useEffect("Effet");
                }
                else {
                    this.useEffect("Cr√©ature");
                }
            }
        };

        useEffect = function (choice) {
            if (choice == "Cr√©ature") {
                this.move("Terrain");
            }
            else if (choice == "Effet") {
                let terrain = this.System.copy(this.owner.adversary().zone("Terrain").cards);
                for (const card of terrain) {
                    card.damage(5);
                }
                this.destroy();
            }
            this.pose();
        };
    }

    /* src/Cards/Creatures/ElementaireMarin/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2M(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : d√©pense 5 eau pour augmenter de 5 son attaque et sa vie.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1n = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2M, create_fragment$2M, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2M.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireMarin extends Creature {
        name = "√âl√©mentaire marin";

        constructor(System) {
            super(System);

            this.init([["Eau", 50]]);
            this.familles.base.push("√âl√©mentaire");

            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;
            this.stat("Attaque").base = 50;

            this.text = Text$1n;
        };

        startStepEffect = function () {
            if (this.zone == "Terrain" && this.owner.ressource("Eau").total() >= 5) {
                this.owner.ressource("Eau").spend(5);
                this.stat("Attaque").add += 5;
                this.stat("Vie").add += 5;
                this.stat("Vie").current += 5;
            }
        };
    }

    /* src/Cards/Creatures/ElementaireExplosif/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2L(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand meurt : diminue la capacit√© en feu de 5 pour infliger 5 d√©g√¢ts √† toutes les unit√©s adverse.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1m = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2L, create_fragment$2L, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2L.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireExplosif extends Creature {
        name = "√âl√©mentaire explosif";

        constructor(System) {
            super(System);

            this.init([["Feu", 50]]);
            this.familles.base.push("√âl√©mentaire");

            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;
            this.stat("Attaque").base = 50;

            this.text = Text$1m;
        };

        dieEffect = function () {
            if (this.owner.ressource("Feu").max >= 5) {
                this.owner.ressource("Feu").max -= 5;
                let terrain = this.System.copy(this.owner.adversary().zone("Terrain").cards);
                for (const card of terrain) {
                    card.damage(5);
                }
            }
        };
    }

    /* src/Cards/Creatures/ElementaireDesRacines/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2K(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand meurt : augmente l'attaque et la vie de la cr√©ature alli√©e sur le terrain la plus en avant de la m√™me valeur que son attaque et sa vie.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1l = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2K, create_fragment$2K, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2K.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class ElementaireDesRacines extends Creature {
        name = "√âl√©mentaire des racines";

        constructor(System) {
            super(System);

            this.init([["V√©g√©tal", 50]]);
            this.familles.base.push("√âl√©mentaire");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1l;
        };

        dieEffect = function () {
            let target = undefined;

            for (const card of this.owner.zone("Terrain").cards) {
                if (target == undefined && card.type == "Cr√©ature") {
                    target = card;
                }
            }

            if (target != undefined) {
                target.stat("Attaque").add += this.stat("Attaque").value();
                target.stat("Vie").add += this.stat("Vie").value();
                target.stat("Vie").current += this.stat("Vie").value();
            }
        };
    }

    class GuerrierGeant extends Creature {
        name = "Guerrier g√©ant";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.familles.base.push("G√©ant");
            
            this.stat("Vie").base = 75;
            this.stat("Vie").current = 75;
            this.stat("Attaque").base = 75;
            this.stat("D√©fense").base = 25;
        };
    }

    class Archimage extends Creature {
        name = "Archimage";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;
            this.stat("Attaque").base = 50;
            this.stat("Magie").base = 50;
        };
    }

    /* src/Cards/Creatures/Stratege/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2J(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : pioche 2 actions.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1k = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2J, create_fragment$2J, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2J.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Strat√®ge extends Creature {
        name = "Strat√®ge";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
            this.stat("Intelligence").base = 2;

            this.text = Text$1k;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.type == "Action") {
                    return true;
                }
                return false;
            };
            this.owner.draw(2, condition);
            this.move("Terrain");
            this.pose();
        };
    }

    class Elfe extends Creature {
        name = "Elfe";

        constructor(System) {
            super(System);

            this.init([["Or", 4], ["V√©g√©tal", 4]]);
            this.familles.base.push("Elfe");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 5;
        };
    }

    class Nain extends Creature {
        name = "Nain";

        constructor(System) {
            super(System);

            this.init([["Or", 4], ["Terre", 4]]);
            this.familles.base.push("Nain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
            this.stat("D√©fense").base = 3;
        };
    }

    class Gobelin extends Creature {
        name = "Gobelin";

        constructor(System) {
            super(System);

            this.init([["Or", 3], ["Feu", 2]]);
            this.familles.base.push("Gobelin");
            
            this.stat("Vie").base = 3;
            this.stat("Vie").current = 3;
            this.stat("Attaque").base = 10;
        };
    }

    /* src/Cards/Creatures/Ondin/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2I(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand arrive sur le terrain : produis 5 eau.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1j = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2I, create_fragment$2I, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2I.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Ondin extends Creature {
        name = "Ondin";

        constructor(System) {
            super(System);

            this.init([["Or", 5], ["Eau", 5]]);
            this.familles.base.push("Ondin");

            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1j;
        };

        addEffect = function (zone) {
            if (zone == "Terrain") {
                this.owner.ressource("Eau").current += 5;
            }
        };
    }

    /* src/Cards/Creatures/Cheval/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2H(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : augmente de 1 la vitesse d'une cr√©ature alli√©e sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1i = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2H, create_fragment$2H, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2H.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/Cheval/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$2G(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$I,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$I(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$2G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$I, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$Q = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2G, create_fragment$2G, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2G.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Cheval extends Creature {
        name = "Cheval";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.familles.base.push("B√™te");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
            this.stat("Vitesse").base = 1;

            this.text = Text$1i;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                let check = false;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (check == false && card.type == "Cr√©ature") {
                        check = true;
                    }
                }

                if (check) {
                    this.System.game.use.set(this, Use$Q);
                    this.System.pages.change("Game");
                }
                else {
                    this.useEffect(undefined);
                }
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
                else {
                    this.useEffect(undefined);
                }
            }
        };

        useEffect = function (target) {
            if (target != undefined) {
                target.stat("Vitesse").add += 1;
            }
            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/Architecte/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2F(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : pioche 1 b√¢timent et r√©duis son co√ªt de 10.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1h = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2F, create_fragment$2F, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2F.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Architecte extends Creature {
        name = "Architecte";

        constructor(System) {
            super(System);

            this.init([["Or", 12], ["Terre", 12]]);
            this.familles.base.push("Nain");

            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
            this.stat("D√©fense").base = 3;

            this.text = Text$1h;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.type == "B√¢timent") {
                    return true;
                }
                return false;
            };
            let cards = this.owner.draw(1, condition);

            if (cards[0] != undefined) {
                cards[0].coutReduce(10);
            }

            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/Roi/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2E(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : augmente de 10 l'attaque et la vie de toutes les cr√©atures sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1g = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2E, create_fragment$2E, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2E.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Roi extends Creature {
        name = "Roi";

        constructor(System) {
            super(System);

            this.init([["Or", 110]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1g;
        };

        useEffect = function () {
            let terrain = this.System.copy(this.owner.zone("Terrain").cards);
            for (const card of terrain) {
                if (card.type == "Cr√©ature") {
                    card.stat("Attaque").add += 10;
                    card.stat("Vie").current += 10;
                    card.stat("Vie").add += 10;
                }
            }
            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/Reine/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2D(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : augmente de 100 l'attaque et la vie d'une cr√©ature alli√©e sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1f = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2D, create_fragment$2D, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2D.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/Reine/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$2C(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$H,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$H(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$2C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$H, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$P = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2C, create_fragment$2C, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2C.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Reine extends Creature {
        name = "Reine";

        constructor(System) {
            super(System);

            this.init([["Or", 110]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1f;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                let check = false;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (check == false && card.type == "Cr√©ature") {
                        check = true;
                    }
                }

                if (check) {
                    this.System.game.use.set(this, Use$P);
                    this.System.pages.change("Game");
                }
                else {
                    this.useEffect(undefined);
                }
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
                else {
                    this.useEffect(undefined);
                }
            }
        };

        useEffect = function (target) {
            if (target != undefined) {
                target.stat("Vie").current += 100;
                target.stat("Vie").add += 100;
                target.stat("Attaque").add += 100;
            }
            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/Heros/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2B(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand une cr√©ature alli√©e est pos√©e : augmente de 10 son attaque et sa vie.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1e = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2B, create_fragment$2B, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2B.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Heros extends Creature {
        name = "H√©ros";

        constructor(System) {
            super(System);

            this.init([["Or", 110]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1e;
        };

        otherPoseEffect = function (card) {
            if (this.zone.name == "Terrain" && card.type == "Cr√©ature" && card.owner == this.owner) {
                this.stat("Vie").current += 10;
                this.stat("Vie").add += 10;
                this.stat("Attaque").add += 10;
            }
        };
    }

    /* src/Cards/Creatures/Prince/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2A(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : augmente de 10 son attaque et sa vie pour chaque cr√©ature alli√©es sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1d = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2A, create_fragment$2A, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2A.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Prince extends Creature {
        name = "Prince";

        constructor(System) {
            super(System);

            this.init([["Or", 110]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1d;
        };

        useEffect = function () {
            let terrain = this.System.copy(this.owner.zone("Terrain").cards);
            for (const card of terrain) {
                if (card.type == "Cr√©ature") {
                    this.stat("Attaque").add += 10;
                    this.stat("Vie").current += 10;
                    this.stat("Vie").add += 10;
                }
            }
            this.move("Terrain");
            this.pose();
        };
    }

    class GuerrierGobelin extends Creature {
        name = "Guerrier gobelin";

        constructor(System) {
            super(System);

            this.init([["Or", 10], ["Feu", 10]]);
            this.familles.base.push("Gobelin");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 20;
            this.stat("D√©fense").base = 5;
        };
    }

    /* src/Cards/Creatures/Lion/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2z(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : augmente de 5 l'attaque et la vie de toutes les cr√©atures de famille B√™te sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1c = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2z, create_fragment$2z, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2z.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Lion extends Creature {
        name = "Lion";

        constructor(System) {
            super(System);

            this.init([["Or", 30], ["Feu", 30]]);
            this.familles.base.push("B√™te");

            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;
            this.stat("Attaque").base = 20;

            this.text = Text$1c;
        };

        useEffect = function () {
            let terrain = this.System.copy(this.owner.zone("Terrain").cards);
            for (const card of terrain) {
                if (card.type == "Cr√©ature" && card.familles.base.includes("B√™te")) {
                    card.stat("Attaque").add += 5;
                    card.stat("Vie").current += 5;
                    card.stat("Vie").add += 5;
                }
            }
            this.move("Terrain");
            this.pose();
        };
    }

    class Renard extends Creature {
        name = "Renard";

        constructor(System) {
            super(System);

            this.init([["Or", 8], ["V√©g√©tal", 8]]);
            this.familles.base.push("B√™te");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
            this.stat("Intelligence").base = 2;
        };
    }

    /* src/Cards/Creatures/Dresseur/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2y(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand pos√© : pioche 1 cr√©ature de famille B√™te et augmente de 10 l'attaque et la vie de cette cr√©ature.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1b = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2y, create_fragment$2y, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2y.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Dresseur extends Creature {
        name = "Dresseur";

        constructor(System) {
            super(System);

            this.init([["Or", 10], ["V√©g√©tal", 10]]);
            this.familles.base.push("Elfe");

            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;

            this.text = Text$1b;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.type == "Cr√©ature" && card.familles.base.includes("B√™te")) {
                    return true;
                }
                return false;
            };
            let cards = this.owner.draw(1, condition);

            if (cards[0] != undefined) {
                cards[0].stat("Vie").add += 10;
                cards[0].stat("Vie").current += 10;
                cards[0].stat("Attaque").add += 10;
            }

            this.move("Terrain");
            this.pose();
        };
    }

    /* src/Cards/Creatures/OndinDesRivieres/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2x(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : produis 10 eau.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1a = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2x, create_fragment$2x, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2x.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class OndinDesRivieres extends Creature {
        name = "Ondin des rivi√®res";

        constructor(System) {
            super(System);

            this.init([["Or", 12], ["Eau", 12]]);
            this.familles.base.push("Ondin");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$1a;
        };
        
        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.ressource("Eau").current += 10;
            }
        };
    }

    /* src/Cards/Creatures/Champion/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2w(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Si est plac√© en premi√®re position : double son attaque et sa d√©fense.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$19 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2w, create_fragment$2w, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2w.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Champion extends Creature {
        name = "Champion";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.familles.base.push("Humain");

            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;
            this.stat("Attaque").base = 20;
            this.stat("D√©fense").base = 5;

            this.text = Text$19;

            this.stat("Attaque").value = function () {
                let total = this.base + this.add + this.step;
                if (this.card.type == "Cr√©ature") {
                    for (const equipment of this.card.equipments) {
                        total += equipment.equipStat(this.name).value();
                    }
                }

                if (this.card.System.game != undefined && this.card.zone.name == "Terrain" && this.card.slot == 0) {
                    total += total;
                }
        
                if (total > 0) {
                    return total;
                }
                else {
                    return 0;
                }
            };

            this.stat("D√©fense").value = function () {
                let total = this.base + this.add + this.step;
                if (this.card.type == "Cr√©ature") {
                    for (const equipment of this.card.equipments) {
                        total += equipment.equipStat(this.name).value();
                    }
                }

                if (this.card.System.game != undefined && this.card.zone.name == "Terrain" && this.card.slot == 0) {
                    total += total;
                }
        
                if (total > 0) {
                    return total;
                }
                else {
                    return 0;
                }
            };
        };
    }

    class ChevalierGeant extends Creature {
        name = "Chevalier g√©ant";

        constructor(System) {
            super(System);

            this.init([["Or", 150]]);
            this.familles.base.push("G√©ant");
            
            this.stat("Vie").base = 120;
            this.stat("Vie").current = 120;
            this.stat("Attaque").base = 120;
            this.stat("D√©fense").base = 30;
        };
    }

    /* src/Cards/Creatures/DruideDesPlaines/Text.svelte generated by Svelte v3.59.2 */

    const file$1j = "src/Cards/Creatures/DruideDesPlaines/Text.svelte";

    // (8:0) {#if card.name == "Druide des plaines (forme humain)"}
    function create_if_block$r(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : pioche 2 cartes.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(8:0) {#if card.name == \\\"Druide des plaines (forme humain)\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2v(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*card*/ ctx[0].name == "Druide des plaines (forme humain)" && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("Quand pos√©, au choix : se transforme en Druide des plaines (forme humaine) OU se transforme en Druide des plaines (forme loup).\n");
    			br = element("br");
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$1j, 6, 0, 192);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[0].name == "Druide des plaines (forme humain)") {
    				if (if_block) ; else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card, System];
    }

    let Text$18 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2v, create_fragment$2v, safe_not_equal, { System: 1, card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2v.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/DruideDesPlaines/Use.svelte generated by Svelte v3.59.2 */

    const file$1i = "src/Cards/Creatures/DruideDesPlaines/Use.svelte";

    function create_fragment$2u(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Forme humain";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Forme loup";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1i, 11, 4, 226);
    			add_location(br, file$1i, 17, 4, 354);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1i, 18, 4, 365);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1i, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Humain");
    	};

    	const click_handler_1 = () => {
    		fonction("Loup");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$O = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2u, create_fragment$2u, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2u.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DruideDesPlaines extends Creature {
        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.familles.base.push("Druide");

            this.text = Text$18;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$O);
                this.System.pages.change("Game");
            }
            else {
                this.useEffect("Loup");
            }
        };

        useEffect = function (choice) {
            if (choice == "Humain") {
                this.transform("Druide des plaines (forme humain)");
            }
            else if (choice == "Loup") {
                this.transform("Druide des plaines (forme loup)");
            }
            this.zone.cards[this.slot].move("Terrain");
            this.pose();
        };
    }

    class DruideDesPlainesHumain extends DruideDesPlaines {
        name = "Druide des plaines (forme humain)";
        otherForm = "Druide des plaines (forme loup)";

        constructor(System) {
            super(System);

            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.draw(2);
            }
        };
    }

    class DruideDesPlainesLoup extends DruideDesPlaines {
        name = "Druide des plaines (forme loup)";
        otherForm = "Druide des plaines (forme humain)";

        constructor(System) {
            super(System);

            this.familles.base.push("B√™te");

            this.trait("Rare").base = true;
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 30;
        };
    }

    /* src/Cards/Creatures/Princesse/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2t(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand une cr√©ature alli√©e est pos√©e : augmente de 10 l'attaque et la vie de cette cr√©ature.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$17 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2t, create_fragment$2t, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2t.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Princesse extends Creature {
        name = "Princesse";

        constructor(System) {
            super(System);

            this.init([["Or", 105]]);
            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;

            this.text = Text$17;
        };

        otherPoseEffect = function (card) {
            if (this.zone.name == "Terrain" && card.type == "Cr√©ature" && card.owner == this.owner) {
                card.stat("Vie").add += 10;
                card.stat("Vie").current += 10;
                card.stat("Attaque").add += 10;
            }
        };
    }

    class OursDesMontagnes extends Creature {
        name = "Ours des montagnes";

        constructor(System) {
            super(System);

            this.init([["Or", 20], ["Terre", 20]]);
            this.familles.base.push("B√™te");
            
            this.stat("Vie").base = 35;
            this.stat("Vie").current = 35;
            this.stat("Attaque").base = 35;
            this.stat("D√©fense").base = 5;
        };
    }

    class OursForestier extends Creature {
        name = "Ours forestier";

        constructor(System) {
            super(System);

            this.init([["Or", 20], ["V√©g√©tal", 20]]);
            this.familles.base.push("B√™te");
            
            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;
            this.stat("Attaque").base = 30;
        };
    }

    class Tortue extends Creature {
        name = "Tortue";

        constructor(System) {
            super(System);

            this.init([["Or", 8], ["Eau", 8]]);
            this.familles.base.push("Reptile");

            this.stat("Vie").base = 15;
            this.stat("Vie").current = 15;
            this.stat("Attaque").base = 5;
            this.stat("D√©fense").base = 5;
        };
    }

    /* src/Cards/Creatures/TortueSolide/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2s(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand meurt : cr√©e Carapace de tortue dans la main.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$16 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2s, create_fragment$2s, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2s.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class TortueSolide extends Creature {
        name = "Tortue solide";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["Eau", 15]]);
            this.familles.base.push("Reptile");

            this.stat("Vie").base = 15;
            this.stat("Vie").current = 15;
            this.stat("Attaque").base = 5;
            this.stat("D√©fense").base = 5;

            this.text = Text$16;
        };

        dieEffect = function () {
            this.owner.getCard("Carapace de tortue").add("Main");
        };
    }

    /* src/Cards/Creatures/DruideMarchand/Text.svelte generated by Svelte v3.59.2 */

    const file$1h = "src/Cards/Creatures/DruideMarchand/Text.svelte";

    // (8:0) {#if card.name == "Druide marchand (forme humain)"}
    function create_if_block$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : augmente de 1 la capacit√© en or.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(8:0) {#if card.name == \\\"Druide marchand (forme humain)\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2r(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*card*/ ctx[0].name == "Druide marchand (forme humain)" && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("Quand pos√©, au choix : se transforme en Druide marchand (forme humaine) OU se transforme en Druide marchand (forme boeuf).\n");
    			br = element("br");
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$1h, 6, 0, 187);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[0].name == "Druide marchand (forme humain)") {
    				if (if_block) ; else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card, System];
    }

    let Text$15 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2r, create_fragment$2r, safe_not_equal, { System: 1, card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2r.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/DruideMarchand/Use.svelte generated by Svelte v3.59.2 */

    const file$1g = "src/Cards/Creatures/DruideMarchand/Use.svelte";

    function create_fragment$2q(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Forme humain";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Forme boeuf";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1g, 11, 4, 226);
    			add_location(br, file$1g, 17, 4, 354);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1g, 18, 4, 365);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1g, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Humain");
    	};

    	const click_handler_1 = () => {
    		fonction("Boeuf");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$N = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2q, create_fragment$2q, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2q.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DruideMarchand extends Creature {
        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.familles.base.push("Druide");

            this.text = Text$15;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$N);
                this.System.pages.change("Game");
            }
            else {
                this.useEffect("Boeuf");
            }
        };

        useEffect = function (choice) {
            if (choice == "Humain") {
                this.transform("Druide marchand (forme humain)");
            }
            else if (choice == "Boeuf") {
                this.transform("Druide marchand (forme boeuf)");
            }
            this.zone.cards[this.slot].move("Terrain");
            this.pose();
        };
    }

    class DruideMarchandHumain extends DruideMarchand {
        name = "Druide marchand (forme humain)";
        otherForm = "Druide marchand (forme boeuf)";

        constructor(System) {
            super(System);

            this.familles.base.push("Humain");
            
            this.stat("Vie").base = 10;
            this.stat("Vie").current = 10;
            this.stat("Attaque").base = 10;
        };

        startStepEffect = function () {
            this.owner.ressource("Or").max += 1;
        };
    }

    class DruideMarchandBoeuf extends DruideMarchand {
        name = "Druide marchand (forme boeuf)";
        otherForm = "Druide marchand (forme humain)";

        constructor(System) {
            super(System);

            this.familles.base.push("B√™te");

            this.trait("Rare").base = true;
            
            this.stat("Vie").base = 30;
            this.stat("Vie").current = 30;
            this.stat("Attaque").base = 10;
        };
    }

    /* src/Cards/Creatures/DruideDesRecifs/Text.svelte generated by Svelte v3.59.2 */

    const file$1f = "src/Cards/Creatures/DruideDesRecifs/Text.svelte";

    // (8:0) {#if card.name == "Druide des r√©cifs (forme ondin)"}
    function create_if_block$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : augmente de 1 la capacit√© en eau.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(8:0) {#if card.name == \\\"Druide des r√©cifs (forme ondin)\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2p(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*card*/ ctx[0].name == "Druide des r√©cifs (forme ondin)" && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("Quand pos√©, au choix : se transforme en Druide des r√©cifs (forme ondin) OU se transforme en Druide des r√©cifs (forme tortue).\n");
    			br = element("br");
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$1f, 6, 0, 190);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[0].name == "Druide des r√©cifs (forme ondin)") {
    				if (if_block) ; else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card, System];
    }

    let Text$14 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2p, create_fragment$2p, safe_not_equal, { System: 1, card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2p.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/DruideDesRecifs/Use.svelte generated by Svelte v3.59.2 */

    const file$1e = "src/Cards/Creatures/DruideDesRecifs/Use.svelte";

    function create_fragment$2o(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Forme ondin";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Forme tortue";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1e, 11, 4, 226);
    			add_location(br, file$1e, 17, 4, 352);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1e, 18, 4, 363);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1e, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Ondin");
    	};

    	const click_handler_1 = () => {
    		fonction("Tortue");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$M = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2o, create_fragment$2o, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2o.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DruideDesRecifs extends Creature {
        constructor(System) {
            super(System);

            this.init([["Or", 25], ["Eau", 25]]);
            this.familles.base.push("Druide");

            this.text = Text$14;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$M);
                this.System.pages.change("Game");
            }
            else {
                this.useEffect("Tortue");
            }
        };

        useEffect = function (choice) {
            if (choice == "Ondin") {
                this.transform("Druide des r√©cifs (forme ondin)");
            }
            else if (choice == "Tortue") {
                this.transform("Druide des r√©cifs (forme tortue)");
            }
            this.zone.cards[this.slot].move("Terrain");
            this.pose();
        };
    }

    class DruideDesRecifsOndin extends DruideDesRecifs {
        name = "Druide des r√©cifs (forme ondin)";
        otherForm = "Druide des r√©cifs (forme tortue)";

        constructor(System) {
            super(System);

            this.familles.base.push("Ondin");
            
            this.stat("Vie").base = 30;
            this.stat("Vie").current = 30;
            this.stat("Attaque").base = 30;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.owner.ressource("Eau").max += 2;
            }
        };
    }

    class DruideDesRecifsTortue extends DruideDesRecifs {
        name = "Druide des r√©cifs (forme tortue)";
        otherForm = "Druide des r√©cifs (forme ondin)";

        constructor(System) {
            super(System);

            this.familles.base.push("Reptile");

            this.trait("Rare").base = true;
            
            this.stat("Vie").base = 40;
            this.stat("Vie").current = 40;
            this.stat("Attaque").base = 40;
            this.stat("D√©fense").base = 10;
        };
    }

    /* src/Cards/Creatures/DruideDesBois/Text.svelte generated by Svelte v3.59.2 */

    const file$1d = "src/Cards/Creatures/DruideDesBois/Text.svelte";

    // (8:0) {#if card.name == "Druide des bois (forme elfe)"}
    function create_if_block$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Quand une action alli√©e est jou√©e : augmente de 1 sa vie.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(8:0) {#if card.name == \\\"Druide des bois (forme elfe)\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2n(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*card*/ ctx[0].name == "Druide des bois (forme elfe)" && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("Quand pos√©, au choix : se transforme en Druide des bois (forme elfe) OU se transforme en Druide des bois (forme renard).\n");
    			br = element("br");
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$1d, 6, 0, 185);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[0].name == "Druide des bois (forme elfe)") {
    				if (if_block) ; else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card, System];
    }

    let Text$13 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2n, create_fragment$2n, safe_not_equal, { System: 1, card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2n.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/DruideDesBois/Use.svelte generated by Svelte v3.59.2 */

    const file$1c = "src/Cards/Creatures/DruideDesBois/Use.svelte";

    function create_fragment$2m(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Forme elfe";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Forme renard";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1c, 11, 4, 226);
    			add_location(br, file$1c, 17, 4, 350);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1c, 18, 4, 361);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1c, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Elfe");
    	};

    	const click_handler_1 = () => {
    		fonction("Renard");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$L = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2m, create_fragment$2m, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2m.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DruideDesBois extends Creature {
        constructor(System) {
            super(System);

            this.init([["Or", 25], ["V√©g√©tal", 25]]);
            this.familles.base.push("Druide");

            this.text = Text$13;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$L);
                this.System.pages.change("Game");
            }
            else {
                this.useEffect("Renard");
            }
        };

        useEffect = function (choice) {
            if (choice == "Elfe") {
                this.transform("Druide des bois (forme elfe)");
            }
            else if (choice == "Renard") {
                this.transform("Druide des bois (forme renard)");
            }
            this.zone.cards[this.slot].move("Terrain");
            this.pose();
        };
    }

    class DruideDesBoisElfe extends DruideDesBois {
        name = "Druide des bois (forme elfe)";
        otherForm = "Druide des bois (forme renard)";

        constructor(System) {
            super(System);

            this.familles.base.push("Elfe");
            
            this.stat("Vie").base = 20;
            this.stat("Vie").current = 20;
            this.stat("Attaque").base = 20;
        };

        otherPoseEffect = function (card) {
            if (card.owner == this.owner && card.type == "Action") {
                this.stat("Vie").current += 3;
                this.stat("Vie").add += 3;
            }
        };
    }

    class DruideDesBoisRenard extends DruideDesBois {
        name = "Druide des bois (forme renard)";
        otherForm = "Druide des bois (forme elfe)";

        constructor(System) {
            super(System);

            this.familles.base.push("B√™te");

            this.trait("Rare").base = true;
            
            this.stat("Vie").base = 25;
            this.stat("Vie").current = 25;
            this.stat("Attaque").base = 25;
            this.stat("Intelligence").base = 5;
        };
    }

    /* src/Cards/Creatures/DruideDeFeu/Text.svelte generated by Svelte v3.59.2 */

    const file$1b = "src/Cards/Creatures/DruideDeFeu/Text.svelte";

    // (8:0) {#if card.name == "Druide de feu (forme gobelin)"}
    function create_if_block$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : augmente son attaque de 10.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(8:0) {#if card.name == \\\"Druide de feu (forme gobelin)\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2l(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*card*/ ctx[0].name == "Druide de feu (forme gobelin)" && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("Quand pos√©, au choix : se transforme en Druide de feu (forme gobelin) OU se transforme en Druide de feu (forme l√©zard).\n");
    			br = element("br");
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$1b, 6, 0, 184);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[0].name == "Druide de feu (forme gobelin)") {
    				if (if_block) ; else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card, System];
    }

    let Text$12 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2l, create_fragment$2l, safe_not_equal, { System: 1, card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2l.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/DruideDeFeu/Use.svelte generated by Svelte v3.59.2 */

    const file$1a = "src/Cards/Creatures/DruideDeFeu/Use.svelte";

    function create_fragment$2k(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Forme gobelin";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Forme l√©zard";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$1a, 11, 4, 226);
    			add_location(br, file$1a, 17, 4, 356);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$1a, 18, 4, 367);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$1a, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Gobelin");
    	};

    	const click_handler_1 = () => {
    		fonction("L√©zard");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$K = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2k, create_fragment$2k, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2k.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DruideDeFeu extends Creature {
        constructor(System) {
            super(System);

            this.init([["Or", 25], ["Feu", 25]]);
            this.familles.base.push("Druide");

            this.text = Text$12;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$K);
                this.System.pages.change("Game");
            }
            else {
                this.useEffect("Gobelin");
            }
        };

        useEffect = function (choice) {
            if (choice == "Gobelin") {
                this.transform("Druide de feu (forme gobelin)");
            }
            else if (choice == "L√©zard") {
                this.transform("Druide de feu (forme l√©zard)");
            }
            this.zone.cards[this.slot].move("Terrain");
            this.pose();
        };
    }

    class DruideDeFeuGobelin extends DruideDeFeu {
        name = "Druide de feu (forme gobelin)";
        otherForm = "Druide de feu (forme l√©zard)";

        constructor(System) {
            super(System);

            this.familles.base.push("Gobelin");
            
            this.stat("Vie").base = 40;
            this.stat("Vie").current = 40;
            this.stat("Attaque").base = 40;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.stat("Attaque").add += 10;
            }
        };
    }

    class DruideDeFeuLezard extends DruideDeFeu {
        name = "Druide de feu (forme l√©zard)";
        otherForm = "Druide de feu (forme gobelin)";

        constructor(System) {
            super(System);

            this.familles.base.push("Reptile");

            this.trait("Rare").base = true;
            
            this.stat("Vie").base = 5;
            this.stat("Vie").current = 5;
            this.stat("Attaque").base = 5;
            this.stat("Adresse").base = 20;
        };
    }

    /* src/Cards/Creatures/DruideDesMontagnes/Text.svelte generated by Svelte v3.59.2 */

    const file$19 = "src/Cards/Creatures/DruideDesMontagnes/Text.svelte";

    // (8:0) {#if card.name == "Druide des montagnes (forme nain)"}
    function create_if_block$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Au d√©but de la phase de pr√©paration : augmente son attaque et sa vie de 10.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(8:0) {#if card.name == \\\"Druide des montagnes (forme nain)\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2j(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let if_block_anchor;
    	let if_block = /*card*/ ctx[0].name == "Druide des montagnes (forme nain)" && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("Quand pos√©, au choix : se transforme en Druide des montagnes (forme nain) OU se transforme en Druide des montagnes (forme ours).\n");
    			br = element("br");
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(br, file$19, 6, 0, 193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[0].name == "Druide des montagnes (forme nain)") {
    				if (if_block) ; else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card, System];
    }

    let Text$11 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2j, create_fragment$2j, safe_not_equal, { System: 1, card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2j.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Creatures/DruideDesMontagnes/Use.svelte generated by Svelte v3.59.2 */

    const file$18 = "src/Cards/Creatures/DruideDesMontagnes/Use.svelte";

    function create_fragment$2i(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Forme nain";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Forme ours";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$18, 11, 4, 226);
    			add_location(br, file$18, 17, 4, 350);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$18, 18, 4, 361);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$18, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Nain");
    	};

    	const click_handler_1 = () => {
    		fonction("Ours");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$J = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2i, create_fragment$2i, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2i.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DruideDesMontagnes extends Creature {
        constructor(System) {
            super(System);

            this.init([["Or", 25], ["Terre", 25]]);
            this.familles.base.push("Druide");

            this.text = Text$11;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$J);
                this.System.pages.change("Game");
            }
            else {
                this.useEffect("Ours");
            }
        };

        useEffect = function (choice) {
            if (choice == "Nain") {
                this.transform("Druide des montagnes (forme nain)");
            }
            else if (choice == "Ours") {
                this.transform("Druide des montagnes (forme ours)");
            }
            this.zone.cards[this.slot].move("Terrain");
            this.pose();
        };
    }

    class DruideDesMontagnesNain extends DruideDesMontagnes {
        name = "Druide des montagnes (forme nain)";
        otherForm = "Druide des montagnes (forme ours)";

        constructor(System) {
            super(System);

            this.familles.base.push("Nain");
            
            this.stat("Vie").base = 25;
            this.stat("Vie").current = 25;
            this.stat("Attaque").base = 25;
            this.stat("D√©fense").base = 5;
        };

        startStepEffect = function () {
            if (this.zone.name == "Terrain") {
                this.stat("Vie").add += 10;
                this.stat("Vie").current += 10;
                this.stat("Attaque").add += 10;
            }
        };
    }

    class DruideDesMontagnesOurs extends DruideDesMontagnes {
        name = "Druide des montagnes (forme ours)";
        otherForm = "Druide des montagnes (forme nain)";

        constructor(System) {
            super(System);

            this.familles.base.push("B√™te");

            this.trait("Rare").base = true;
            
            this.stat("Vie").base = 50;
            this.stat("Vie").current = 50;
            this.stat("Attaque").base = 50;
        };
    }

    class Objet extends Card {
        type = "Objet";
    }

    /* src/Cards/Objets/CoffreEnBois/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2h(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Pioche 2 cartes.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$10 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2h, create_fragment$2h, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2h.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CoffreEnBois extends Objet {
        name = "Coffre en bois";

        constructor (System) {
            super(System);

            this.init([["Or", 5]]);

            this.text = Text$10;
        };

        useEffect = function () {
            this.owner.draw(2);
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/FlecheEnBois/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 10 d√©g√¢ts √† une unit√© adverse sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$$ = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2g, create_fragment$2g, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2g.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/FlecheEnBois/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$2f(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$G,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$G(card) {
    	return true;
    }

    function instance$2f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$G, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$I = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2f, create_fragment$2f, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2f.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class FlecheEnBois extends Objet {
        name = "Fl√®che en bois";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);

            this.text = Text$$;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$I);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            target.damage(10);
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/PotionDeSoin/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Soigne 10 blessures √† une cr√©ature alli√©e sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$_ = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2e, create_fragment$2e, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2e.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/PotionDeSoin/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$2d(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$F,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$F(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$2d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$F, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$H = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2d, create_fragment$2d, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$2d.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PotionDeSoin extends Objet {
        name = "Potion de soin";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);

            this.text = Text$_;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$H);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.stat("Vie").current < card.stat("Vie").value()) {
                        target = card;
                    }
                }
                
                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.heal(10);
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Livre/Text.svelte generated by Svelte v3.59.2 */

    const file$17 = "src/Cards/Objets/Livre/Text.svelte";

    function create_fragment$2c(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("D√©couvre 1 carte.\n");
    			br = element("br");
    			t1 = text("\nRuse 2 : D√©couvre 2 cartes √† la place.");
    			add_location(br, file$17, 6, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$Z = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2c, create_fragment$2c, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2c.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Livre extends Objet {
        name = "Livre";

        constructor (System) {
            super(System);

            this.init([["Or", 8]]);

            this.text = Text$Z;
        };

        useEffect = function () {
            if (this.owner.totalIntelligence() >= 2) {
                this.owner.discover(2);
            }
            else {
                this.owner.discover(1);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/PierrePhilosophale/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Produis de l'or et augmente la capacit√© en or du m√™me montant que le flux. D√©pense tout le flux.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$Y = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2b, create_fragment$2b, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2b.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PierrePhilosophale extends Objet {
        name = "Pierre Philosophale";

        constructor (System) {
            super(System);

            this.init([["Or", 5]]);

            this.text = Text$Y;
        };

        use = function () {
            if (this.owner == this.System.game.player || this.owner.flux > 0) {
                this.useEffect();
            }
        };

        useEffect = function () {
            this.owner.ressource("Or").max += this.owner.flux;
            this.owner.ressource("Or").current += this.owner.flux;
            this.owner.flux = 0;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Bombe/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$2a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 30 d√©g√¢ts √† une unit√© adverse sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$X = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2a, create_fragment$2a, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$2a.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/Bombe/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$29(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$E,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$29.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$E(card) {
    	return true;
    }

    function instance$29($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$E, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$G = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$29, create_fragment$29, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$29.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Bombe extends Objet {
        name = "Bombe";

        constructor(System) {
            super(System);

            this.init([["Or", 15]]);

            this.text = Text$X;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$G);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            target.damage(30);
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/CorDeGuerre/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$28(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 5 l'attaque de toutes les cr√©atures alli√©es sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$28.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$28($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$W = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$28, create_fragment$28, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$28.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CorDeGuerre extends Objet {
        name = "Cor de guerre";

        constructor (System) {
            super(System);

            this.init([["Or", 25]]);

            this.text = Text$W;
        };

        use = function () {
            if (this.owner == this.System.game.player || this.owner.zone("Terrain").cards.length > 0) {
                this.useEffect();
            }
        };

        useEffect = function () {
            let terrain = this.System.copy(this.owner.zone("Terrain").cards);
            for (const card of terrain) {
                if (card.type == "Cr√©ature") {
                    card.stat("Attaque").add += 5;
                }
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Banniere/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$27(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 3 l'attaque et la vie de toutes les cr√©atures alli√©es sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$27.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$27($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$V = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$27, create_fragment$27, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$27.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Banniere extends Objet {
        name = "Banni√®re";

        constructor (System) {
            super(System);

            this.init([["Or", 30]]);

            this.text = Text$V;
        };

        use = function () {
            if (this.owner == this.System.game.player || this.owner.zone("Terrain").cards.length > 0) {
                this.useEffect();
            }
        };

        useEffect = function () {
            let terrain = this.System.copy(this.owner.zone("Terrain").cards);
            for (const card of terrain) {
                if (card.type == "Cr√©ature") {
                    card.stat("Attaque").add += 3;
                    card.stat("Vie").current += 3;
                    card.stat("Vie").add += 3;
                }
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Tresor/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$26(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Pioche 5 cartes et produis 10 or.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$26.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$26($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$U = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$26, create_fragment$26, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$26.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Tresor extends Objet {
        name = "Tr√©sor";

        constructor (System) {
            super(System);

            this.init([["Or", 25]]);

            this.text = Text$U;
        };
        
        useEffect = function () {
            this.owner.draw(5);
            this.owner.ressource("Or").current += 10;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/PotionDeMana/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$25(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Produis 5 mana.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$25.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$25($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$T = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$25, create_fragment$25, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$25.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PotionDeMana extends Objet {
        name = "Potion de mana";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);

            this.text = Text$T;
        };

        useEffect = function (target) {
            this.owner.ressource("Mana").current += 5;
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Sifflet/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$24(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Pioche 1 cr√©ature de famille B√™te. Augmente de 1 l'attaque et la vie de toutes les cr√©atures alli√©es de famille B√™te sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$24.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$24($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$S = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$24, create_fragment$24, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$24.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Sifflet extends Objet {
        name = "Sifflet";

        constructor (System) {
            super(System);

            this.init([["Or", 10]]);

            this.text = Text$S;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.type == "Cr√©ature" && card.familles.base.includes("B√™te")) {
                    return true;
                }
                return false;
            };
            this.owner.draw(1, condition);

            let terrain = this.System.copy(this.owner.zone("Terrain").cards);
            for (const card of terrain) {
                if (card.type == "Cr√©ature" && card.familles.base.includes("B√™te")) {
                    card.stat("Attaque").add += 1;
                    card.stat("Vie").current += 1;
                    card.stat("Vie").add += 1;
                }
            }

            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Pain/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$23(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Soigne 10 blessures √† une cr√©ature alli√©e sur le terrain. Si cette cr√©ature n'est pas bless√©e, augmente de 1 la production d'or.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$23.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$23($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$R = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$23, create_fragment$23, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$23.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/Pain/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$22(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$D,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$22.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$D(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$22($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$D, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$F = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$22, create_fragment$22, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$22.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Pain extends Objet {
        name = "Pain";

        constructor(System) {
            super(System);

            this.init([["Or", 8]]);
            this.familles.base.push("Nourriture");

            this.text = Text$R;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$F);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (target.stat("Vie").current == target.stat("Vie").value()) {
                target.owner.ressource("Or").max++;
            }
            else {
                target.heal(10);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Pomme/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$21(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Soigne 10 blessures √† une cr√©ature alli√©e sur le terrain. Si cette cr√©ature n'est pas bless√©e, augmente sa vie de 5.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$21.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$21($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$Q = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$21, create_fragment$21, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$21.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/Pomme/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$20(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$C,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$20.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$C(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$20($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$C, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$E = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$20, create_fragment$20, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$20.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Pomme extends Objet {
        name = "Pomme";

        constructor(System) {
            super(System);

            this.init([["Or", 4], ["V√©g√©tal", 4]]);
            this.familles.base.push("Nourriture");

            this.text = Text$Q;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$E);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (target.stat("Vie").current == target.stat("Vie").value()) {
                target.stat("Vie").add += 5;
                target.stat("Vie").current += 5;
            }
            else {
                target.heal(10);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/PouletRoti/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$1$(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Soigne 10 blessures √† une cr√©ature alli√©e sur le terrain. Si cette cr√©ature n'est pas bless√©e, augmente de 10 son attaque.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$P = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1$, create_fragment$1$, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1$.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/PouletRoti/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1_(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$B,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$B(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$1_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$B, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$D = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1_, create_fragment$1_, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1_.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PouletRoti extends Objet {
        name = "Poulet roti";

        constructor(System) {
            super(System);

            this.init([["Or", 4], ["Feu", 4]]);
            this.familles.base.push("Nourriture");

            this.text = Text$P;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$D);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (target.stat("Vie").current == target.stat("Vie").value()) {
                target.stat("Attaque").add += 10;
            }
            else {
                target.heal(10);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/PommeDeTerre/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$1Z(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Soigne 10 blessures √† une cr√©ature alli√©e sur le terrain. Si cette cr√©ature n'est pas bless√©e, augmente sa d√©fense de 5.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$O = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Z, create_fragment$1Z, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1Z.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/PommeDeTerre/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1Y(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$A,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$A(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$1Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$A, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$C = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Y, create_fragment$1Y, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1Y.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PommeDeTerre extends Objet {
        name = "Pomme de terre";

        constructor(System) {
            super(System);

            this.init([["Or", 4], ["Terre", 4]]);
            this.familles.base.push("Nourriture");

            this.text = Text$O;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$C);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (target.stat("Vie").current == target.stat("Vie").value()) {
                target.stat("D√©fense").add += 5;
            }
            else {
                target.heal(10);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/SardinesEnBoite/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$1X(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Soigne 10 blessures √† une cr√©ature alli√©e sur le terrain. Si cette cr√©ature n'est pas bless√©e, produis 5 eau.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$N = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1X, create_fragment$1X, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1X.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/SardinesEnBoite/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1W(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$z,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$z(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$1W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$z, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$B = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1W, create_fragment$1W, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1W.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class SardinesEnBoite extends Objet {
        name = "Sardines en bo√Æte";

        constructor(System) {
            super(System);

            this.init([["Or", 4], ["Eau", 4]]);
            this.familles.base.push("Nourriture");

            this.text = Text$N;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$B);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (target.stat("Vie").current == target.stat("Vie").value()) {
                target.owner.ressource("Eau").current += 5;
            }
            else {
                target.heal(10);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Bestiaire/Text.svelte generated by Svelte v3.59.2 */

    const file$16 = "src/Cards/Objets/Bestiaire/Text.svelte";

    function create_fragment$1V(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("D√©couvre 3 cr√©atures.\n");
    			br = element("br");
    			t1 = text("\nRuse 10 : D√©couvre 5 cr√©atures √† la place.");
    			add_location(br, file$16, 6, 0, 86);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$M = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1V, create_fragment$1V, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1V.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Bestiaire extends Objet {
        name = "Bestiaire";

        constructor (System) {
            super(System);

            this.init([["Or", 15]]);

            this.text = Text$M;
        };

        useEffect = function () {
            let condition = function (card) {
                if (card.type == "Cr√©ature") {
                    return true;
                }
                return false;
            };

            if (this.owner.totalIntelligence() >= 10) {
                this.owner.discover(5, condition);
            }
            else {
                this.owner.discover(3, condition);
            }

            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Conque/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$1U(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Diminue de 5 la capacit√© en or pour augmenter de 5 la capacit√© en eau.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$L = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1U, create_fragment$1U, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1U.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Conque extends Objet {
        name = "Conque";

        constructor (System) {
            super(System);

            this.init([["Or", 10], ["Eau", 10]]);

            this.text = Text$L;
        };
        
        useEffect = function () {
            if (this.owner.ressource("Or").max > 5) {
                this.owner.ressource("Or").max -= 5;
                this.owner.ressource("Eau").max += 5;
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/CoffreEnOr/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$1T(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Pioche 1 carte du m√™me niveau que la boutique et r√©duis de 20 le co√ªt de cette carte.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$K = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1T, create_fragment$1T, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1T.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CoffreEnOr extends Objet {
        name = "Coffre en or";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);

            this.text = Text$K;
        };

        useEffect = function () {
            let condition = function (card, drawer) {
                if (drawer.owner.zone("Boutique").level == card.level) {
                    return true;
                }
                return false;
            };
            let cards = this.owner.draw(1, condition, this);
            cards[0].coutReduce(20);
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Torche/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$1S(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 2 la capacit√© en feu OU inflige 20 d√©g√¢ts √† une unit√© adverse sur le terrain.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$J = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1S, create_fragment$1S, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1S.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Objets/Torche/Use.svelte generated by Svelte v3.59.2 */
    const file$15 = "src/Cards/Objets/Torche/Use.svelte";

    // (34:29) 
    function create_if_block_1$f(ctx) {
    	let button;
    	let t1;
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$y,
    				fonction: /*fonction*/ ctx[2]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Retour";
    			t1 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$15, 34, 4, 777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(34:29) ",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#if choice == undefined}
    function create_if_block$l(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Augmente de 2 la capacit√© en feu";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Inflige 10 d√©g√¢ts √† une unit√© adverse sur le terrain";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$15, 19, 8, 361);
    			add_location(br, file$15, 25, 8, 534);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$15, 26, 8, 549);
    			attr_dev(div, "class", "center");
    			add_location(div, file$15, 18, 4, 332);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(18:0) {#if choice == undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1R(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$l, create_if_block_1$f];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*choice*/ ctx[1] == undefined) return 0;
    		if (/*choice*/ ctx[1] == "damage") return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$y() {
    	return true;
    }

    function instance$1R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;
    	let choice = undefined;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction(undefined);
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, choice = "damage");
    	};

    	const click_handler_2 = () => {
    		$$invalidate(1, choice = undefined);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Zone: Zone$1,
    		System,
    		choice,
    		condition: condition$y,
    		fonction
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('choice' in $$props) $$invalidate(1, choice = $$props.choice);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, choice, fonction, click_handler, click_handler_1, click_handler_2];
    }

    let Use$A = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1R, create_fragment$1R, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1R.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Torche extends Objet {
        name = "Torche";

        constructor(System) {
            super(System);

            this.init([["Or", 8], ["Feu", 8]]);

            this.text = Text$J;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$A);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            if (target == undefined) {
                this.owner.ressource("Feu").max += 2;
            }
            else {
                target.damage(20);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Objets/Trefle/Text.svelte generated by Svelte v3.59.2 */

    const file$14 = "src/Cards/Objets/Trefle/Text.svelte";

    function create_fragment$1Q(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("D√©couvre 1 carte.\n");
    			br = element("br");
    			t1 = text("\nRuse 2 : D√©couvre 2 cartes √† la place.");
    			add_location(br, file$14, 6, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$I = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1Q.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Trefle extends Objet {
        name = "Tr√®fle";

        constructor (System) {
            super(System);

            this.init([["Or", 10], ["V√©g√©tal", 10]]);
            this.familles.base.push("Plante");

            this.text = Text$I;
        };

        useEffect = function () {
            this.owner.discover(4);
            this.move("D√©fausse");
            this.pose();
        };
    }

    class Equipment extends Objet {
        equipTraits = [];
        equipStats = [];
        bearer = undefined;

        constructor(System) {
            super(System);

            this.familles.base.push("√âquipement");

            this.addEquipTrait("L√©gendaire", false);

            this.addEquipStat("Attaque", 0);
            this.addEquipStat("Vie", 0);
            this.addEquipStat("D√©fense", 0);
            this.addEquipStat("Actions", 0);
            this.addEquipStat("Multicoup", 0);
            this.addEquipStat("Vitesse", 0);
            this.addEquipStat("Protection", 0);
            this.addEquipStat("Maniement", 0);
            this.addEquipStat("Magie", 0);
            this.addEquipStat("Intelligence", 0);
            this.addEquipStat("Adresse", 0);

            this.addEquipStat("Endurance", 0);
            this.addEquipStat("Perp√©tuit√©", 0);
            this.addEquipStat("Esquive", 0);
        };

        remove = function () {
            this.zone.cards.splice(this.slot, 1);
            for (let i = this.slot; i < this.zone.cards.length; i++) {
                this.zone.cards[i].slot--;
            }
            this.zone = undefined;
            this.slot = undefined;
            this.bearer = undefined;
        };

        equipStat = function (name) {
            for (const stat of this.equipStats) {
                if (stat.name == name) {
                    return stat;
                }
            }
        };

        addEquipStat = function (name, value) {
            let stat = new Stat$1(name, value, this);
            stat.value = function () {
                return this.base;
            };
            this.equipStats.push(stat);
        };

        equipTrait = function (name) {
            for (const trait of this.equipTraits) {
                if (trait.name == name) {
                    return trait;
                }
            }
        };

        addEquipTrait = function (name, value) {
            let trait = new Trait$1(name, value, this);
            trait.value = function () {
                return this.base;
            };
            this.equipStats.push(trait);
        };

        killEffect = function () {

        };
    }

    /* src/Cards/Equipements/BottesEnCuir/Text.svelte generated by Svelte v3.59.2 */

    const file$13 = "src/Cards/Equipements/BottesEnCuir/Text.svelte";

    function create_fragment$1P(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 1 la vitesse de la cr√©ature √©quip√©e.");
    			add_location(br, file$13, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$H = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1P.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/BottesEnCuir/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1O(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$x,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$x(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$x, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$z = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1O.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BottesEnCuir extends Equipment {
        name = "Bottes en cuir";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);
            this.equipStat("Vitesse").base = 1;

            this.text = Text$H;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$z);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/BouclierEnCuir/Text.svelte generated by Svelte v3.59.2 */

    const file$12 = "src/Cards/Equipements/BouclierEnCuir/Text.svelte";

    function create_fragment$1N(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 5 la d√©fense de la cr√©ature √©quip√©e.");
    			add_location(br, file$12, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$G = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1N.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/BouclierEnCuir/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1M(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$w,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$w(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$w, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$y = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1M.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BouclierEnCuir extends Equipment {
        name = "Bouclier en cuir";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);
            this.equipStat("D√©fense").base = 5;

            this.text = Text$G;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$y);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/BouclierDeFer/Text.svelte generated by Svelte v3.59.2 */

    const file$11 = "src/Cards/Equipements/BouclierDeFer/Text.svelte";

    function create_fragment$1L(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 25 la d√©fense de la cr√©ature √©quip√©e.");
    			add_location(br, file$11, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$F = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1L.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/BouclierDeFer/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1K(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$v,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$v(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$v, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$x = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1K.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BouclierDeFer extends Equipment {
        name = "Bouclier de fer";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.equipStat("D√©fense").base = 25;

            this.text = Text$F;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$x);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/BouclierDePlatine/Text.svelte generated by Svelte v3.59.2 */

    const file$10 = "src/Cards/Equipements/BouclierDePlatine/Text.svelte";

    function create_fragment$1J(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 100 la d√©fense de la cr√©ature √©quip√©e.");
    			add_location(br, file$10, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$E = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1J.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/BouclierDePlatine/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1I(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$u,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$u(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$u, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$w = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1I.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BouclierDePlatine extends Equipment {
        name = "Bouclier de platine";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.equipStat("D√©fense").base = 100;

            this.text = Text$E;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$w);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/Egide/Text.svelte generated by Svelte v3.59.2 */

    const file$$ = "src/Cards/Equipements/Egide/Text.svelte";

    function create_fragment$1H(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 1 la protection de la cr√©ature √©quip√©e.");
    			add_location(br, file$$, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$D = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1H.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/Egide/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1G(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$t,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$t(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$t, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$v = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1G.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Egide extends Equipment {
        name = "√âgide";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);
            this.equipStat("Protection").base = 1;

            this.text = Text$D;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$v);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/EpeeDeCuivre/Text.svelte generated by Svelte v3.59.2 */

    const file$_ = "src/Cards/Equipements/EpeeDeCuivre/Text.svelte";

    function create_fragment$1F(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 10 l'attaque de la cr√©ature √©quip√©e.");
    			add_location(br, file$_, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$C = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1F.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/EpeeDeCuivre/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1E(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$s,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$s(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$s, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$u = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1E.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class EpeeDeCuivre extends Equipment {
        name = "√âp√©e de cuivre";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);
            this.equipStat("Attaque").base = 10;

            this.text = Text$C;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$u);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/EpeeDeFer/Text.svelte generated by Svelte v3.59.2 */

    const file$Z = "src/Cards/Equipements/EpeeDeFer/Text.svelte";

    function create_fragment$1D(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 50 l'attaque de la cr√©ature √©quip√©e.");
    			add_location(br, file$Z, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$B = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1D.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/EpeeDeFer/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1C(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$r,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$r(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$r, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$t = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1C.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class EpeeDeFer extends Equipment {
        name = "√âp√©e de fer";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.equipStat("Attaque").base = 50;

            this.text = Text$B;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$t);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/EpeeDePlatine/Text.svelte generated by Svelte v3.59.2 */

    const file$Y = "src/Cards/Equipements/EpeeDePlatine/Text.svelte";

    function create_fragment$1B(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 200 l'attaque de la cr√©ature √©quip√©e.");
    			add_location(br, file$Y, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$A = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1B.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/EpeeDePlatine/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1A(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$q,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$q(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$q, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$s = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1A.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class EpeeDePlatine extends Equipment {
        name = "√âp√©e de platine";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.equipStat("Attaque").base = 200;

            this.text = Text$A;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$s);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/PlastronEnCuir/Text.svelte generated by Svelte v3.59.2 */

    const file$X = "src/Cards/Equipements/PlastronEnCuir/Text.svelte";

    function create_fragment$1z(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 8 la vie de la cr√©ature √©quip√©e.");
    			add_location(br, file$X, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$z = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1z.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/PlastronEnCuir/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1y(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$p,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$p(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$p, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$r = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1y.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PlastronEnCuir extends Equipment {
        name = "Plastron en cuir";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);
            this.equipStat("Vie").base = 8;

            this.text = Text$z;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$r);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            target.stat("Vie").current += this.equipStat("Vie").base;
            this.pose();
        };
    }

    /* src/Cards/Equipements/PlastronEnFer/Text.svelte generated by Svelte v3.59.2 */

    const file$W = "src/Cards/Equipements/PlastronEnFer/Text.svelte";

    function create_fragment$1x(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 45 la vie de la cr√©ature √©quip√©e.");
    			add_location(br, file$W, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$y = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1x.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/PlastronEnFer/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1w(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$o,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$o(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$o, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$q = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1w.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PlastronEnFer extends Equipment {
        name = "Plastron en fer";

        constructor(System) {
            super(System);

            this.init([["Or", 30]]);
            this.equipStat("Vie").base = 45;

            this.text = Text$y;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$q);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            target.stat("Vie").current += this.equipStat("Vie").base;
            this.pose();
        };
    }

    /* src/Cards/Equipements/PlastronEnPlatine/Text.svelte generated by Svelte v3.59.2 */

    const file$V = "src/Cards/Equipements/PlastronEnPlatine/Text.svelte";

    function create_fragment$1v(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 150 la vie de la cr√©ature √©quip√©e.");
    			add_location(br, file$V, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$x = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1v.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/PlastronEnPlatine/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1u(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$n,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$n(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$n, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$p = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1u.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PlastronEnPlatine extends Equipment {
        name = "Plastron en platine";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.equipStat("Vie").base = 150;

            this.text = Text$x;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$p);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            target.stat("Vie").current += this.equipStat("Vie").base;
            this.pose();
        };
    }

    /* src/Cards/Equipements/SacEnToile/Text.svelte generated by Svelte v3.59.2 */

    const file$U = "src/Cards/Equipements/SacEnToile/Text.svelte";

    function create_fragment$1t(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAu d√©but de la phase de pr√©paration, quand √©quip√© : pioche 1 carte.");
    			add_location(br, file$U, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$w = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1t.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/SacEnToile/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1s(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$m,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$m(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$m, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$o = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1s.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class SacEnToile extends Equipment {
        name = "Sac en toile";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);

            this.text = Text$w;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$o);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        startStepEffect = function () {
            if (this.bearer != undefined && this.bearer.zone.name == "Terrain") {
                this.owner.draw(1);
            }
        };
    }

    /* src/Cards/Equipements/FauxDePaysan/Text.svelte generated by Svelte v3.59.2 */

    const file$T = "src/Cards/Equipements/FauxDePaysan/Text.svelte";

    function create_fragment$1r(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nSi la cr√©ature √©quip√©e d√©truis une unit√© au combat : stocke 5 or.");
    			add_location(br, file$T, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$v = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1r.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/FauxDePaysan/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1q(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$l,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$l(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$l, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$n = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1q.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class FauxDePaysan extends Equipment {
        name = "Faux de paysan";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);

            this.text = Text$v;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$n);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        killEffect = function () {
            this.owner.ressource("Or").stock += 3;
        };
    }

    /* src/Cards/Equipements/GanteletsEnCuir/Text.svelte generated by Svelte v3.59.2 */

    const file$S = "src/Cards/Equipements/GanteletsEnCuir/Text.svelte";

    function create_fragment$1p(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 1 les actions de la cr√©ature √©quip√©e.");
    			add_location(br, file$S, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$u = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1p.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/GanteletsEnCuir/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1o(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$k,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$k(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$k, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$m = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1o.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class GanteletsEnCuir extends Equipment {
        name = "Gantelets en cuir";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.equipStat("Actions").base = 1;

            this.text = Text$u;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$m);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/SacocheEnCuir/Text.svelte generated by Svelte v3.59.2 */

    const file$R = "src/Cards/Equipements/SacocheEnCuir/Text.svelte";

    function create_fragment$1n(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAu d√©but de la phase de pr√©paration, quand √©quip√© : d√©couvre 2 cartes.");
    			add_location(br, file$R, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$t = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1n.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/SacocheEnCuir/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1m(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$j,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$j(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$j, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$l = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1m.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class SacocheEnCuir extends Equipment {
        name = "Sacoche en cuir";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);

            this.text = Text$t;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$l);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        startStepEffect = function () {
            if (this.bearer != undefined && this.bearer.zone.name == "Terrain") {
                this.owner.discover(2);
            }
        };
    }

    /* src/Cards/Equipements/BaguetteEnBois/Text.svelte generated by Svelte v3.59.2 */

    const file$Q = "src/Cards/Equipements/BaguetteEnBois/Text.svelte";

    function create_fragment$1l(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 5 la magie de la cr√©ature √©quip√©e.");
    			add_location(br, file$Q, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$s = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1l.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/BaguetteEnBois/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1k(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$i,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$i(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$i, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$k = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1k.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BaguetteEnBois extends Equipment {
        name = "Baguette en bois";

        constructor(System) {
            super(System);

            this.init([["Or", 10]]);
            this.equipStat("Magie").base = 5;

            this.text = Text$s;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$k);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/BaguetteDeMage/Text.svelte generated by Svelte v3.59.2 */

    const file$P = "src/Cards/Equipements/BaguetteDeMage/Text.svelte";

    function create_fragment$1j(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 25 la magie de la cr√©ature √©quip√©e.");
    			add_location(br, file$P, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$r = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1j.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/BaguetteDeMage/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1i(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$h,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$h(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$h, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$j = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1i.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BaguetteDeMage extends Equipment {
        name = "Baguette de mage";

        constructor(System) {
            super(System);

            this.init([["Or", 25]]);
            this.equipStat("Magie").base = 25;

            this.text = Text$r;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$j);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/BaguetteDArchimage/Text.svelte generated by Svelte v3.59.2 */

    const file$O = "src/Cards/Equipements/BaguetteDArchimage/Text.svelte";

    function create_fragment$1h(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 100 la magie de la cr√©ature √©quip√©e.");
    			add_location(br, file$O, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$q = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1h.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/BaguetteDArchimage/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1g(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$g,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$g(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$g, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$i = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1g.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BaguetteDArchimage extends Equipment {
        name = "Baguette d'archimage";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.equipStat("Magie").base = 100;

            this.text = Text$q;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$i);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/Grimoire/Text.svelte generated by Svelte v3.59.2 */

    const file$N = "src/Cards/Equipements/Grimoire/Text.svelte";

    function create_fragment$1f(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAu d√©but de la phase de pr√©paration, quand √©quip√© : pioche 1 carte de famille Sort.");
    			add_location(br, file$N, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$p = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1f.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/Grimoire/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1e(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$f,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$f(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$f, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$h = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1e.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Grimoire extends Equipment {
        name = "Grimoire";

        constructor(System) {
            super(System);

            this.init([["Or", 6]]);

            this.text = Text$p;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$h);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        startStepEffect = function () {
            if (this.bearer != undefined && this.bearer.zone.name == "Terrain") {
                let condition = function (card) {
                    if (card.familles.base.includes("Sort")) {
                        return true;
                    }
                    return false;
                };
                this.owner.draw(1, condition);
            }
        };
    }

    /* src/Cards/Equipements/DagueDeCuivre/Text.svelte generated by Svelte v3.59.2 */

    const file$M = "src/Cards/Equipements/DagueDeCuivre/Text.svelte";

    function create_fragment$1d(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain OU inflige 5 d√©g√¢ts √† une unit√© adverse sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 5 l'attaque de la cr√©ature √©quip√©e.");
    			add_location(br, file$M, 6, 0, 168);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$o = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1d.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/DagueDeCuivre/Use.svelte generated by Svelte v3.59.2 */
    const file$L = "src/Cards/Equipements/DagueDeCuivre/Use.svelte";

    // (56:29) 
    function create_if_block_2$8(ctx) {
    	let button;
    	let t1;
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition2,
    				fonction: /*fonction*/ ctx[2]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Retour";
    			t1 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$L, 56, 4, 1341);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[6], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(56:29) ",
    		ctx
    	});

    	return block;
    }

    // (41:28) 
    function create_if_block_1$e(ctx) {
    	let button;
    	let t1;
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$e,
    				fonction: /*fonction*/ ctx[2]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Retour";
    			t1 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$L, 41, 4, 978);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(41:28) ",
    		ctx
    	});

    	return block;
    }

    // (25:0) {#if choice == undefined}
    function create_if_block$k(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "S'√©quipe √† une cr√©ature alli√©e sur le terrain";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Inflige 5 d√©g√¢ts √† une unit√© adverse sur le terrain";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$L, 26, 8, 554);
    			add_location(br, file$L, 32, 8, 737);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$L, 33, 8, 752);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$L, 25, 4, 499);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(25:0) {#if choice == undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1c(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_if_block_1$e, create_if_block_2$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*choice*/ ctx[1] == undefined) return 0;
    		if (/*choice*/ ctx[1] == "equip") return 1;
    		if (/*choice*/ ctx[1] == "damage") return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$e(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function condition2(card) {
    	return true;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;
    	let choice = undefined;

    	function fonction(card) {
    		System.game.use.card.useEffect(card, choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(1, choice = "equip");
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, choice = "damage");
    	};

    	const click_handler_2 = () => {
    		$$invalidate(1, choice = undefined);
    	};

    	const click_handler_3 = () => {
    		$$invalidate(1, choice = undefined);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Zone: Zone$1,
    		System,
    		choice,
    		condition: condition$e,
    		condition2,
    		fonction
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('choice' in $$props) $$invalidate(1, choice = $$props.choice);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		choice,
    		fonction,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    let Use$g = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1c.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DagueDeCuivre extends Equipment {
        name = "Dague de cuivre";

        constructor(System) {
            super(System);

            this.init([["Or", 3]]);
            this.equipStat("Attaque").base = 5;

            this.text = Text$o;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$g);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target, "equip");
                    return 0;
                }

                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0], "damage");
                }
            }
        };

        useEffect = function (target, choice) {
            if (choice == "equip") {
                target.equip(this);
            }
            else if (choice == "damage") {
                target.damage(5);
                this.move("D√©fausse");
            }
            this.pose();
        };
    }

    /* src/Cards/Equipements/DoublesLamesDeCuivre/Text.svelte generated by Svelte v3.59.2 */

    const file$K = "src/Cards/Equipements/DoublesLamesDeCuivre/Text.svelte";

    function create_fragment$1b(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 1 le multicoup de la cr√©ature √©quip√©e.");
    			add_location(br, file$K, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$n = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$1b.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/DoublesLamesDeCuivre/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$1a(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$d,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$d(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$d, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$f = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$1a.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class DoublesLamesDeCuivre extends Equipment {
        name = "Doubles lames de cuivre";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.equipStat("Multicoup").base = 1;

            this.text = Text$n;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$f);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/CasqueEnCuir/Text.svelte generated by Svelte v3.59.2 */

    const file$J = "src/Cards/Equipements/CasqueEnCuir/Text.svelte";

    function create_fragment$19(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAu d√©but de la phase de pr√©paration, quand √©quip√© : fixe l'endurance de la cr√©ature √©quip√©e √† 5.");
    			add_location(br, file$J, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$m = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$19.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/CasqueEnCuir/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$18(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$c,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$c(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$c, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$e = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$18.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CasqueEnCuir extends Equipment {
        name = "Casque en cuir";

        constructor(System) {
            super(System);

            this.init([["Or", 5]]);

            this.text = Text$m;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$e);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        startStepEffect = function () {
            if (this.bearer != undefined && this.bearer.zone.name == "Terrain") {
                this.bearer.stat("Endurance").fix(5);
            }
        };
    }

    /* src/Cards/Equipements/Couronne/Text.svelte generated by Svelte v3.59.2 */

    const file$I = "src/Cards/Equipements/Couronne/Text.svelte";

    function create_fragment$17(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nQuand une cr√©ature alli√©e est pos√©e : augmente l'attaque et la vie de cette cr√©ature du m√™me montant que le niveau de la cr√©ature √©quip√©e.");
    			add_location(br, file$I, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$l = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$17.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/Couronne/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$16(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$b,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$b(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$b, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$d = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$16.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Couronne extends Equipment {
        name = "Couronne";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);

            this.text = Text$l;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$d);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        otherPoseEffect = function (card) {
            if (this.bearer != undefined && this.bearer.zone.name == "Terrain" && card.type == "Cr√©ature") {
                card.stat("Attaque").add += this.bearer.level;
                card.stat("Vie").add += this.bearer.level;
                card.stat("Vie").current += this.bearer.level;
            }
        };
    }

    /* src/Cards/Equipements/HacheDeCuivre/Text.svelte generated by Svelte v3.59.2 */

    const file$H = "src/Cards/Equipements/HacheDeCuivre/Text.svelte";

    function create_fragment$15(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 10 l'adresse de la cr√©ature √©quip√©e.");
    			add_location(br, file$H, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$k = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$15.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/HacheDeCuivre/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$14(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$a,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$a(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$a, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$c = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$14.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class HacheDeCuivre extends Equipment {
        name = "Hache de cuivre";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);
            this.equipStat("Adresse").base = 10;

            this.text = Text$k;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$c);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/HacheDeFer/Text.svelte generated by Svelte v3.59.2 */

    const file$G = "src/Cards/Equipements/HacheDeFer/Text.svelte";

    function create_fragment$13(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 25 l'adresse de la cr√©ature √©quip√©e.");
    			add_location(br, file$G, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$j = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$13.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/HacheDeFer/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$12(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$9,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$9(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$9, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$b = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class HacheDeFer extends Equipment {
        name = "Hache de fer";

        constructor(System) {
            super(System);

            this.init([["Or", 50]]);
            this.equipStat("Adresse").base = 25;

            this.text = Text$j;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$b);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/HacheDePlatine/Text.svelte generated by Svelte v3.59.2 */

    const file$F = "src/Cards/Equipements/HacheDePlatine/Text.svelte";

    function create_fragment$11(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 50 l'adresse de la cr√©ature √©quip√©e.");
    			add_location(br, file$F, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$i = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/HacheDePlatine/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$10(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$8,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$8(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$8, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$a = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class HacheDePlatine extends Equipment {
        name = "Hache de platine";

        constructor(System) {
            super(System);

            this.init([["Or", 100]]);
            this.equipStat("Adresse").base = 50;

            this.text = Text$i;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$a);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    /* src/Cards/Equipements/Pelle/Text.svelte generated by Svelte v3.59.2 */

    const file$E = "src/Cards/Equipements/Pelle/Text.svelte";

    function create_fragment$$(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAu d√©but de la phase de pr√©paration, quand √©quip√© : d√©couvre 1 carte d'√©l√©ment Terre et produis autant de terre que le niveau de cette carte.");
    			add_location(br, file$E, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$h = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$$.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/Pelle/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$_(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$7,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$7(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$7, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$9 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Pelle extends Equipment {
        name = "Pelle";

        constructor(System) {
            super(System);

            this.init([["Or", 18], ["Terre", 18]]);

            this.text = Text$h;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$9);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        startStepEffect = function () {
            if (this.bearer != undefined && this.bearer.zone.name == "Terrain") {
                let condition = function (card) {
                    if (card.elements.includes("Terre")) {
                        return true;
                    }
                    return false;
                };
                let cards = this.owner.discover(1, condition);
                this.owner.ressource("Terre").current += cards[0].level;
            }
        };
    }

    /* src/Cards/Equipements/CapeDAgilite/Text.svelte generated by Svelte v3.59.2 */

    const file$D = "src/Cards/Equipements/CapeDAgilite/Text.svelte";

    function create_fragment$Z(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAu d√©but d'un tour de combat, quand √©quip√© : augmente de 1 l'esquive de la cr√©ature √©quip√©e pendant ce tour de combat.");
    			add_location(br, file$D, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$g = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/CapeDAgilite/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$Y(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$6,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$6(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$6, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$8 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CapeDAgilite extends Equipment {
        name = "Cape d'agilit√©";

        constructor(System) {
            super(System);

            this.init([["Or", 20]]);

            this.text = Text$g;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$8);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };

        turnEffect = function () {
            if (this.bearer != undefined && this.bearer.zone.name == "Terrain") {
                this.bearer.stat("Esquive").turn += 1;
            }
        };
    }

    /* src/Cards/Equipements/CarapaceDeTortue/Text.svelte generated by Svelte v3.59.2 */

    const file$C = "src/Cards/Equipements/CarapaceDeTortue/Text.svelte";

    function create_fragment$X(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("S'√©quipe sur une cr√©ature alli√©e sur le terrain.\n");
    			br = element("br");
    			t1 = text("\nAugmente de 15 la d√©fense de la cr√©ature √©quip√©e.");
    			add_location(br, file$C, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$f = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Equipements/CarapaceDeTortue/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$W(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$5,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$5(card) {
    	if (card.type == "Cr√©ature" && card.canEquip()) {
    		return true;
    	}

    	return false;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$5, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$7 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CarapaceDeTortue extends Equipment {
        name = "Carapace de tortue";

        constructor(System) {
            super(System);

            this.init([["Or", 8], ["Eau", 8]]);
            this.familles.base.push("Reptile");
            this.equipStat("D√©fense").base = 15;

            this.text = Text$f;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$7);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature" && card.canEquip()) {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            target.equip(this);
            this.pose();
        };
    }

    class Lieu extends Card {
        type = "Lieu";

        useEffect = function () {
            this.move("Lieux");
            this.pose();
        };

        condition = function (card) {
            return true;
        };
    }

    /* src/Cards/Lieux/Plaine/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$V(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Toutes les cartes sont piochables.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$e = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$V.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Plaine extends Lieu {
        name = "Plaine";

        constructor(System) {
            super(System);

            this.init([["Or", 30]]);

            this.text = Text$e;
        };
    }

    /* src/Cards/Lieux/Ville/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$U(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Les cartes piochables sont Neutre.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$d = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Ville extends Lieu {
        name = "Ville";

        constructor(System) {
            super(System);

            this.init([["Or", 30]]);

            this.text = Text$d;
        };

        condition = function (card) {
            if (card.elements.includes("Neutre")) {
                return true;
            }
            return false;
        };
    }

    /* src/Cards/Lieux/Village/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$T(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Les cartes piochables sont de niveau 5 ou moins.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$c = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$T.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Village extends Lieu {
        name = "Village";

        constructor(System) {
            super(System);

            this.init([["Or", 30]]);

            this.text = Text$c;
        };

        condition = function (card) {
            if (card.level <= 5) {
                return true;
            }
            return false;
        };
    }

    /* src/Cards/Lieux/Foret/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$S(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Les cartes piochables sont d'√©lement V√©g√©tal.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$b = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Foret extends Lieu {
        name = "For√™t";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["V√©g√©tal", 15]]);

            this.text = Text$b;
        };

        condition = function (card) {
            if (card.elements.includes("V√©g√©tal")) {
                return true;
            }
            return false;
        };
    }

    /* src/Cards/Lieux/Volcan/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$R(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Les cartes piochables sont d'√©lement Feu.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$a = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Volcan extends Lieu {
        name = "Volcan";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["Feu", 15]]);

            this.text = Text$a;
        };

        condition = function (card) {
            if (card.elements.includes("Feu")) {
                return true;
            }
            return false;
        };
    }

    /* src/Cards/Lieux/Mer/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$Q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Les cartes piochables sont d'√©lement Eau.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$9 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Mer extends Lieu {
        name = "Mer";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["Eau", 15]]);

            this.text = Text$9;
        };

        condition = function (card) {
            if (card.elements.includes("Eau")) {
                return true;
            }
            return false;
        };
    }

    /* src/Cards/Lieux/Montagne/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$P(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Les cartes piochables sont d'√©lement Terre.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$8 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Montagne extends Lieu {
        name = "Montagne";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["Terre", 15]]);

            this.text = Text$8;
        };

        condition = function (card) {
            if (card.elements.includes("Terre")) {
                return true;
            }
            return false;
        };
    }

    class Sort extends Action {
        constructor(System) {
            super(System);

            this.familles.base.push("Sort");
        }

        manaCost = function (value) {
            value -= this.owner.totalIntelligence();
            if (value < 0) {
                value = 0;
            }
            
            return value;
        };
    }

    /* src/Cards/Sorts/BouleDeFeu/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$O(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 30 d√©g√¢ts √† une unit√© adverse sur le terrain. D√©pense 15 mana pour infliger 60 d√©g√¢ts √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$7 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$O.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Sorts/BouleDeFeu/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$N(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner.adversary(),
    				zone: /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain"),
    				condition: condition$4,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner.adversary();
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.adversary().zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$4(card) {
    	return true;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$4, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$6 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BouleDeFeu extends Sort {
        name = "Boule de feu";

        constructor(System) {
            super(System);

            this.init([["Or", 10], ["Feu", 10]]);

            this.text = Text$7;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$6);
                this.System.pages.change("Game");
            }
            else {
                if (this.owner.adversary().zone("Terrain").cards.length > 0) {
                    this.useEffect(this.owner.adversary().zone("Terrain").cards[0]);
                }
            }
        };

        useEffect = function (target) {
            if (this.owner.ressource("Mana").total() >= this.manaCost(15)) {
                this.owner.ressource("Mana").spend(this.manaCost(15));
                target.damage(60);
            }
            else {
                target.damage(30);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Sorts/PluieDeFeu/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$M(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Inflige 5 d√©g√¢ts √† toutes les unit√©s adverses sur le terrain. D√©pense 25 mana pour infliger 10 d√©g√¢ts √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$6 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PluieDeFeu extends Sort {
        name = "Pluie de feu";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["Feu", 15]]);
            this.familles.base.push("Sort");

            this.text = Text$6;
        };

        use = function () {
            if (this.owner == this.System.game.player || this.owner.adversary().zone("Terrain").cards.length > 0) {
                this.useEffect();
            }
        };

        useEffect = function () {
            let damage;
            if (this.owner.ressource("Mana").total() >= this.manaCost(25)) {
                this.owner.ressource("Mana").spend(this.manaCost(25));
                damage = 10;
            }
            else {
                damage = 5;
            }

            let terrain = this.System.copy(this.owner.adversary().zone("Terrain").cards);
            for (const card of terrain) {
                card.damage(damage);
            }

            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Sorts/PeauDePierre/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$L(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 15 la d√©fense d'une cr√©ature alli√©e sur le terrain. D√©pense 15 mana pour augmenter la d√©fense de 30 √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$5 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Sorts/PeauDePierre/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$K(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$3,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$3(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$3, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$5 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PeauDePierre extends Sort {
        name = "Peau de pierre";

        constructor(System) {
            super(System);

            this.init([["Or", 10], ["Terre", 10]]);

            this.text = Text$5;
        };
        
        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$5);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (this.owner.ressource("Mana").total() >= this.manaCost(15)) {
                this.owner.ressource("Mana").spend(this.manaCost(15));
                target.stat("D√©fense").add += 30;
            }
            else {
                target.stat("D√©fense").add += 15;
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Sorts/CreationRocheuse/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$J(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cr√©e un √âl√©mentaire de roche sur le terrain OU cr√©√© un Mur de roche sur le terrain. D√©pense 50 mana pour cr√©er les deux sur le terrain √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$4 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Sorts/CreationRocheuse/Use.svelte generated by Svelte v3.59.2 */

    const file$B = "src/Cards/Sorts/CreationRocheuse/Use.svelte";

    function create_fragment$I(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "√âl√©mentaire de roche";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Mur de roche";
    			attr_dev(button0, "class", "big");
    			add_location(button0, file$B, 11, 4, 226);
    			add_location(br, file$B, 17, 4, 364);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$B, 18, 4, 375);
    			attr_dev(div, "class", "center");
    			set_style(div, "text-align", "center");
    			add_location(div, file$B, 10, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(choice) {
    		System.game.use.card.useEffect(choice);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		fonction("Cr√©ature");
    	};

    	const click_handler_1 = () => {
    		fonction("B√¢timent");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fonction, System, click_handler, click_handler_1];
    }

    let Use$4 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class CreationRocheuse extends Sort {
        name = "Cr√©ation rocheuse";

        constructor(System) {
            super(System);

            this.init([["Or", 35], ["Terre", 35]]);

            this.text = Text$4;
        };

        use = function () {
            if (this.owner.ressource("Mana").total() >= 50) {
                this.useEffect();
            }
            else {
                if (this.owner == this.System.game.player) {
                    this.System.game.use.set(this, Use$4);
                    this.System.pages.change("Game");
                }
                else {
                    this.useEffect("Cr√©ature");
                }
            }
        };

        useEffect = function (choice) {
            if (this.owner.ressource("Mana").total() >= this.manaCost(50)) {
                this.owner.ressource("Mana").spend(this.manaCost(50));
                this.owner.getCard("√âl√©mentaire de roche").add("Terrain");
                this.owner.getCard("Mur de roche").add("Terrain");
            }
            else {
                if (choice == "Cr√©ature") {
                    this.owner.getCard("√âl√©mentaire de roche").add("Terrain");
                }
                else if (choice == "B√¢timent") {
                    this.owner.getCard("Mur de roche").add("Terrain");
                }
            }

            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Sorts/PeauDEcorce/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$H(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente de 15 la vie d'une cr√©ature alli√©e sur le terrain. D√©pense 15 mana pour augmenter la vie de 30 √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$3 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Sorts/PeauDEcorce/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$G(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$2,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$2(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$2, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$3 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class PeauDEcorce extends Sort {
        name = "Peau d'√©corce";

        constructor(System) {
            super(System);

            this.init([["Or", 10], ["V√©g√©tal", 10]]);

            this.text = Text$3;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$3);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (this.owner.ressource("Mana").total() >= this.manaCost(15)) {
                this.owner.ressource("Mana").spend(this.manaCost(15));
                target.stat("Vie").add += 45;
            }
            else {
                target.stat("Vie").add += 20;
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Sorts/Ecoulement/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$F(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente la capacit√© de production d'eau de 3. D√©pense 15 eau et 15 mana pour augmenter la capacit√© de production de 10 √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$2 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class Ecoulement extends Sort {
        name = "√âcoulement";

        constructor(System) {
            super(System);

            this.init([["Or", 10], ["Eau", 10]]);

            this.text = Text$2;
        };

        useEffect = function () {
            if (this.owner.ressource("Mana").total() >= 15 && this.owner.ressource("Eau").total() >= this.manaCost(15)) {
                this.owner.ressource("Mana").spend(this.manaCost(15));
                this.owner.ressource("Eau").spend(15);
                this.owner.ressource("Eau").max += 10;
            }
            else {
                this.owner.ressource("Eau").max += 3;
            }

            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Sorts/BulleProtectrice/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$E(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Fixe l'endurance d'une cr√©ature alli√©e sur le terrain √† 25. D√©pense 25 mana pour fixer l'endurance √† 50 √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    let Text$1 = class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Cards/Sorts/BulleProtectrice/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$D(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition: condition$1,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition$1(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition: condition$1, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$2 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class BulleProtectrice extends Sort {
        name = "Bulle protectrice";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["Eau", 15]]);

            this.text = Text$1;
        };
        
        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$2);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (this.owner.ressource("Mana").total() >= this.manaCost(25)) {
                this.owner.ressource("Mana").spend(this.manaCost(25));
                target.stat("Endurance").fix(50);
            }
            else {
                target.stat("Endurance").fix(25);
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    /* src/Cards/Sorts/EnseignementElfique/Text.svelte generated by Svelte v3.59.2 */

    function create_fragment$C(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Augmente l'intelligence d'une cr√©ature alli√©e de 5. D√©pense 25 mana pour augmenter l'intelligence de 10 √† la place.");
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Text', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Text> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Text> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Text> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card];
    }

    class Text extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Text",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get System() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Cards/Sorts/EnseignementElfique/Use.svelte generated by Svelte v3.59.2 */

    function create_fragment$B(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.use.card.owner,
    				zone: /*System*/ ctx[0].game.use.card.owner.zone("Terrain"),
    				condition,
    				fonction: /*fonction*/ ctx[1]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance_changes.entity = /*System*/ ctx[0].game.use.card.owner;
    			if (dirty & /*System*/ 1) switch_instance_changes.zone = /*System*/ ctx[0].game.use.card.owner.zone("Terrain");

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function condition(card) {
    	if (card.type == "Cr√©ature") {
    		return true;
    	}

    	return false;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function fonction(card) {
    		System.game.use.card.useEffect(card);
    		System.game.use.reset();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, condition, fonction });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, fonction];
    }

    let Use$1 = class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    class EnseignementElfique extends Sort {
        name = "Enseignement elfique";

        constructor(System) {
            super(System);

            this.init([["Or", 15], ["V√©g√©tal", 15]]);
            this.familles.base.push("Elfe");

            this.text = Text;
        };

        use = function () {
            this.select();
        };

        select = function () {
            if (this.owner == this.System.game.player) {
                this.System.game.use.set(this, Use$1);
                this.System.pages.change("Game");
            }
            else {
                let target = undefined;

                for (const card of this.owner.zone("Terrain").cards) {
                    if (target == undefined && card.type == "Cr√©ature") {
                        target = card;
                    }
                }

                if (target != undefined) {
                    this.useEffect(target);
                }
            }
        };

        useEffect = function (target) {
            if (this.owner.ressource("Mana").total() >= this.manaCost(25)) {
                this.owner.ressource("Mana").spend(this.manaCost(25));
                target.stat("Intelligence").add += 10;
            }
            else {
                target.stat("Intelligence").add += 5;
            }
            this.move("D√©fausse");
            this.pose();
        };
    }

    var cards = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Ambidextrie: Ambidextrie,
        Archimage: Archimage,
        Architecte: Architecte,
        Atlas: Atlas,
        Bagarreur: Bagarreur,
        BaguetteDArchimage: BaguetteDArchimage,
        BaguetteDeMage: BaguetteDeMage,
        BaguetteEnBois: BaguetteEnBois,
        Bandit: Bandit,
        Banniere: Banniere,
        Barbare: Barbare,
        Bestiaire: Bestiaire,
        BibliothequeElfique: BibliothequeElfique,
        'Biblioth√®que': Biblioth√®que,
        Bivouac: Bivouac,
        Bombe: Bombe,
        BottesEnCuir: BottesEnCuir,
        BouclierDeFer: BouclierDeFer,
        BouclierDePlatine: BouclierDePlatine,
        BouclierEnCuir: BouclierEnCuir,
        BouleDeFeu: BouleDeFeu,
        BulleProtectrice: BulleProtectrice,
        CanonAEau: CanonAEau,
        CapeDAgilite: CapeDAgilite,
        CarapaceDeTortue: CarapaceDeTortue,
        Caserne: Caserne,
        CasqueEnCuir: CasqueEnCuir,
        Cavalier: Cavalier,
        Champion: Champion,
        Charrette: Charrette,
        Cheval: Cheval,
        Chevalier: Chevalier,
        ChevalierGeant: ChevalierGeant,
        ChevalierMonte: ChevalierMonte,
        Chien: Chien,
        CoffreEnBois: CoffreEnBois,
        CoffreEnOr: CoffreEnOr,
        Conque: Conque,
        CorDeGuerre: CorDeGuerre,
        Couronne: Couronne,
        CreationRocheuse: CreationRocheuse,
        Cuisinier: Cuisinier,
        DagueDeCuivre: DagueDeCuivre,
        DoublesLamesDeCuivre: DoublesLamesDeCuivre,
        Dresseur: Dresseur,
        DruideDeFeuGobelin: DruideDeFeuGobelin,
        DruideDeFeuLezard: DruideDeFeuLezard,
        DruideDesBoisElfe: DruideDesBoisElfe,
        DruideDesBoisRenard: DruideDesBoisRenard,
        DruideDesMontagnesNain: DruideDesMontagnesNain,
        DruideDesMontagnesOurs: DruideDesMontagnesOurs,
        DruideDesPlainesHumain: DruideDesPlainesHumain,
        DruideDesPlainesLoup: DruideDesPlainesLoup,
        DruideDesRecifsOndin: DruideDesRecifsOndin,
        DruideDesRecifsTortue: DruideDesRecifsTortue,
        DruideMarchandBoeuf: DruideMarchandBoeuf,
        DruideMarchandHumain: DruideMarchandHumain,
        Ecoulement: Ecoulement,
        Egide: Egide,
        ElementaireDEau: ElementaireDEau,
        ElementaireDeFeu: ElementaireDeFeu,
        ElementaireDeRoche: ElementaireDeRoche,
        ElementaireDeTerre: ElementaireDeTerre,
        ElementaireDesHerbes: ElementaireDesHerbes,
        ElementaireDesRacines: ElementaireDesRacines,
        ElementaireExplosif: ElementaireExplosif,
        ElementaireMarin: ElementaireMarin,
        Elementaliste: Elementaliste,
        Elfe: Elfe,
        Elimination: Elimination,
        EnseignementElfique: EnseignementElfique,
        Entrainement: Entrainement,
        EpeeDeCuivre: EpeeDeCuivre,
        EpeeDeFer: EpeeDeFer,
        EpeeDePlatine: EpeeDePlatine,
        Eruption: Eruption,
        FauxDePaysan: FauxDePaysan,
        Fermier: Fermier,
        FeuDeCamp: FeuDeCamp,
        FlecheEnBois: FlecheEnBois,
        Foret: Foret,
        Forger: Forger,
        Forgeron: Forgeron,
        GanteletsEnCuir: GanteletsEnCuir,
        Garde: Garde,
        Geant: Geant,
        GoHoumei: GoHoumei,
        Gobelin: Gobelin,
        Grimoire: Grimoire,
        Guerrier: Guerrier,
        GuerrierGeant: GuerrierGeant,
        GuerrierGobelin: GuerrierGobelin,
        Gyoun: Gyoun,
        HacheDeCuivre: HacheDeCuivre,
        HacheDeFer: HacheDeFer,
        HacheDePlatine: HacheDePlatine,
        Heros: Heros,
        Humain: Humain,
        Kanki: Kanki,
        Lion: Lion,
        Livre: Livre,
        LoupGris: LoupGris,
        Mage: Mage,
        MaitreChien: MaitreChien,
        Marchand: Marchand,
        Mendiant: Mendiant,
        Mer: Mer,
        Metamorphose: Metamorphose,
        Mimique: Mimique,
        Montagne: Montagne,
        MurDeBrique: MurDeBrique,
        MurDePierre: MurDePierre,
        MurDeRoche: MurDeRoche,
        Nain: Nain,
        Noyade: Noyade,
        Ondin: Ondin,
        OndinDesRivieres: OndinDesRivieres,
        OursDesMontagnes: OursDesMontagnes,
        OursForestier: OursForestier,
        Pain: Pain,
        PeauDEcorce: PeauDEcorce,
        PeauDePierre: PeauDePierre,
        Pelle: Pelle,
        PierrePhilosophale: PierrePhilosophale,
        Plaine: Plaine,
        PlastronEnCuir: PlastronEnCuir,
        PlastronEnFer: PlastronEnFer,
        PlastronEnPlatine: PlastronEnPlatine,
        PluieDeFeu: PluieDeFeu,
        PluieDeFleche: PluieDeFleche,
        Pomme: Pomme,
        PommeDeTerre: PommeDeTerre,
        Pont: Pont,
        PotionDeMana: PotionDeMana,
        PotionDeSoin: PotionDeSoin,
        PouletRoti: PouletRoti,
        Prince: Prince,
        Princesse: Princesse,
        'Pr√™tre': Pr√™tre,
        Raido: Raido,
        Rappel: Rappel,
        Reine: Reine,
        Renard: Renard,
        Renforcement: Renforcement,
        Restockage: Restockage,
        Roi: Roi,
        Roulade: Roulade,
        SacEnToile: SacEnToile,
        SacocheEnCuir: SacocheEnCuir,
        SardinesEnBoite: SardinesEnBoite,
        Sifflet: Sifflet,
        Soldat: Soldat,
        Sprint: Sprint,
        'Strat√®ge': Strat√®ge,
        TirHydraulique: TirHydraulique,
        Torche: Torche,
        Tortue: Tortue,
        TortueSolide: TortueSolide,
        TourDeMage: TourDeMage,
        Trefle: Trefle,
        Tresor: Tresor,
        Vache: Vache,
        Village: Village,
        Ville: Ville,
        Volcan: Volcan,
        Voleur: Voleur
    });

    class Chapter {
        steps = [];
        ressources = [];
        boss = false;
        dialog = 0;

        constructor(System, number) {
            this.System = System;
            this.number = number;
        };

        init = function () {
            this.System.game.player.step = 1;
            this.System.game.bot.step = 0;

            for (const ressource of this.ressources) {
                this.System.game.bot.ressource(ressource.name).max = ressource.value;
            }
        };

        addRessource = function (name, value) {
            this.ressources.push({
                name: name,
                value: value
            });
        };

        addStep = function (life, place, cards, dialogs = []) {
            this.steps.push({
                life: life,
                place: place,
                cards: cards,
                dialogs: dialogs
            });
        };

        nextDialog = function () {
            if (this.dialog < this.steps[this.System.game.player.step - 1].dialogs.length - 1) {
                this.dialog++;
                this.System.pages.change("Dialog");
            }
            else {
                this.System.pages.change("Game");
            }
        };

        getLevel = function () {
            let total = 0;
            for (const ressource of this.ressources) {
                total += ressource.value;
            }

            let level = 0;
            let max = 0;
            while (total > max && level < 20) {
                level++;
                max += level * 10;
            }
            return level;
        };
    }

    class Lv1_Humains extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 10);

            this.addStep(10, "Village", ["Humain"], ["Vous arrivez dans un petit village, mais les habitants vous font face."]);
            this.addStep(10, "Village", ["Humain", "Humain"]);
        }
    }

    class Lv1_Bandits extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 10);

            this.addStep(10, "Plaine", ["Bandit"], ["Des bandits bloquent le chemin, d√©sirants votre bourse."]);
            this.addStep(10, "Plaine", []);
            this.addStep(10, "Plaine", ["Bandit"]);
        }
    }

    class Lv1_Loup extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 10);

            this.addStep(10, "For√™t", ["Loup gris"], ["Quelques loups affam√©s vous approchent, les crocs mena√ßants."]);
            this.addStep(10, "For√™t", ["Loup gris"]);
        }
    }

    class Lv1_Chien extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 10);

            this.addStep(10, "Village", ["Chien", "Chien"], ["Au abords d'un village vous apercevez des chiens.", "Fouillant dans des d√©bris pour se nourrir, ils n'ont pas l'air d'√™tre domestiqu√©. Ou du moins ils ne le sont plus.", "Alors que vous alliez les contourner, ils vous foncent dessus."]);
            this.addStep(10, "Village", ["Chien", "Chien", "Chien"]);
        }
    }

    class Lv1_Mendiant extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 10);

            this.addStep(10, "Ville", ["Mendiant"], ["Deux hommes se battent devant un bar.", "En vous approchant, il s'agit d'un ivrogne et d'un soldat soul."]);
            this.addStep(10, "Ville", ["Soldat"]);
        }
    }

    class Lv2_Mur extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 30);

            this.addStep(20, "Plaine", ["Soldat", "Garde"], ["Un mur vous barre la route tandis que des gardes s'avancent vers vous."]);
            this.addStep(20, "Plaine", ["Mur de brique", "Soldat", "Soldat"]);
        }
    }

    class Lv2_Bandits extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 30);

            this.addStep(20, "For√™t", ["Fl√®che en bois", "Fl√®che en bois", "Fl√®che en bois"], ["Tandis que vous voyagez sur une route, on se met √† vous tirer dessus."]);
            this.addStep(20, "For√™t", ["Bandit", "Bouclier en cuir", "Bandit", "√âp√©e de cuivre"], ["Des bandits vous tendent une embuscade."]);
        }
    }

    class Lv2_Ferme extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 30);

            this.addStep(20, "Plaine", ["Vache", "Vache", "Chien"], ["Une colonne de vache vous bloque la route.", "Des fermiers semblent se disputer la propri√©t√© du b√©tail tout en vous emp√™chant de passer."]);
            this.addStep(20, "Plaine", ["Vache", "Vache", "Vache"]);
            this.addStep(20, "Plaine", ["Fermier", "Fermier"]);
        }
    }

    class Lv2_Raido extends Chapter {
        boss = true;

        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 30);

            this.addStep(20, "Plaine", ["Bandit", "Entra√Ænement", "Bandit", "Entra√Ænement"], ["Un clan de bandit s'est install√© dans une vall√©e.", "Il s'agirait du clan de Raido √† en croire des rescap√©s d'un village voisin.", "Lui et ses hommes sont connus pour rivaliser avec des soldats."]);
            this.addStep(20, "Plaine", ["Bandit", "Bandit"]);
            this.addStep(20, "Plaine", ["Raido, chef brutal", "Bandit", "Bandit"]);
        }
    }

    class Lv3_Geant extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 60);

            this.addStep(30, "Plaine", ["G√©ant"], ["Un g√©ant manque de vous marcher dessus.", "Il serait bon ton de lui apprendre √† faire attention."]);
        }
    }

    class Lv4_Chevalier extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 100);

            this.addStep(40, "Plaine", ["Chevalier mont√©", "Chevalier mont√©"], ["Une troupe de chevalier errant terrorise la r√©gion en usant de leur privil√®ge pour vivre aux d√©pends des habitants."]);
            this.addStep(40, "Plaine", ["Chevalier mont√©", "Chevalier mont√©"]);
        }
    }

    class Lv4_Kanki extends Chapter {
        boss = true;

        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 100);

            this.addStep(40, "Plaine", ["Kanki, roi des bandits"]);
        }
    }

    class Lv5_ChevalierGeant extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 150);

            this.addStep(50, "Plaine", ["Chevalier g√©ant"], ["Un chevalier sur de lui souhaite vous d√©fier pour prouver sa force.", "Le probl√®me √©tant que ce chevalier semble pouvoir enjamber des montagnes."]);
        }
    }

    class Lv6_Roi extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 210);

            this.addStep(60, "Ville", ["Soldat", "Soldat", "Soldat", "Soldat", "Soldat", "Roi"], ["Le tr√¥ne du royaume local est occup√© par un usurpateur.", "Les villages alentours vous somment de faire tomber ce faux-roi."]);
        }
    }

    class Lv6_Gyoun extends Chapter {
        boss = true;
        
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 100);
            this.addRessource("V√©g√©tal", 100);

            this.addStep(60, "For√™t", ["Gyoun, colosse de jade"], ["Le puissant Gyoun est parti en retraite dans la r√©gion.", "Celui qui a falli faire tomber des royaumes veux connaitre votre valeur, le colosse de jade sort de son repos une derni√®re fois."]);
        }
    }

    class Lv7_Eruption extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 140);
            this.addRessource("Feu", 140);

            this.addStep(70, "Volcan", ["√âruption", "Pluie de feu", "Pluie de feu", "Pluie de feu", "Pluie de feu"], ["Une violente √©ruption volcanique surprend votre groupe !", "Pas le temps de vous enfuir, il faudra encaisser les d√©g√¢ts."]);
        }
    }

    class Lv7_Reine extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 280);

            this.addStep(80, "Ville", ["Chevalier g√©ant", "Reine"], "Le chevalier favori de la reine exige un duel pour pr√©senter une audience au souverain local.");
        }
    }

    class Lv8_Geant extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 360);

            this.addStep(80, "Ville", ["G√©ant", "Plastron en platine", "G√©ant", "√âp√©e de platine"], ["Deux g√©ants se battent en duel pour d√©partager le plus fort d'entre eux.", "Croyants que vous vouliez interrompre le duel, ils se liguent tous deux contre vous."]);
        }
    }

    class Lv8_GoHoumei extends Chapter {
        boss = true;
        
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 150);
            this.addRessource("Terre", 150);

            this.addStep(80, "Montagne", ["Go Houmei, reine des tours"], ["Dans les montagnes du pays de Wei, la plus grande cheffe de guerre est Go Houmei.", "Redout√©e pour ses initiatives et son utilisation d'engin de si√®ge, elle n'a jamais √©t√© d√©faite en d√©fense."]);
        }
    }

    class Lv9_Reine extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 450);

            let array = [];
            for (let i = 0; i < 3; i++) {
                array.push("Princesse");
            }
            for (let i = 0; i < 12; i++) {
                array.push("Soldat");
            }
            this.addStep(90, "Ville", array, ["Les trois princesses d'un royaume voisin d√©cident de se rebeller face √† la reine m√®re.", "Cette derni√®re vous recrute pour les corriger."]);
        }
    }

    class Lv10_Reine extends Chapter {
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 550);

            let array = ["Chevalier mont√©"];
            for (let i = 0; i < 4; i++) {
                array.push("Reine");
            }
            this.addStep(100, "Ville", array, ["Le plus grand chevalier du continent est d√©sign√© par les 5 royaumes alentours.", "Au coeur d'une controverse, vous devez d√©terminer si ce chevalier a pris parti pour l'un des roi."]);
        }
    }

    class Lv10_Atlas extends Chapter {
        boss = true;
        
        constructor(System, number) {
            super(System, number);

            this.addRessource("Or", 500);

            this.addStep(80, "Montagne", ["Atlas, marche-crat√®re"], "Dans la plus grande grotte de la plus haute montagne de l'√Æle, vit un g√©ant hors du commun.", "Atlas est reput√© pour sa taille qui impressionne m√™me les dieux.", "Mais son manque d'√©ducation en fit un individu solitaire et b√™te, √©crasant des paysages par inattention.");
        }
    }

    var chapters = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Lv10_Atlas: Lv10_Atlas,
        Lv10_Reine: Lv10_Reine,
        Lv1_Bandits: Lv1_Bandits,
        Lv1_Chien: Lv1_Chien,
        Lv1_Humains: Lv1_Humains,
        Lv1_Loup: Lv1_Loup,
        Lv1_Mendiant: Lv1_Mendiant,
        Lv2_Bandits: Lv2_Bandits,
        Lv2_Ferme: Lv2_Ferme,
        Lv2_Mur: Lv2_Mur,
        Lv2_Raido: Lv2_Raido,
        Lv3_Geant: Lv3_Geant,
        Lv4_Chevalier: Lv4_Chevalier,
        Lv4_Kanki: Lv4_Kanki,
        Lv5_ChevalierGeant: Lv5_ChevalierGeant,
        Lv6_Gyoun: Lv6_Gyoun,
        Lv6_Roi: Lv6_Roi,
        Lv7_Eruption: Lv7_Eruption,
        Lv7_Reine: Lv7_Reine,
        Lv8_Geant: Lv8_Geant,
        Lv8_GoHoumei: Lv8_GoHoumei,
        Lv9_Reine: Lv9_Reine
    });

    /* src/Login/BlackScreen.svelte generated by Svelte v3.59.2 */

    const file$A = "src/Login/BlackScreen.svelte";

    function create_fragment$A(ctx) {
    	let div2;
    	let div0;
    	let button0;
    	let t1;
    	let div1;
    	let t2;
    	let button1;
    	let t4;
    	let button2;
    	let t6;
    	let button3;
    	let t8;
    	let br;
    	let t9;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Jouer";
    			t1 = space();
    			div1 = element("div");
    			t2 = text("by \n        ");
    			button1 = element("button");
    			button1.textContent = "Algolbarth";
    			t4 = text("\n        -\n        ");
    			button2 = element("button");
    			button2.textContent = "Github Repository";
    			t6 = text("\n        -\n        ");
    			button3 = element("button");
    			button3.textContent = "Website";
    			t8 = space();
    			br = element("br");
    			t9 = text("\n        version BETA - 2024");
    			attr_dev(button0, "class", "classic svelte-1ra0bfh");
    			add_location(button0, file$A, 6, 8, 92);
    			attr_dev(div0, "class", "center");
    			add_location(div0, file$A, 5, 4, 63);
    			attr_dev(button1, "class", "classic svelte-1ra0bfh");
    			add_location(button1, file$A, 16, 8, 340);
    			attr_dev(button2, "class", "classic svelte-1ra0bfh");
    			add_location(button2, file$A, 25, 8, 548);
    			attr_dev(button3, "class", "classic svelte-1ra0bfh");
    			add_location(button3, file$A, 34, 8, 773);
    			add_location(br, file$A, 42, 8, 972);
    			attr_dev(div1, "id", "credits");
    			attr_dev(div1, "class", "svelte-1ra0bfh");
    			add_location(div1, file$A, 14, 4, 301);
    			attr_dev(div2, "id", "body");
    			attr_dev(div2, "class", "svelte-1ra0bfh");
    			add_location(div2, file$A, 4, 0, 43);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div1, button1);
    			append_dev(div1, t4);
    			append_dev(div1, button2);
    			append_dev(div1, t6);
    			append_dev(div1, button3);
    			append_dev(div1, t8);
    			append_dev(div1, br);
    			append_dev(div1, t9);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[3], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BlackScreen', slots, []);
    	let { System } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<BlackScreen> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BlackScreen> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.music.play();
    		System.pages.change("TitleScreen");
    	};

    	const click_handler_1 = () => {
    		window.open("https://github.com/Algolbarth");
    	};

    	const click_handler_2 = () => {
    		window.open("https://github.com/Algolbarth/JsRPG");
    	};

    	const click_handler_3 = () => {
    		window.open("https://algolbarth.github.io/");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, click_handler, click_handler_1, click_handler_2, click_handler_3];
    }

    class BlackScreen extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BlackScreen",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get System() {
    		throw new Error("<BlackScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<BlackScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class Account {
        aventure = {
            victory : 0,
            defeat : 0,
            total : function () {
                return this.victory + this.defeat;
            }
        };
        construct = {
            victory : 0,
            defeat : 0,
            total : function () {
                return this.victory + this.defeat;
            }
        };

        constructor (System, name) {
            this.System = System;
            this.name = name;
        };

        victory = function () {
            return this.aventure.victory + this.construct.victory;
        };

        defeat = function () {
            return this.aventure.defeat + this.construct.defeat;
        };

        matchs = function () {
            return this.aventure.total() + this.construct.total();
        };
    }

    /* src/Login/TitleScreen.svelte generated by Svelte v3.59.2 */
    const file$z = "src/Login/TitleScreen.svelte";

    function create_fragment$z(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let br0;
    	let t1;
    	let button0;
    	let t3;
    	let br1;
    	let t4;
    	let button1;
    	let t6;
    	let br2;
    	let br3;
    	let t7;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			br0 = element("br");
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Connexion";
    			t3 = space();
    			br1 = element("br");
    			t4 = space();
    			button1 = element("button");
    			button1.textContent = "Inscription";
    			t6 = space();
    			br2 = element("br");
    			br3 = element("br");
    			t7 = space();
    			button2 = element("button");
    			button2.textContent = "Jouer en tant qu'invit√©";
    			if (!src_url_equal(img.src, img_src_value = "Pictures/Title.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo");
    			attr_dev(img, "class", "logo");
    			add_location(img, file$z, 11, 4, 231);
    			add_location(br0, file$z, 12, 4, 291);
    			attr_dev(button0, "class", "big svelte-ch8oe9");
    			add_location(button0, file$z, 13, 4, 301);
    			add_location(br1, file$z, 19, 4, 436);
    			attr_dev(button1, "class", "big svelte-ch8oe9");
    			add_location(button1, file$z, 20, 4, 447);
    			add_location(br2, file$z, 26, 4, 587);
    			add_location(br3, file$z, 26, 10, 593);
    			attr_dev(button2, "class", "classic");
    			add_location(button2, file$z, 27, 4, 604);
    			attr_dev(div, "id", "body");
    			attr_dev(div, "class", "svelte-ch8oe9");
    			add_location(div, file$z, 10, 0, 211);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			append_dev(div, br0);
    			append_dev(div, t1);
    			append_dev(div, button0);
    			append_dev(div, t3);
    			append_dev(div, br1);
    			append_dev(div, t4);
    			append_dev(div, button1);
    			append_dev(div, t6);
    			append_dev(div, br2);
    			append_dev(div, br3);
    			append_dev(div, t7);
    			append_dev(div, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TitleScreen', slots, []);
    	let { System } = $$props;

    	function invite() {
    		$$invalidate(0, System.account = new Account(System, "Invit√©"), System);
    		System.pages.change("Menu");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<TitleScreen> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TitleScreen> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("Login");
    	};

    	const click_handler_1 = () => {
    		System.pages.change("Register");
    	};

    	const click_handler_2 = () => {
    		invite();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Account, System, invite });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, invite, click_handler, click_handler_1, click_handler_2];
    }

    class TitleScreen extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TitleScreen",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get System() {
    		throw new Error("<TitleScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<TitleScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let Deck$1 = class Deck {
        cards = [];
        victory = 0;
        defeat = 0;

        constructor(System) {
            this.System = System;

            this.changeName("Nouveau deck", 0);
        };

        changeName = function (name, number) {
            let newName = name;
            if (number > 0) {
                newName += " (" + number + ")";
            }
            for (const deck of this.System.decks) {
                if (deck != this && deck.name == newName) {
                    return this.changeName(name, number + 1);
                }
            }
            this.name = newName;
        };

        canModify = function () {
            if (this.victory > 0 || this.defeat > 0) {
                return false;
            }
            return true;
        };

        add = function (name) {
            if (!this.check(name)) {
                this.cards.push(name);
                this.System.pages.change("Add");
            }
        };

        remove = function (name) {
            for (let i = 0; i < this.cards.length; i++) {
                if (this.cards[i] == name) {
                    this.cards.splice(i, 1);
                }
            }
        };

        check = function (name) {
            for (const card of this.cards) {
                if (card == name) {
                    return true;
                }
            }
            return false;
        };

        clone = function () {
            let deck = new Deck(this.System);
            deck.changeName(this.name, 0);
            for (const card of this.cards) {
                deck.add(card);
            }
            this.System.decks.push(deck);
            this.System.pages.change("Decks");
        };

        delete = function () {
            for (let i = 0; i < this.System.decks.length; i++) {
                if (this.System.decks[i].name == this.name) {
                    this.System.decks.splice(i, 1);
                }
            }
            this.System.deck = undefined;
            this.System.pages.change("Decks");
        };

        playable = function () {
            for (const card of this.cards) {
                if (this.System.cards.getByName(card).level == 1) {
                    return true;
                }
            }
            return false;
        };

        code = function () {
            let code = this.name + "_";
            for (const card of this.cards) {
                code += card + "_";
            }
            return code;
        };
    };

    /* src/Login/Login.svelte generated by Svelte v3.59.2 */
    const file$y = "src/Login/Login.svelte";

    function create_fragment$y(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let br0;
    	let t1;
    	let button0;
    	let t3;
    	let br1;
    	let br2;
    	let t4;
    	let br3;
    	let t5;
    	let input;
    	let t6;
    	let br4;
    	let t7;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			br0 = element("br");
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Retour";
    			t3 = space();
    			br1 = element("br");
    			br2 = element("br");
    			t4 = text("\n    Fichier de la save\n    ");
    			br3 = element("br");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			br4 = element("br");
    			t7 = space();
    			button1 = element("button");
    			button1.textContent = "Valider";
    			if (!src_url_equal(img.src, img_src_value = "Pictures/Title.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo");
    			attr_dev(img, "class", "logo");
    			add_location(img, file$y, 55, 4, 1556);
    			add_location(br0, file$y, 56, 4, 1616);
    			attr_dev(button0, "class", "classic");
    			add_location(button0, file$y, 57, 4, 1626);
    			add_location(br1, file$y, 63, 4, 1768);
    			add_location(br2, file$y, 63, 10, 1774);
    			add_location(br3, file$y, 65, 4, 1808);
    			attr_dev(input, "type", "file");
    			attr_dev(input, "class", "svelte-181w02h");
    			add_location(input, file$y, 66, 4, 1819);
    			add_location(br4, file$y, 67, 4, 1856);
    			attr_dev(button1, "class", "big svelte-181w02h");
    			add_location(button1, file$y, 68, 4, 1867);
    			attr_dev(div, "id", "body");
    			attr_dev(div, "class", "svelte-181w02h");
    			add_location(div, file$y, 54, 0, 1536);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			append_dev(div, br0);
    			append_dev(div, t1);
    			append_dev(div, button0);
    			append_dev(div, t3);
    			append_dev(div, br1);
    			append_dev(div, br2);
    			append_dev(div, t4);
    			append_dev(div, br3);
    			append_dev(div, t5);
    			append_dev(div, input);
    			append_dev(div, t6);
    			append_dev(div, br4);
    			append_dev(div, t7);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[4]),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Login', slots, []);
    	let { System } = $$props;
    	let files;
    	let step;
    	let save;

    	async function login() {
    		if (files != undefined) {
    			save = await files[0].text();
    			step = 0;
    			$$invalidate(0, System.account = new Account(System, readValue()), System);
    			$$invalidate(0, System.account.aventure.victory = readInt(), System);
    			$$invalidate(0, System.account.aventure.defeat = readInt(), System);
    			$$invalidate(0, System.account.construct.victory = readInt(), System);
    			$$invalidate(0, System.account.construct.defeat = readInt(), System);
    			let decks = readInt();

    			for (let i = 0; i < decks; i++) {
    				let deck = new Deck$1(System);
    				deck.changeName(readValue(), 0);
    				deck.victory = readInt();
    				deck.defeat = readInt();
    				let cards = readInt();

    				for (let j = 0; j < cards; j++) {
    					let name = readValue();

    					if (System.cards.getByName(name) != undefined) {
    						deck.add(name);
    					}
    				}

    				System.decks.push(deck);
    			}

    			System.pages.change("Menu");
    		}
    	}

    	function readValue() {
    		let value = "";

    		while (save[step] != "_" && step < save.length) {
    			value += save[step];
    			step++;
    		}

    		step++;
    		return value;
    	}

    	function readInt() {
    		return parseInt(readValue());
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Login> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("TitleScreen");
    	};

    	function input_change_handler() {
    		files = this.files;
    		$$invalidate(1, files);
    	}

    	const click_handler_1 = () => {
    		login();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Account,
    		Deck: Deck$1,
    		System,
    		files,
    		step,
    		save,
    		login,
    		readValue,
    		readInt
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('files' in $$props) $$invalidate(1, files = $$props.files);
    		if ('step' in $$props) step = $$props.step;
    		if ('save' in $$props) save = $$props.save;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, files, login, click_handler, input_change_handler, click_handler_1];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get System() {
    		throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Login/Register.svelte generated by Svelte v3.59.2 */
    const file$x = "src/Login/Register.svelte";

    function create_fragment$x(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let br0;
    	let t1;
    	let button0;
    	let t3;
    	let br1;
    	let br2;
    	let t4;
    	let br3;
    	let t5;
    	let input;
    	let t6;
    	let br4;
    	let br5;
    	let t7;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			br0 = element("br");
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Retour";
    			t3 = space();
    			br1 = element("br");
    			br2 = element("br");
    			t4 = text("\n    Nom du compte\n    ");
    			br3 = element("br");
    			t5 = space();
    			input = element("input");
    			t6 = space();
    			br4 = element("br");
    			br5 = element("br");
    			t7 = space();
    			button1 = element("button");
    			button1.textContent = "Valider";
    			if (!src_url_equal(img.src, img_src_value = "Pictures/Title.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo");
    			attr_dev(img, "class", "logo");
    			add_location(img, file$x, 15, 4, 293);
    			add_location(br0, file$x, 16, 4, 354);
    			attr_dev(button0, "class", "classic");
    			add_location(button0, file$x, 17, 4, 365);
    			add_location(br1, file$x, 23, 4, 507);
    			add_location(br2, file$x, 23, 10, 513);
    			add_location(br3, file$x, 25, 4, 542);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "svelte-vozvv4");
    			add_location(input, file$x, 26, 4, 553);
    			add_location(br4, file$x, 27, 4, 597);
    			add_location(br5, file$x, 27, 10, 603);
    			attr_dev(button1, "class", "big svelte-vozvv4");
    			add_location(button1, file$x, 28, 4, 614);
    			attr_dev(div, "id", "body");
    			attr_dev(div, "class", "svelte-vozvv4");
    			add_location(div, file$x, 14, 0, 273);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			append_dev(div, br0);
    			append_dev(div, t1);
    			append_dev(div, button0);
    			append_dev(div, t3);
    			append_dev(div, br1);
    			append_dev(div, br2);
    			append_dev(div, t4);
    			append_dev(div, br3);
    			append_dev(div, t5);
    			append_dev(div, input);
    			set_input_value(input, /*name*/ ctx[1]);
    			append_dev(div, t6);
    			append_dev(div, br4);
    			append_dev(div, br5);
    			append_dev(div, t7);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[4]),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name*/ 2 && input.value !== /*name*/ ctx[1]) {
    				set_input_value(input, /*name*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Register', slots, []);
    	let { System } = $$props;
    	let name = "";

    	function register() {
    		if (name != "") {
    			$$invalidate(0, System.account = new Account(System, name), System);
    			System.pages.change("Menu");
    		}
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Register> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Register> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("TitleScreen");
    	};

    	function input_input_handler() {
    		name = this.value;
    		$$invalidate(1, name);
    	}

    	const click_handler_1 = () => {
    		register();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Account, System, name, register });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('name' in $$props) $$invalidate(1, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, name, register, click_handler, input_input_handler, click_handler_1];
    }

    class Register extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Register",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get System() {
    		throw new Error("<Register>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Register>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Menu/Menu.svelte generated by Svelte v3.59.2 */

    const file$w = "src/Menu/Menu.svelte";

    function create_fragment$w(ctx) {
    	let div3;
    	let img;
    	let img_src_value;
    	let t0;
    	let div2;
    	let div0;
    	let button0;
    	let t2;
    	let br0;
    	let br1;
    	let t3;
    	let button1;
    	let t5;
    	let br2;
    	let br3;
    	let t6;
    	let button2;
    	let t8;
    	let div1;
    	let button3;
    	let t10;
    	let br4;
    	let br5;
    	let t11;
    	let button4;
    	let t13;
    	let br6;
    	let br7;
    	let t14;
    	let button5;
    	let t16;
    	let br8;
    	let t17;
    	let button6;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			img = element("img");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "Jouer";
    			t2 = space();
    			br0 = element("br");
    			br1 = element("br");
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Decks";
    			t5 = space();
    			br2 = element("br");
    			br3 = element("br");
    			t6 = space();
    			button2 = element("button");
    			button2.textContent = "Biblioth√®que";
    			t8 = space();
    			div1 = element("div");
    			button3 = element("button");
    			button3.textContent = "Profil";
    			t10 = space();
    			br4 = element("br");
    			br5 = element("br");
    			t11 = space();
    			button4 = element("button");
    			button4.textContent = "Options";
    			t13 = space();
    			br6 = element("br");
    			br7 = element("br");
    			t14 = space();
    			button5 = element("button");
    			button5.textContent = "Sauvegarder";
    			t16 = space();
    			br8 = element("br");
    			t17 = space();
    			button6 = element("button");
    			button6.textContent = "Se d√©connecter";
    			if (!src_url_equal(img.src, img_src_value = "Pictures/Title.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo");
    			attr_dev(img, "class", "logo");
    			add_location(img, file$w, 52, 4, 1383);
    			attr_dev(button0, "class", "big svelte-kk1ne2");
    			add_location(button0, file$w, 55, 12, 1486);
    			add_location(br0, file$w, 61, 12, 1664);
    			add_location(br1, file$w, 61, 18, 1670);
    			attr_dev(button1, "class", "big svelte-kk1ne2");
    			add_location(button1, file$w, 62, 12, 1689);
    			add_location(br2, file$w, 68, 12, 1868);
    			add_location(br3, file$w, 68, 18, 1874);
    			attr_dev(button2, "class", "big svelte-kk1ne2");
    			add_location(button2, file$w, 69, 12, 1893);
    			add_location(div0, file$w, 54, 8, 1468);
    			attr_dev(button3, "class", "big svelte-kk1ne2");
    			add_location(button3, file$w, 77, 12, 2110);
    			add_location(br4, file$w, 83, 12, 2291);
    			add_location(br5, file$w, 83, 18, 2297);
    			attr_dev(button4, "class", "big svelte-kk1ne2");
    			add_location(button4, file$w, 84, 12, 2316);
    			add_location(br6, file$w, 90, 12, 2500);
    			add_location(br7, file$w, 90, 18, 2506);
    			attr_dev(button5, "class", "big svelte-kk1ne2");
    			add_location(button5, file$w, 91, 12, 2525);
    			add_location(br8, file$w, 97, 12, 2688);
    			attr_dev(button6, "class", "classic");
    			add_location(button6, file$w, 98, 12, 2707);
    			add_location(div1, file$w, 76, 8, 2092);
    			attr_dev(div2, "id", "list");
    			attr_dev(div2, "class", "svelte-kk1ne2");
    			add_location(div2, file$w, 53, 4, 1444);
    			attr_dev(div3, "id", "body");
    			attr_dev(div3, "class", "svelte-kk1ne2");
    			add_location(div3, file$w, 51, 0, 1363);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, img);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t2);
    			append_dev(div0, br0);
    			append_dev(div0, br1);
    			append_dev(div0, t3);
    			append_dev(div0, button1);
    			append_dev(div0, t5);
    			append_dev(div0, br2);
    			append_dev(div0, br3);
    			append_dev(div0, t6);
    			append_dev(div0, button2);
    			append_dev(div2, t8);
    			append_dev(div2, div1);
    			append_dev(div1, button3);
    			append_dev(div1, t10);
    			append_dev(div1, br4);
    			append_dev(div1, br5);
    			append_dev(div1, t11);
    			append_dev(div1, button4);
    			append_dev(div1, t13);
    			append_dev(div1, br6);
    			append_dev(div1, br7);
    			append_dev(div1, t14);
    			append_dev(div1, button5);
    			append_dev(div1, t16);
    			append_dev(div1, br8);
    			append_dev(div1, t17);
    			append_dev(div1, button6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[4], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[5], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[6], false, false, false, false),
    					listen_dev(button4, "click", /*click_handler_4*/ ctx[7], false, false, false, false),
    					listen_dev(button5, "click", /*click_handler_5*/ ctx[8], false, false, false, false),
    					listen_dev(button6, "click", /*click_handler_6*/ ctx[9], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Menu', slots, []);
    	let { System } = $$props;

    	function save() {
    		let text = System.account.name + "_" + System.account.aventure.victory + "_" + System.account.aventure.defeat + "_" + System.account.construct.victory + "_" + System.account.construct.defeat + "_" + System.decks.length + "_";

    		for (const deck of System.decks) {
    			text += deck.name + "_" + deck.victory + "_" + deck.defeat + "_" + deck.cards.length + "_";

    			for (const card of deck.cards) {
    				text += card + "_";
    			}
    		}

    		var element = document.createElement("a");
    		element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(text));
    		element.setAttribute("download", System.account.name);
    		element.style.display = "none";
    		document.body.appendChild(element);
    		element.click();
    		document.body.removeChild(element);
    	}

    	function logout() {
    		$$invalidate(0, System.decks = [], System);
    		$$invalidate(0, System.account = "", System);
    		System.pages.change("TitleScreen");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Menu> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Menu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("Play");
    	};

    	const click_handler_1 = () => {
    		System.pages.change("Decks");
    	};

    	const click_handler_2 = () => {
    		System.pages.change("Library");
    	};

    	const click_handler_3 = () => {
    		System.pages.change("Profil");
    	};

    	const click_handler_4 = () => {
    		System.pages.change("Settings");
    	};

    	const click_handler_5 = () => {
    		save();
    	};

    	const click_handler_6 = () => {
    		logout();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, save, logout });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		save,
    		logout,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6
    	];
    }

    class Menu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get System() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let Entity$2 = class Entity {
        life = {
            current: 0,
            max: 0,
            set: function (value) {
                this.current = value;
                this.max = value;
            }
        };
        zones = [{
            name: "Lieux",
            cards: [],
            size: 3
        },
        {
            name: "Boutique",
            level: 1,
            cards: [],
            size: 10
        },
        {
            name: "Main",
            cards: [],
            size: 10
        },
        {
            name: "Terrain",
            cards: [],
            size: 10
        },
        {
            name: "D√©fausse",
            cards: []
        }];
        ressources = [];
        place = undefined;

        constructor(System) {
            this.System = System;
            this.setRessources();
        }

        adversary = function () {
            if (this == this.System.game.player) {
                return this.System.game.bot;
            }
            return this.System.game.player;
        };

        setRessources = function () {
            for (const r of this.System.ressources) {
                this.ressources.push({
                    name: r,
                    current: 0,
                    stock: 0,
                    total: function () {
                        return this.current + this.stock;
                    },
                    spend: function (value) {
                        if (value < this.current) {
                            this.current -= value;
                            value = 0;
                        }
                        else {
                            value -= this.current;
                            this.current = 0;
                        }

                        this.stock -= value;
                        if (this.stock < 0) {
                            this.stock = 0;
                        }
                    },
                    max: 0
                });
            }
        };

        zone = function (name) {
            for (const z of this.zones) {
                if (z.name == name) {
                    return z;
                }
            }
        };

        ressource = function (name) {
            for (const z of this.ressources) {
                if (z.name == name) {
                    return z;
                }
            }
        };

        getCard = function (name) {
            let card = this.System.cards.getByName(name);
            card.owner = this;
            if (this == this.System.game.player) {
                card.cache = false;
            }
            else {
                card.cache = true;
            }
            return card;
        };

        cardList = function (condition = undefined, drawer) {
            let nameList = [];
            if (this.System.game.deck == undefined) {
                for (const card of this.System.cards.instance) {
                    if (card.playable && this.place.condition(card) && card.level <= this.zone("Boutique").level && (condition == undefined || condition(card, drawer))) {
                        nameList.push(card.name);
                    }
                }
            }
            else {
                for (const c of this.System.game.deck.cards) {
                    let card = this.System.cards.getByName(c);
                    if (this.place.condition(card) && card.level <= this.zone("Boutique").level) {
                        nameList.push(c);
                    }
                }
            }
            return nameList;
        };

        draw = function (number, condition, drawer, array=[]) {
            let nameList = this.cardList(condition, drawer);
            let card = undefined;

            if (nameList.length > 0) {
                card = this.getCard(nameList[parseInt(Math.random() * nameList.length)]);
                card.add("Boutique");
            }

            array.push(card);

            if (number > 1) {
                array = this.draw(number - 1, condition, drawer, array);
            }
            return array;
        };

        discover = function (number, condition, drawer, array=[]) {
            let nameList = this.cardList(condition, drawer);
            let card = undefined;

            for (const card of this.zone("Boutique").cards) {
                if (nameList.includes(card.name)) {
                    nameList.splice(nameList.indexOf(card.name), 1);
                }
            }

            if (nameList.length > 0) {
                card = this.getCard(nameList[parseInt(Math.random() * nameList.length)]);
                card.add("Boutique");
            }

            array.push(card);

            if (number > 1) {
                array = this.discover(number - 1, condition, drawer, array);
            }
            return array
        };

        upShop = function () {
            if (this.ressource("Or").total() >= this.zone("Boutique").level * 10) {
                this.ressource("Or").spend(this.zone("Boutique").level * 10);
                this.zone("Boutique").level++;
                this.refreshShop();
                this.System.pages.change("Game");
            }
        };

        actualiseShop = function () {
            if (this.ressource("Or").total() >= 10) {
                this.ressource("Or").spend(10);
                this.refreshShop();
                this.System.pages.change("Game");
            }
        };

        refreshShop = function () {
            let boutique = this.System.copy(this.zone("Boutique").cards);
            for (const card of boutique) {
                if (!card.verrou) {
                    card.remove();
                }
            }
            if (this.zone("Boutique").cards.length < 5) {
                this.draw(5 - this.zone("Boutique").cards.length);
            }
        };

        lock = function () {
            let check = false;
            for (const card of this.zone("Boutique").cards) {
                if (!card.verrou) {
                    check = true;
                }
            }

            if (check) {
                for (const card of this.zone("Boutique").cards) {
                    card.lock(true);
                }
            }
            else {
                for (const card of this.zone("Boutique").cards) {
                    card.lock(false);
                }
            }
            this.System.pages.change("Game");
        };

        play = function () {
            let playable = true;
            while (playable) {
                playable = false;
                let main = this.System.copy(this.zone("Main").cards);
                for (const card of main) {
                    card.use();
                    if (card.zone == undefined || card.zone.name != "Main") {
                        playable = true;
                    }
                }
            }

            let boutique = this.System.copy(this.zone("Boutique").cards);
            for (const card of boutique) {
                card.buy();
            }

            for (const ressource of this.ressources) {
                ressource.current = ressource.max;
            }

            if (this.System.game.mode != "Entra√Ænement") {
                if (this.step < this.System.game.chapter.steps.length) {
                    for (const name of this.System.game.chapter.steps[this.step].cards) {
                        let card = this.getCard(name, this);
                        card.add("Boutique");
                    }
                }
                this.step++;
            }
        };

        checkPerpetuite = function () {
            let defausse = this.System.copy(this.zone("D√©fausse").cards);
            for (const card of defausse) {
                if (card.stat("Perp√©tuit√©").current == 1) {
                    card.remove();
                }
                else {
                    card.stat("Perp√©tuit√©").current--;
                }
            }
        };

        totalIntelligence = function () {
            let total = 0;
            for (const card of this.zone("Terrain").cards) {
                total += card.stat("Intelligence").value();
            }
            return total;
        };
    };

    class Battle {
        fighter = undefined;

        constructor(System) {
            this.System = System;
        }

        isBattle = function () {
            if (this.phase == "Combat") {
                return true;
            }
            return false;
        };

        newBattle = function () {
            this.phase = "Combat";
            this.turn = 0;
            this.nextTurn();
            this.System.pages.change("Game");
        };

        nextTurn = function () {
            this.turn++;
            this.fighter = undefined;

            this.resetAction();

            for (const entity of [this.player, this.bot]) {
                for (const zone of entity.zones) {
                    let cpy = this.System.copy(zone.cards);
                    for (const card of cpy) {
                        card.turnEffect();
                        if (card.type == "Cr√©ature") {
                            for (const e of card.equipments) {
                                e.turnEffect();
                            }
                        }
                    }
                }
            }
        };

        resetAction = function () {
            for (const card of this.player.zone("Terrain").cards) {
                card.stat("Actions").current = card.stat("Actions").value();
            }
            for (const card of this.bot.zone("Terrain").cards) {
                card.stat("Actions").current = card.stat("Actions").value();
            }
        };

        actionBattle = function () {
            if (!this.isEndBattle()) {
                if (!this.isEndTurn()) {
                    this.nextFighter();
                    this.fighter.play();
                }
                else {
                    this.endTurn();
                    this.nextTurn();
                }
                this.System.pages.change("Game");
            }
            else {
                this.endTurn();
                this.endBattle();
            }
        };

        nextFighter = function (camp = undefined) {
            if (camp == undefined) {
                if (this.fighter == undefined) {
                    camp = this.player;
                }
                else {
                    camp = this.fighter.owner.adversary();
                }
            }

            let speed = this.bestSpeed();
            this.fighter = undefined;
            for (let i = 0; i < camp.zone("Terrain").cards.length; i++) {
                let card = camp.zone("Terrain").cards[i];
                if (this.fighter == undefined && card.stat("Actions").current > 0 && speed == card.stat("Vitesse").value()) {
                    this.fighter = card;
                }
            }

            if (this.fighter == undefined) {
                this.nextFighter(camp.adversary());
            }
        };

        bestSpeed = function () {
            let best = 0;

            for (const card of this.player.zone("Terrain").cards) {
                if (card.stat("Actions").current > 0 && card.stat("Vitesse").value() > best) {
                    best = card.stat("Vitesse").value();
                }
            }
            for (const card of this.bot.zone("Terrain").cards) {
                if (card.stat("Actions").current > 0 && card.stat("Vitesse").value() > best) {
                    best = card.stat("Vitesse").value();
                }
            }

            return best;
        };

        isEndTurn = function () {
            for (const card of this.player.zone("Terrain").cards) {
                if (card.stat("Actions").current > 0) {
                    return false;
                }
            }
            for (const card of this.bot.zone("Terrain").cards) {
                if (card.stat("Actions").current > 0) {
                    return false;
                }
            }
            return true;
        };

        endTurn = function () {
            for (const entity of [this.player, this.bot]) {
                for (const zone of entity.zones) {
                    let cpy = this.System.copy(zone.cards);
                    for (const card of cpy) {
                        for (const stat of card.stats) {
                            stat.turn = 0;
                        }
                        for (const trait of card.traits) {
                            trait.turn = false;
                        }
                    }
                }
            }
        }

        isEndBattle = function () {
            if (this.player.zone("Terrain").cards.length == 0) {
                return true;
            }
            if (this.bot.zone("Terrain").cards.length == 0) {
                return true;
            }
            return false;
        };

        isVictory = function () {
            if (this.bot.zone("Terrain").cards.length == 0) {
                return true;
            }
        };

        endBattle = function () {
            this.phase = "Pr√©paration";
            this.fighter = undefined;

            this.endStep();

            if (this.isVictory()) {
                this.nextStep();
            }
            else {
                for (const card of this.bot.zone("Terrain").cards) {
                    if (card.type == "Cr√©ature") {
                        this.player.life.current -= card.level;
                    }
                }

                if (this.player.life.current <= 0) {
                    this.defeat();
                }
                else {
                    this.startStep();
                    this.System.pages.change("Game");
                }
            }
        };
    }

    let Game$1 = class Game extends Battle {
        use = {
            card: undefined,
            svelte: undefined,
            set: function (card, svelte) {
                this.card = card;
                this.svelte = svelte;
            },
            reset: function () {
                this.card = undefined;
                this.svelte = undefined;
            }
        };
        flux = false;
        pause = false;
        phase = "Pr√©paration";
        deck = undefined;

        constructor(System, mode) {
            super(System);

            this.mode = mode;
        };

        init = function () {
            this.player = new Entity$2(this.System);
            this.bot = new Entity$2(this.System);

            if (this.mode == "Entra√Ænement") {
                this.player.life.set(this.System.train.player.life);
                this.player.ressource("Or").max = this.System.train.player.gold;
                this.player.flux = this.System.train.player.flux;
                this.player.zone("Boutique").level = this.System.train.player.zones[1].level;
                for (const zone of this.System.train.player.zones) {
                    for (const card_name of zone.cards) {
                        this.player.getCard(card_name).add(zone.name);
                    }
                }
                this.player.place = this.player.zone("Lieux").cards[0];

                this.bot.life.set(this.System.train.bot.life);
                this.player.ressource("Or").max = this.System.train.player.gold;
                this.player.flux = this.System.train.player.flux;
                this.bot.zone("Boutique").level = this.System.train.bot.zones[1].level;
                for (const zone of this.System.train.bot.zones) {
                    for (const card_name of zone.cards) {
                        let card = this.bot.getCard(card_name);
                        card.add(zone.name);
                        card.cache = false;
                    }
                }
                this.bot.place = this.bot.zone("Lieux").cards[0];

                this.startStep();
            }
            else {
                this.player.life.set(100);
                this.player.ressource("Or").max = 4;
                this.player.flux = 4;

                this.player.getCard("Plaine").add("Lieux");
                this.player.place = this.player.zone("Lieux").cards[0];

                this.player.getCard("Humain").add("Terrain");
                
                this.chapter = new Chapter(this.System, 0);

                this.nextChapter();
            }
        };

        nextChapter = function () {
            if (this.chapter.number < 50) {
                this.bot = new Entity$2(this.System);

                let number = this.chapter.number + 1;
                if (number % 10 == 0) {
                    this.chapter = this.System.bosses.getRandom(number);
                }
                else {
                    this.chapter = this.System.chapters.getRandom(number);
                }

                this.chapter.init();

                this.startChapter();
            }
            else {
                this.victory();
            }
        };

        startChapter = function () {
            this.player.ressource("Or").max++;
            this.player.flux++;

            for (let i = 0; i < 3; i++) {
                this.bot.play();
            }

            this.bot.life.set(this.chapter.steps[0].life);

            this.bot.zone("Lieux").cards = [];
            this.bot.getCard(this.chapter.steps[0].place).add("Lieux");
            this.bot.place = this.bot.zone("Lieux").cards[0];

            this.startStep();
        };

        startStep = function () {
            for (const ressource of this.player.ressources) {
                ressource.current = ressource.max;
            }

            if (this.mode != "Entra√Ænement") {
                this.player.refreshShop();
            }

            for (const entity of [this.player, this.bot]) {
                for (const zone of entity.zones) {
                    let cpy = this.System.copy(zone.cards);
                    for (const card of cpy) {
                        card.startStepEffect();
                        if (card.type == "Cr√©ature") {
                            for (const e of card.equipments) {
                                e.startStepEffect();
                            }
                        }
                    }
                }
            }

            if (this.mode == "Entra√Ænement") {
                this.System.pages.change("Game");
            }
            else {
                if (this.chapter.steps[this.player.step - 1].dialogs.length > 0) {
                    this.System.pages.change("Dialog");
                }
                else {
                    this.System.pages.change("Game");
                }
            }
        };

        endStep = function () {
            this.player.checkPerpetuite();
            this.bot.checkPerpetuite();

            for (const entity of [this.player, this.bot]) {
                for (const zone of entity.zones) {
                    let cpy = this.System.copy(zone.cards);
                    for (const card of cpy) {
                        for (const stat of card.stats) {
                            stat.step = 0;
                        }
                        for (const trait of card.traits) {
                            trait.step = false;
                        }
                    }
                }
            }
        };

        nextStep = function () {
            if (this.mode == "Entra√Ænement") {
                this.startStep();
                this.bot.play();
            }
            else {
                if (this.player.step < this.chapter.steps.length) {
                    this.player.step++;

                    this.System.game.bot.life.set(this.chapter.steps[this.System.game.player.step - 1].life);

                    this.bot.zone("Lieux").cards = [];
                    this.bot.getCard(this.chapter.steps[this.System.game.player.step - 1].place).add("Lieux");
                    this.bot.place = this.bot.zone("Lieux").cards[0];

                    this.startStep();

                    this.bot.play();
                }
                else {
                    this.nextChapter();
                }
            }
        };

        victory = function () {
            if (this.mode == "Aventure") {
                this.System.account.aventure.victory++;
            }
            else if (this.mode == "Construit") {
                this.System.account.construct.victory++;
            }
            this.deck.victory++;
            this.System.pages.change("Finish");
        };

        defeat = function () {
            if (this.mode == "Aventure") {
                this.System.account.aventure.defeat++;
            }
            else if (this.mode == "Construit") {
                this.System.account.construct.defeat++;
            }
            this.deck.defeat++;
            this.System.pages.change("GameOver");
        };
    };

    /* src/Menu/Play.svelte generated by Svelte v3.59.2 */
    const file$v = "src/Menu/Play.svelte";

    function create_fragment$v(ctx) {
    	let button0;
    	let t1;
    	let div;
    	let button1;
    	let t3;
    	let br0;
    	let t4;
    	let button2;
    	let t6;
    	let br1;
    	let t7;
    	let br2;
    	let t8;
    	let button3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			div = element("div");
    			button1 = element("button");
    			button1.textContent = "Aventure";
    			t3 = space();
    			br0 = element("br");
    			t4 = space();
    			button2 = element("button");
    			button2.textContent = "Construit";
    			t6 = space();
    			br1 = element("br");
    			t7 = space();
    			br2 = element("br");
    			t8 = space();
    			button3 = element("button");
    			button3.textContent = "Entra√Ænement";
    			attr_dev(button0, "class", "close svelte-d65s6j");
    			add_location(button0, file$v, 11, 0, 196);
    			attr_dev(button1, "class", "big svelte-d65s6j");
    			add_location(button1, file$v, 18, 4, 320);
    			add_location(br0, file$v, 24, 4, 436);
    			attr_dev(button2, "class", "big svelte-d65s6j");
    			add_location(button2, file$v, 25, 4, 447);
    			add_location(br1, file$v, 31, 4, 586);
    			add_location(br2, file$v, 32, 4, 597);
    			attr_dev(button3, "class", "big svelte-d65s6j");
    			add_location(button3, file$v, 33, 4, 607);
    			attr_dev(div, "id", "body");
    			attr_dev(div, "class", "svelte-d65s6j");
    			add_location(div, file$v, 17, 0, 300);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button1);
    			append_dev(div, t3);
    			append_dev(div, br0);
    			append_dev(div, t4);
    			append_dev(div, button2);
    			append_dev(div, t6);
    			append_dev(div, br1);
    			append_dev(div, t7);
    			append_dev(div, br2);
    			append_dev(div, t8);
    			append_dev(div, button3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[4], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Play', slots, []);
    	let { System } = $$props;

    	function aventure() {
    		$$invalidate(0, System.game = new Game$1(System, "Aventure"), System);
    		System.game.init();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Play> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Play> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("Menu");
    	};

    	const click_handler_1 = () => {
    		aventure();
    	};

    	const click_handler_2 = () => {
    		System.pages.change("Construit");
    	};

    	const click_handler_3 = () => {
    		System.pages.change("Training");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Game: Game$1, System, aventure });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		aventure,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Play extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Play",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get System() {
    		throw new Error("<Play>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Play>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Decks/View.svelte generated by Svelte v3.59.2 */

    const file$u = "src/Decks/View.svelte";

    // (7:0) {#if deck != undefined}
    function create_if_block$j(ctx) {
    	let div6;
    	let div5;
    	let div1;
    	let div0;
    	let t0_value = /*deck*/ ctx[0].name + "";
    	let t0;
    	let t1;
    	let div4;
    	let div2;
    	let t2;
    	let div3;
    	let t3_value = /*deck*/ ctx[0].victory + /*deck*/ ctx[0].defeat + "";
    	let t3;
    	let t4;
    	let br0;
    	let t5;
    	let t6_value = /*deck*/ ctx[0].victory + "";
    	let t6;
    	let t7;
    	let br1;
    	let t8;
    	let t9_value = /*deck*/ ctx[0].defeat + "";
    	let t9;
    	let t10;

    	function select_block_type(ctx, dirty) {
    		if (/*deck*/ ctx[0].cards.length > 0) return create_if_block_1$d;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div4 = element("div");
    			div2 = element("div");
    			if_block.c();
    			t2 = space();
    			div3 = element("div");
    			t3 = text(t3_value);
    			t4 = text(" parties jou√©es\n                    ");
    			br0 = element("br");
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = text(" gagn√©es\n                    ");
    			br1 = element("br");
    			t8 = space();
    			t9 = text(t9_value);
    			t10 = text(" perdues");
    			attr_dev(div0, "class", "box center");
    			set_style(div0, "text-align", "center");
    			add_location(div0, file$u, 10, 16, 244);
    			attr_dev(div1, "id", "cover");
    			attr_dev(div1, "class", "svelte-19in2ja");
    			add_location(div1, file$u, 9, 12, 211);
    			attr_dev(div2, "class", "box");
    			add_location(div2, file$u, 15, 16, 416);
    			add_location(br0, file$u, 24, 20, 757);
    			add_location(br1, file$u, 26, 20, 827);
    			attr_dev(div3, "class", "box");
    			add_location(div3, file$u, 22, 16, 655);
    			attr_dev(div4, "id", "content");
    			attr_dev(div4, "class", "svelte-19in2ja");
    			add_location(div4, file$u, 14, 12, 381);
    			attr_dev(div5, "id", "body");
    			attr_dev(div5, "class", "svelte-19in2ja");
    			add_location(div5, file$u, 8, 8, 183);
    			attr_dev(div6, "id", "shadow");
    			attr_dev(div6, "class", "svelte-19in2ja");
    			add_location(div6, file$u, 7, 4, 157);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			if_block.m(div2, null);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			append_dev(div3, t3);
    			append_dev(div3, t4);
    			append_dev(div3, br0);
    			append_dev(div3, t5);
    			append_dev(div3, t6);
    			append_dev(div3, t7);
    			append_dev(div3, br1);
    			append_dev(div3, t8);
    			append_dev(div3, t9);
    			append_dev(div3, t10);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*deck*/ 1 && t0_value !== (t0_value = /*deck*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			}

    			if (dirty & /*deck*/ 1 && t3_value !== (t3_value = /*deck*/ ctx[0].victory + /*deck*/ ctx[0].defeat + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*deck*/ 1 && t6_value !== (t6_value = /*deck*/ ctx[0].victory + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*deck*/ 1 && t9_value !== (t9_value = /*deck*/ ctx[0].defeat + "")) set_data_dev(t9, t9_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(7:0) {#if deck != undefined}",
    		ctx
    	});

    	return block;
    }

    // (19:20) {:else}
    function create_else_block$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Vide");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(19:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:20) {#if deck.cards.length > 0}
    function create_if_block_1$d(ctx) {
    	let t0_value = /*deck*/ ctx[0].cards.length + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" cartes");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*deck*/ 1 && t0_value !== (t0_value = /*deck*/ ctx[0].cards.length + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(17:20) {#if deck.cards.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let if_block_anchor;
    	let if_block = /*deck*/ ctx[0] != undefined && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*deck*/ ctx[0] != undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let deck;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('View', slots, []);
    	let { System } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<View> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<View> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, deck });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    		if ('deck' in $$props) $$invalidate(0, deck = $$props.deck);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*System*/ 2) {
    			$$invalidate(0, deck = System.view.quick == undefined
    			? System.view.card
    			: System.view.quick);
    		}
    	};

    	return [deck, System];
    }

    class View extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "View",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get System() {
    		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Menu/Construit.svelte generated by Svelte v3.59.2 */
    const file$t = "src/Menu/Construit.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (24:50) {#if array.length > 1}
    function create_if_block$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("s");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(24:50) {#if array.length > 1}",
    		ctx
    	});

    	return block;
    }

    // (26:8) {#each array as deck}
    function create_each_block$c(ctx) {
    	let div2;
    	let div0;
    	let button0;
    	let t0_value = /*deck*/ ctx[7].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let button1;
    	let t3;
    	let mounted;
    	let dispose;

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[3](/*deck*/ ctx[7]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[5](/*deck*/ ctx[7]);
    	}

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[6](/*deck*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Jouer";
    			t3 = space();
    			attr_dev(button0, "class", "classic");
    			add_location(button0, file$t, 28, 20, 641);
    			add_location(div0, file$t, 27, 16, 615);
    			add_location(button1, file$t, 45, 20, 1390);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$t, 44, 16, 1339);
    			attr_dev(div2, "class", "preview svelte-iuu9px");
    			add_location(div2, file$t, 26, 12, 577);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			append_dev(button0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, button1);
    			append_dev(div2, t3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "mouseenter", mouseenter_handler, false, false, false, false),
    					listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[4], false, false, false, false),
    					listen_dev(button0, "click", click_handler_1, false, false, false, false),
    					listen_dev(button1, "click", click_handler_2, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(26:8) {#each array as deck}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let button;
    	let t1;
    	let br;
    	let t2;
    	let div1;
    	let t3_value = /*System*/ ctx[0].several(/*array*/ ctx[1].length, "deck") + "";
    	let t3;
    	let t4;
    	let t5;
    	let div0;
    	let t6;
    	let div2;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*array*/ ctx[1].length > 1 && create_if_block$i(ctx);
    	let each_value = /*array*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	var switch_value = View;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "X";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = text(" jouable");
    			if (if_block) if_block.c();
    			t5 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			div2 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(button, "class", "close");
    			add_location(button, file$t, 14, 0, 265);
    			add_location(br, file$t, 21, 0, 398);
    			attr_dev(div0, "id", "list");
    			attr_dev(div0, "class", "scroll svelte-iuu9px");
    			add_location(div0, file$t, 24, 4, 504);
    			attr_dev(div1, "id", "zone");
    			attr_dev(div1, "class", "svelte-iuu9px");
    			add_location(div1, file$t, 22, 0, 405);
    			attr_dev(div2, "id", "view");
    			attr_dev(div2, "class", "svelte-iuu9px");
    			add_location(div2, file$t, 60, 0, 1828);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t5);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			insert_dev(target, t6, anchor);
    			insert_dev(target, div2, anchor);
    			if (switch_instance) mount_component(switch_instance, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*System*/ 1) && t3_value !== (t3_value = /*System*/ ctx[0].several(/*array*/ ctx[1].length, "deck") + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*System, Game, array, undefined*/ 3) {
    				each_value = /*array*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = View)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div2, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div2);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Construit', slots, []);
    	let { System } = $$props;
    	let array = [];

    	for (const deck of System.decks) {
    		if (deck.playable()) {
    			array.push(deck);
    		}
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Construit> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Construit> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.view.reset();
    		System.pages.change("Play");
    	};

    	const mouseenter_handler = deck => {
    		$$invalidate(0, System.view.quick = deck, System);
    		System.pages.change("Construit");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Construit");
    	};

    	const click_handler_1 = deck => {
    		$$invalidate(0, System.view.card = deck, System);
    		System.pages.change("Construit");
    	};

    	const click_handler_2 = deck => {
    		System.view.reset();
    		$$invalidate(0, System.game = new Game$1(System, "Construit"), System);
    		$$invalidate(0, System.game.deck = deck, System);
    		System.game.init();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Game: Game$1, View, System, array });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('array' in $$props) $$invalidate(1, array = $$props.array);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		array,
    		click_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Construit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Construit",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get System() {
    		throw new Error("<Construit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Construit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Menu/Dropdown.svelte generated by Svelte v3.59.2 */

    const file$s = "src/Menu/Dropdown.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (40:4) {:else}
    function create_else_block$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Liste");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(40:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:4) {#if selected != undefined}
    function create_if_block_1$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*selected*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selected*/ 1) set_data_dev(t, /*selected*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(38:4) {#if selected != undefined}",
    		ctx
    	});

    	return block;
    }

    // (45:2) {#if isDropdownOpen}
    function create_if_block$h(ctx) {
    	let div;
    	let each_value = /*array*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "list scroll svelte-1phpwbn");
    			set_style(div, "width", /*width*/ ctx[3] + "vw");
    			set_style(div, "max-height", /*height*/ ctx[2] + "vh");
    			add_location(div, file$s, 45, 3, 881);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*select, array*/ 130) {
    				each_value = /*array*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*width*/ 8) {
    				set_style(div, "width", /*width*/ ctx[3] + "vw");
    			}

    			if (dirty & /*height*/ 4) {
    				set_style(div, "max-height", /*height*/ ctx[2] + "vh");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(45:2) {#if isDropdownOpen}",
    		ctx
    	});

    	return block;
    }

    // (51:4) {#each array as element}
    function create_each_block$b(ctx) {
    	let button;
    	let t0_value = /*element*/ ctx[10] + "";
    	let t0;
    	let t1;
    	let br;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[9](/*element*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			br = element("br");
    			attr_dev(button, "class", "svelte-1phpwbn");
    			add_location(button, file$s, 51, 5, 1017);
    			add_location(br, file$s, 56, 5, 1112);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*array*/ 2 && t0_value !== (t0_value = /*element*/ ctx[10] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(51:4) {#each array as element}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let button;
    	let t;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*selected*/ ctx[0] != undefined) return create_if_block_1$c;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*isDropdownOpen*/ ctx[4] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			button = element("button");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(button, "class", "main svelte-1phpwbn");
    			set_style(button, "width", /*width*/ ctx[3] + "vw");
    			add_location(button, file$s, 32, 3, 656);
    			add_location(div0, file$s, 31, 2, 647);
    			add_location(div1, file$s, 30, 1, 601);
    			set_style(div2, "height", `3vh`);
    			add_location(div2, file$s, 29, 0, 575);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, button);
    			if_block0.m(button, null);
    			append_dev(div1, t);
    			if (if_block1) if_block1.m(div1, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*handleDropdownClick*/ ctx[5], false, false, false, false),
    					listen_dev(div1, "focusout", /*handleDropdownFocusLoss*/ ctx[6], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(button, null);
    				}
    			}

    			if (dirty & /*width*/ 8) {
    				set_style(button, "width", /*width*/ ctx[3] + "vw");
    			}

    			if (/*isDropdownOpen*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$h(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dropdown', slots, []);
    	let { array = [] } = $$props;
    	let { selected } = $$props;

    	let { selecting = function () {
    		
    	} } = $$props;

    	let { height = 25 } = $$props;
    	let { width = 15 } = $$props;
    	let isDropdownOpen = false;

    	const handleDropdownClick = () => {
    		$$invalidate(4, isDropdownOpen = !isDropdownOpen);
    	};

    	const handleDropdownFocusLoss = ({ relatedTarget, currentTarget }) => {
    		if (relatedTarget instanceof HTMLElement && currentTarget.contains(relatedTarget)) return;
    		$$invalidate(4, isDropdownOpen = false);
    	};

    	function select(element) {
    		selecting(element);
    		$$invalidate(0, selected = element);
    		$$invalidate(4, isDropdownOpen = false);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (selected === undefined && !('selected' in $$props || $$self.$$.bound[$$self.$$.props['selected']])) {
    			console.warn("<Dropdown> was created without expected prop 'selected'");
    		}
    	});

    	const writable_props = ['array', 'selected', 'selecting', 'height', 'width'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dropdown> was created with unknown prop '${key}'`);
    	});

    	const click_handler = element => {
    		select(element);
    	};

    	$$self.$$set = $$props => {
    		if ('array' in $$props) $$invalidate(1, array = $$props.array);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('selecting' in $$props) $$invalidate(8, selecting = $$props.selecting);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    		if ('width' in $$props) $$invalidate(3, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({
    		array,
    		selected,
    		selecting,
    		height,
    		width,
    		isDropdownOpen,
    		handleDropdownClick,
    		handleDropdownFocusLoss,
    		select
    	});

    	$$self.$inject_state = $$props => {
    		if ('array' in $$props) $$invalidate(1, array = $$props.array);
    		if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
    		if ('selecting' in $$props) $$invalidate(8, selecting = $$props.selecting);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    		if ('width' in $$props) $$invalidate(3, width = $$props.width);
    		if ('isDropdownOpen' in $$props) $$invalidate(4, isDropdownOpen = $$props.isDropdownOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selected,
    		array,
    		height,
    		width,
    		isDropdownOpen,
    		handleDropdownClick,
    		handleDropdownFocusLoss,
    		select,
    		selecting,
    		click_handler
    	];
    }

    class Dropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
    			array: 1,
    			selected: 0,
    			selecting: 8,
    			height: 2,
    			width: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dropdown",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get array() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set array(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selecting() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selecting(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Menu/Filter.svelte generated by Svelte v3.59.2 */
    const file$r = "src/Menu/Filter.svelte";

    function create_fragment$r(ctx) {
    	let div10;
    	let div0;
    	let button0;
    	let t1;
    	let div9;
    	let div2;
    	let t2;
    	let div1;
    	let switch_instance0;
    	let t3;
    	let div4;
    	let t4;
    	let div3;
    	let switch_instance1;
    	let t5;
    	let div6;
    	let t6;
    	let div5;
    	let switch_instance2;
    	let t7;
    	let div8;
    	let t8;
    	let div7;
    	let switch_instance3;
    	let t9;
    	let br;
    	let t10;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Dropdown;

    	function switch_props(ctx) {
    		return {
    			props: {
    				array: /*System*/ ctx[4].sort.levels,
    				selected: /*levelSelect*/ ctx[0],
    				selecting: /*func*/ ctx[8]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	var switch_value_1 = Dropdown;

    	function switch_props_1(ctx) {
    		return {
    			props: {
    				array: /*System*/ ctx[4].sort.types,
    				selected: /*typeSelect*/ ctx[1],
    				selecting: /*func_1*/ ctx[9]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	var switch_value_2 = Dropdown;

    	function switch_props_2(ctx) {
    		return {
    			props: {
    				array: /*System*/ ctx[4].sort.familles,
    				selected: /*familleSelect*/ ctx[2],
    				selecting: /*func_2*/ ctx[10]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_2) {
    		switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    	}

    	var switch_value_3 = Dropdown;

    	function switch_props_3(ctx) {
    		return {
    			props: {
    				array: /*System*/ ctx[4].sort.elements,
    				selected: /*elementSelect*/ ctx[3],
    				selecting: /*func_3*/ ctx[11]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_3) {
    		switch_instance3 = construct_svelte_component_dev(switch_value_3, switch_props_3(ctx));
    	}

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			div9 = element("div");
    			div2 = element("div");
    			t2 = text("Niveau\n            ");
    			div1 = element("div");
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t3 = space();
    			div4 = element("div");
    			t4 = text("Type\n            ");
    			div3 = element("div");
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			t5 = space();
    			div6 = element("div");
    			t6 = text("Famille\n            ");
    			div5 = element("div");
    			if (switch_instance2) create_component(switch_instance2.$$.fragment);
    			t7 = space();
    			div8 = element("div");
    			t8 = text("√âl√©ment\n            ");
    			div7 = element("div");
    			if (switch_instance3) create_component(switch_instance3.$$.fragment);
    			t9 = space();
    			br = element("br");
    			t10 = space();
    			button1 = element("button");
    			button1.textContent = "Valider";
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$r, 14, 8, 325);
    			set_style(div0, "text-align", "right");
    			add_location(div0, file$r, 13, 4, 286);
    			add_location(div1, file$r, 26, 12, 568);
    			attr_dev(div2, "class", "container svelte-n1iqfm");
    			add_location(div2, file$r, 24, 8, 513);
    			add_location(div3, file$r, 39, 12, 970);
    			attr_dev(div4, "class", "container svelte-n1iqfm");
    			add_location(div4, file$r, 37, 8, 917);
    			add_location(div5, file$r, 52, 12, 1372);
    			attr_dev(div6, "class", "container svelte-n1iqfm");
    			add_location(div6, file$r, 50, 8, 1316);
    			add_location(div7, file$r, 65, 12, 1783);
    			attr_dev(div8, "class", "container svelte-n1iqfm");
    			add_location(div8, file$r, 63, 8, 1727);
    			attr_dev(div9, "id", "options");
    			attr_dev(div9, "class", "svelte-n1iqfm");
    			add_location(div9, file$r, 23, 4, 486);
    			add_location(br, file$r, 77, 4, 2145);
    			attr_dev(button1, "class", "classic");
    			add_location(button1, file$r, 78, 4, 2156);
    			attr_dev(div10, "id", "body");
    			attr_dev(div10, "class", "center svelte-n1iqfm");
    			add_location(div10, file$r, 12, 0, 251);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div0);
    			append_dev(div0, button0);
    			append_dev(div10, t1);
    			append_dev(div10, div9);
    			append_dev(div9, div2);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			if (switch_instance0) mount_component(switch_instance0, div1, null);
    			append_dev(div9, t3);
    			append_dev(div9, div4);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			if (switch_instance1) mount_component(switch_instance1, div3, null);
    			append_dev(div9, t5);
    			append_dev(div9, div6);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			if (switch_instance2) mount_component(switch_instance2, div5, null);
    			append_dev(div9, t7);
    			append_dev(div9, div8);
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			if (switch_instance3) mount_component(switch_instance3, div7, null);
    			append_dev(div10, t9);
    			append_dev(div10, br);
    			append_dev(div10, t10);
    			append_dev(div10, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[7], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[12], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance0_changes = {};
    			if (dirty & /*System*/ 16) switch_instance0_changes.array = /*System*/ ctx[4].sort.levels;
    			if (dirty & /*levelSelect*/ 1) switch_instance0_changes.selected = /*levelSelect*/ ctx[0];
    			if (dirty & /*levelSelect*/ 1) switch_instance0_changes.selecting = /*func*/ ctx[8];

    			if (switch_value !== (switch_value = Dropdown)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, div1, null);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*System*/ 16) switch_instance1_changes.array = /*System*/ ctx[4].sort.types;
    			if (dirty & /*typeSelect*/ 2) switch_instance1_changes.selected = /*typeSelect*/ ctx[1];
    			if (dirty & /*typeSelect*/ 2) switch_instance1_changes.selecting = /*func_1*/ ctx[9];

    			if (switch_value_1 !== (switch_value_1 = Dropdown)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, div3, null);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}

    			const switch_instance2_changes = {};
    			if (dirty & /*System*/ 16) switch_instance2_changes.array = /*System*/ ctx[4].sort.familles;
    			if (dirty & /*familleSelect*/ 4) switch_instance2_changes.selected = /*familleSelect*/ ctx[2];
    			if (dirty & /*familleSelect*/ 4) switch_instance2_changes.selecting = /*func_2*/ ctx[10];

    			if (switch_value_2 !== (switch_value_2 = Dropdown)) {
    				if (switch_instance2) {
    					group_outros();
    					const old_component = switch_instance2;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_2) {
    					switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    					create_component(switch_instance2.$$.fragment);
    					transition_in(switch_instance2.$$.fragment, 1);
    					mount_component(switch_instance2, div5, null);
    				} else {
    					switch_instance2 = null;
    				}
    			} else if (switch_value_2) {
    				switch_instance2.$set(switch_instance2_changes);
    			}

    			const switch_instance3_changes = {};
    			if (dirty & /*System*/ 16) switch_instance3_changes.array = /*System*/ ctx[4].sort.elements;
    			if (dirty & /*elementSelect*/ 8) switch_instance3_changes.selected = /*elementSelect*/ ctx[3];
    			if (dirty & /*elementSelect*/ 8) switch_instance3_changes.selecting = /*func_3*/ ctx[11];

    			if (switch_value_3 !== (switch_value_3 = Dropdown)) {
    				if (switch_instance3) {
    					group_outros();
    					const old_component = switch_instance3;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_3) {
    					switch_instance3 = construct_svelte_component_dev(switch_value_3, switch_props_3(ctx));
    					create_component(switch_instance3.$$.fragment);
    					transition_in(switch_instance3.$$.fragment, 1);
    					mount_component(switch_instance3, div7, null);
    				} else {
    					switch_instance3 = null;
    				}
    			} else if (switch_value_3) {
    				switch_instance3.$set(switch_instance3_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			if (switch_instance2) transition_in(switch_instance2.$$.fragment, local);
    			if (switch_instance3) transition_in(switch_instance3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			if (switch_instance2) transition_out(switch_instance2.$$.fragment, local);
    			if (switch_instance3) transition_out(switch_instance3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			if (switch_instance0) destroy_component(switch_instance0);
    			if (switch_instance1) destroy_component(switch_instance1);
    			if (switch_instance2) destroy_component(switch_instance2);
    			if (switch_instance3) destroy_component(switch_instance3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Filter', slots, []);
    	let { System } = $$props;
    	let { levelSelect } = $$props;
    	let { typeSelect } = $$props;
    	let { familleSelect } = $$props;
    	let { elementSelect } = $$props;
    	let { sorting } = $$props;
    	let { close } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Filter> was created without expected prop 'System'");
    		}

    		if (levelSelect === undefined && !('levelSelect' in $$props || $$self.$$.bound[$$self.$$.props['levelSelect']])) {
    			console.warn("<Filter> was created without expected prop 'levelSelect'");
    		}

    		if (typeSelect === undefined && !('typeSelect' in $$props || $$self.$$.bound[$$self.$$.props['typeSelect']])) {
    			console.warn("<Filter> was created without expected prop 'typeSelect'");
    		}

    		if (familleSelect === undefined && !('familleSelect' in $$props || $$self.$$.bound[$$self.$$.props['familleSelect']])) {
    			console.warn("<Filter> was created without expected prop 'familleSelect'");
    		}

    		if (elementSelect === undefined && !('elementSelect' in $$props || $$self.$$.bound[$$self.$$.props['elementSelect']])) {
    			console.warn("<Filter> was created without expected prop 'elementSelect'");
    		}

    		if (sorting === undefined && !('sorting' in $$props || $$self.$$.bound[$$self.$$.props['sorting']])) {
    			console.warn("<Filter> was created without expected prop 'sorting'");
    		}

    		if (close === undefined && !('close' in $$props || $$self.$$.bound[$$self.$$.props['close']])) {
    			console.warn("<Filter> was created without expected prop 'close'");
    		}
    	});

    	const writable_props = [
    		'System',
    		'levelSelect',
    		'typeSelect',
    		'familleSelect',
    		'elementSelect',
    		'sorting',
    		'close'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Filter> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		close();
    	};

    	const func = function (element) {
    		$$invalidate(0, levelSelect = element);
    	};

    	const func_1 = function (element) {
    		$$invalidate(1, typeSelect = element);
    	};

    	const func_2 = function (element) {
    		$$invalidate(2, familleSelect = element);
    	};

    	const func_3 = function (element) {
    		$$invalidate(3, elementSelect = element);
    	};

    	const click_handler_1 = () => {
    		sorting(levelSelect, typeSelect, familleSelect, elementSelect);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(4, System = $$props.System);
    		if ('levelSelect' in $$props) $$invalidate(0, levelSelect = $$props.levelSelect);
    		if ('typeSelect' in $$props) $$invalidate(1, typeSelect = $$props.typeSelect);
    		if ('familleSelect' in $$props) $$invalidate(2, familleSelect = $$props.familleSelect);
    		if ('elementSelect' in $$props) $$invalidate(3, elementSelect = $$props.elementSelect);
    		if ('sorting' in $$props) $$invalidate(5, sorting = $$props.sorting);
    		if ('close' in $$props) $$invalidate(6, close = $$props.close);
    	};

    	$$self.$capture_state = () => ({
    		Dropdown,
    		System,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		sorting,
    		close
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(4, System = $$props.System);
    		if ('levelSelect' in $$props) $$invalidate(0, levelSelect = $$props.levelSelect);
    		if ('typeSelect' in $$props) $$invalidate(1, typeSelect = $$props.typeSelect);
    		if ('familleSelect' in $$props) $$invalidate(2, familleSelect = $$props.familleSelect);
    		if ('elementSelect' in $$props) $$invalidate(3, elementSelect = $$props.elementSelect);
    		if ('sorting' in $$props) $$invalidate(5, sorting = $$props.sorting);
    		if ('close' in $$props) $$invalidate(6, close = $$props.close);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		System,
    		sorting,
    		close,
    		click_handler,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		click_handler_1
    	];
    }

    class Filter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			System: 4,
    			levelSelect: 0,
    			typeSelect: 1,
    			familleSelect: 2,
    			elementSelect: 3,
    			sorting: 5,
    			close: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Filter",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get System() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get levelSelect() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set levelSelect(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get typeSelect() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set typeSelect(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get familleSelect() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set familleSelect(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get elementSelect() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set elementSelect(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sorting() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sorting(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set close(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/View/Caracteristics.svelte generated by Svelte v3.59.2 */

    const file$q = "src/View/Caracteristics.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    // (33:8) {#if i > 0}
    function create_if_block_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("¬†");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(33:8) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (32:4) {#each card.elements as element, i}
    function create_each_block_3(ctx) {
    	let t0;
    	let t1_value = /*element*/ ctx[8] + "";
    	let t1;
    	let if_block = /*i*/ ctx[3] > 0 && create_if_block_7$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*element*/ ctx[8] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(32:4) {#each card.elements as element, i}",
    		ctx
    	});

    	return block;
    }

    // (40:0) {#if cout(card).length > 0 || vente(card).length > 0}
    function create_if_block_2$7(ctx) {
    	let div;
    	let show_if_1;
    	let t0;
    	let hr;
    	let t1;
    	let show_if;

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*card*/ 1) show_if_1 = null;
    		if (show_if_1 == null) show_if_1 = !!(cout(/*card*/ ctx[0]).length > 0);
    		if (show_if_1) return create_if_block_5$3;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*card*/ 1) show_if = null;
    		if (show_if == null) show_if = !!(vente(/*card*/ ctx[0]).length > 0);
    		if (show_if) return create_if_block_3$6;
    		return create_else_block$5;
    	}

    	let current_block_type_1 = select_block_type_1(ctx, -1);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block0.c();
    			t0 = space();
    			hr = element("hr");
    			t1 = space();
    			if_block1.c();
    			add_location(hr, file$q, 51, 8, 1018);
    			attr_dev(div, "class", "box");
    			add_location(div, file$q, 40, 4, 719);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, hr);
    			append_dev(div, t1);
    			if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx, dirty)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block0.d();
    			if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(40:0) {#if cout(card).length > 0 || vente(card).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {:else}
    function create_else_block_1$2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "Rien";
    			add_location(i, file$q, 49, 12, 984);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(49:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (42:8) {#if cout(card).length > 0}
    function create_if_block_5$3(ctx) {
    	let each_1_anchor;
    	let each_value_2 = cout(/*card*/ ctx[0]);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cout, card*/ 1) {
    				each_value_2 = cout(/*card*/ ctx[0]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(42:8) {#if cout(card).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (44:16) {#if i > 0}
    function create_if_block_6$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("¬†");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(44:16) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (43:12) {#each cout(card) as cost, i}
    function create_each_block_2(ctx) {
    	let t0;
    	let t1_value = /*cost*/ ctx[6].name + "";
    	let t1;
    	let t2;
    	let t3_value = /*cost*/ ctx[6].value() + "";
    	let t3;
    	let if_block = /*i*/ ctx[3] > 0 && create_if_block_6$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = text(" : ");
    			t3 = text(t3_value);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*cost*/ ctx[6].name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*card*/ 1 && t3_value !== (t3_value = /*cost*/ ctx[6].value() + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(43:12) {#each cout(card) as cost, i}",
    		ctx
    	});

    	return block;
    }

    // (60:8) {:else}
    function create_else_block$5(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			i.textContent = "Rien";
    			add_location(i, file$q, 60, 12, 1274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(60:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:8) {#if vente(card).length > 0}
    function create_if_block_3$6(ctx) {
    	let each_1_anchor;
    	let each_value_1 = vente(/*card*/ ctx[0]);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*vente, card*/ 1) {
    				each_value_1 = vente(/*card*/ ctx[0]);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(53:8) {#if vente(card).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (55:16) {#if i > 0}
    function create_if_block_4$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("¬†");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(55:16) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (54:12) {#each vente(card) as sell, i}
    function create_each_block_1(ctx) {
    	let t0;
    	let t1_value = /*sell*/ ctx[4].name + "";
    	let t1;
    	let t2;
    	let t3_value = /*sell*/ ctx[4].value() + "";
    	let t3;
    	let if_block = /*i*/ ctx[3] > 0 && create_if_block_4$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = text(" : ");
    			t3 = text(t3_value);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*sell*/ ctx[4].name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*card*/ 1 && t3_value !== (t3_value = /*sell*/ ctx[4].value() + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(54:12) {#each vente(card) as sell, i}",
    		ctx
    	});

    	return block;
    }

    // (68:4) {#if card.familles.base.length > 0}
    function create_if_block$g(ctx) {
    	let t;
    	let each_1_anchor;
    	let each_value = /*card*/ ctx[0].familles.base;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			t = text("-\n        ");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1) {
    				each_value = /*card*/ ctx[0].familles.base;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(68:4) {#if card.familles.base.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (71:12) {#if i > 0}
    function create_if_block_1$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("¬†");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(71:12) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (70:8) {#each card.familles.base as famille, i}
    function create_each_block$a(ctx) {
    	let t_value = /*famille*/ ctx[1] + "";
    	let t;
    	let if_block = /*i*/ ctx[3] > 0 && create_if_block_1$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t_value !== (t_value = /*famille*/ ctx[1] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(70:8) {#each card.familles.base as famille, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let div0;
    	let t0_value = /*card*/ ctx[0].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let t3_value = /*card*/ ctx[0].level + "";
    	let t3;
    	let t4;
    	let t5;
    	let show_if = cout(/*card*/ ctx[0]).length > 0 || vente(/*card*/ ctx[0]).length > 0;
    	let t6;
    	let div2;
    	let t7_value = /*card*/ ctx[0].type + "";
    	let t7;
    	let t8;
    	let each_value_3 = /*card*/ ctx[0].elements;
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let if_block0 = show_if && create_if_block_2$7(ctx);
    	let if_block1 = /*card*/ ctx[0].familles.base.length > 0 && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text("Nv ");
    			t3 = text(t3_value);
    			t4 = text("\n    -\n    ");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			div2 = element("div");
    			t7 = text(t7_value);
    			t8 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "box");
    			add_location(div0, file$q, 24, 0, 445);
    			attr_dev(div1, "class", "box");
    			add_location(div1, file$q, 28, 0, 487);
    			attr_dev(div2, "class", "box");
    			add_location(div2, file$q, 65, 0, 1318);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div1, null);
    				}
    			}

    			insert_dev(target, t5, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, t7);
    			append_dev(div2, t8);
    			if (if_block1) if_block1.m(div2, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*card*/ 1 && t0_value !== (t0_value = /*card*/ ctx[0].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*card*/ 1 && t3_value !== (t3_value = /*card*/ ctx[0].level + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*card*/ 1) {
    				each_value_3 = /*card*/ ctx[0].elements;
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}

    			if (dirty & /*card*/ 1) show_if = cout(/*card*/ ctx[0]).length > 0 || vente(/*card*/ ctx[0]).length > 0;

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					if_block0.m(t6.parentNode, t6);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*card*/ 1 && t7_value !== (t7_value = /*card*/ ctx[0].type + "")) set_data_dev(t7, t7_value);

    			if (/*card*/ ctx[0].familles.base.length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$g(ctx);
    					if_block1.c();
    					if_block1.m(div2, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div2);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function cout(c) {
    	let tab = [];

    	for (const cost of c.cout) {
    		if (cost.value() > 0) {
    			tab.push(cost);
    		}
    	}

    	return tab;
    }

    function vente(c) {
    	let tab = [];

    	for (const sell of c.vente) {
    		if (sell.value() > 0) {
    			tab.push(sell);
    		}
    	}

    	return tab;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Caracteristics', slots, []);
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Caracteristics> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Caracteristics> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ card, cout, vente });

    	$$self.$inject_state = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card];
    }

    class Caracteristics extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Caracteristics",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get card() {
    		throw new Error("<Caracteristics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Caracteristics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/View/Description.svelte generated by Svelte v3.59.2 */

    const file$p = "src/View/Description.svelte";

    function create_fragment$p(ctx) {
    	let div1;
    	let i;
    	let t1;
    	let div0;
    	let t2;
    	let t3_value = /*card*/ ctx[0].description() + "";
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			i = element("i");
    			i.textContent = "Description";
    			t1 = space();
    			div0 = element("div");
    			t2 = text("\"");
    			t3 = text(t3_value);
    			t4 = text("\"");
    			add_location(i, file$p, 5, 4, 63);
    			set_style(div0, "text-align", "center");
    			add_location(div0, file$p, 6, 4, 86);
    			attr_dev(div1, "class", "box");
    			add_location(div1, file$p, 4, 0, 41);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, i);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, t4);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*card*/ 1 && t3_value !== (t3_value = /*card*/ ctx[0].description() + "")) set_data_dev(t3, t3_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Description', slots, []);
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Description> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Description> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ card });

    	$$self.$inject_state = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card];
    }

    class Description extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Description",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get card() {
    		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/View/Effet.svelte generated by Svelte v3.59.2 */

    const file$o = "src/View/Effet.svelte";

    function create_fragment$o(ctx) {
    	let div;
    	let i;
    	let t1;
    	let br;
    	let t2;
    	let switch_instance;
    	let current;
    	var switch_value = /*card*/ ctx[0].text;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*card*/ ctx[0].System,
    				card: /*card*/ ctx[0]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			i.textContent = "Effet";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			add_location(i, file$o, 5, 4, 63);
    			add_location(br, file$o, 6, 4, 80);
    			attr_dev(div, "class", "box");
    			add_location(div, file$o, 4, 0, 41);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			if (switch_instance) mount_component(switch_instance, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*card*/ 1) switch_instance_changes.System = /*card*/ ctx[0].System;
    			if (dirty & /*card*/ 1) switch_instance_changes.card = /*card*/ ctx[0];

    			if (dirty & /*card*/ 1 && switch_value !== (switch_value = /*card*/ ctx[0].text)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Effet', slots, []);
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Effet> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Effet> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ card });

    	$$self.$inject_state = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card];
    }

    class Effet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Effet",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get card() {
    		throw new Error("<Effet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Effet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/View/Equipments.svelte generated by Svelte v3.59.2 */

    const file$n = "src/View/Equipments.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (10:4) {#each card.equipments as equipment}
    function create_each_block$9(ctx) {
    	let button;
    	let t0_value = /*equipment*/ ctx[3].name + "";
    	let t0;
    	let t1;
    	let br;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*equipment*/ ctx[3]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			br = element("br");
    			attr_dev(button, "class", "classic");
    			add_location(button, file$n, 10, 8, 231);
    			add_location(br, file$n, 14, 8, 401);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*card*/ 2 && t0_value !== (t0_value = /*equipment*/ ctx[3].name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(10:4) {#each card.equipments as equipment}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div;
    	let i;
    	let t1;
    	let t2_value = /*card*/ ctx[1].equipments.length + "";
    	let t2;
    	let t3;
    	let t4_value = /*card*/ ctx[1].stat("Maniement").value() + "";
    	let t4;
    	let t5;
    	let br;
    	let t6;
    	let each_value = /*card*/ ctx[1].equipments;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			i.textContent = "√âquipements";
    			t1 = text("\n    (");
    			t2 = text(t2_value);
    			t3 = text(" / ");
    			t4 = text(t4_value);
    			t5 = text(")\n    ");
    			br = element("br");
    			t6 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(i, file$n, 6, 4, 86);
    			add_location(br, file$n, 8, 4, 175);
    			attr_dev(div, "class", "box");
    			add_location(div, file$n, 5, 0, 64);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    			append_dev(div, t5);
    			append_dev(div, br);
    			append_dev(div, t6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*card*/ 2 && t2_value !== (t2_value = /*card*/ ctx[1].equipments.length + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*card*/ 2 && t4_value !== (t4_value = /*card*/ ctx[1].stat("Maniement").value() + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*System, card*/ 3) {
    				each_value = /*card*/ ctx[1].equipments;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Equipments', slots, []);
    	let { System } = $$props;
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Equipments> was created without expected prop 'System'");
    		}

    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Equipments> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['System', 'card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Equipments> was created with unknown prop '${key}'`);
    	});

    	const click_handler = equipment => {
    		$$invalidate(0, System.view.card = equipment, System);
    		System.pages.change("Game");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ System, card });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, card, click_handler];
    }

    class Equipments extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { System: 0, card: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Equipments",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get System() {
    		throw new Error("<Equipments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Equipments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get card() {
    		throw new Error("<Equipments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Equipments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/View/Stat.svelte generated by Svelte v3.59.2 */

    const file$m = "src/View/Stat.svelte";

    // (9:4) {#if card.isUnit()}
    function create_if_block_14(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Vie").current + "";
    	let t1;
    	let t2;
    	let t3_value = /*card*/ ctx[0].stat("Vie").value() + "";
    	let t3;
    	let t4;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Vie : ");
    			t1 = text(t1_value);
    			t2 = text(" / ");
    			t3 = text(t3_value);
    			t4 = space();
    			br = element("br");
    			add_location(br, file$m, 10, 8, 197);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Vie").current + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*card*/ 1 && t3_value !== (t3_value = /*card*/ ctx[0].stat("Vie").value() + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(9:4) {#if card.isUnit()}",
    		ctx
    	});

    	return block;
    }

    // (14:4) {#if card.isUnit() && card.stat("Endurance").value() > 0}
    function create_if_block_13(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Endurance").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Endurance : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 15, 8, 338);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Endurance").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(14:4) {#if card.isUnit() && card.stat(\\\"Endurance\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if card.isUnit() && card.stat("D√©fense").value() > 0}
    function create_if_block_12(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("D√©fense").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("D√©fense : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 20, 8, 473);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("D√©fense").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(19:4) {#if card.isUnit() && card.stat(\\\"D√©fense\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (24:4) {#if card.isUnit() && card.stat("Esquive").value() > 0}
    function create_if_block_11(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Esquive").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Esquive : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 25, 8, 608);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Esquive").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(24:4) {#if card.isUnit() && card.stat(\\\"Esquive\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (29:4) {#if card.isUnit() && card.stat("Protection").value() > 0}
    function create_if_block_10(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Protection").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Protection : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 30, 8, 752);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Protection").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(29:4) {#if card.isUnit() && card.stat(\\\"Protection\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (34:4) {#if card.isUnit() && card.stat("Actions").value() > 1}
    function create_if_block_9(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Actions").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Actions : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 35, 8, 887);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Actions").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(34:4) {#if card.isUnit() && card.stat(\\\"Actions\\\").value() > 1}",
    		ctx
    	});

    	return block;
    }

    // (39:4) {#if card.isUnit() && card.stat("Vitesse").value() > 0}
    function create_if_block_8(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Vitesse").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Vitesse : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 40, 8, 1022);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Vitesse").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(39:4) {#if card.isUnit() && card.stat(\\\"Vitesse\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (44:4) {#if card.type == "Cr√©ature"}
    function create_if_block_7(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Attaque").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Attaque : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 45, 8, 1131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Attaque").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(44:4) {#if card.type == \\\"Cr√©ature\\\"}",
    		ctx
    	});

    	return block;
    }

    // (49:4) {#if card.type == "Cr√©ature" && card.stat("Adresse").value() > 0}
    function create_if_block_6$1(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Adresse").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Adresse : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 50, 8, 1276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Adresse").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(49:4) {#if card.type == \\\"Cr√©ature\\\" && card.stat(\\\"Adresse\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (54:4) {#if card.type == "Cr√©ature" && (card.stat("Critique").current > 0 || card.stat("Adresse").value() > 0)}
    function create_if_block_5$2(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Critique").current + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Critique : ");
    			t1 = text(t1_value);
    			t2 = text(" %\n        ");
    			br = element("br");
    			add_location(br, file$m, 55, 8, 1464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Critique").current + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(54:4) {#if card.type == \\\"Cr√©ature\\\" && (card.stat(\\\"Critique\\\").current > 0 || card.stat(\\\"Adresse\\\").value() > 0)}",
    		ctx
    	});

    	return block;
    }

    // (59:4) {#if card.isUnit() && card.stat("Multicoup").value() > 1}
    function create_if_block_4$3(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Multicoup").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Multicoup : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 60, 8, 1605);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Multicoup").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(59:4) {#if card.isUnit() && card.stat(\\\"Multicoup\\\").value() > 1}",
    		ctx
    	});

    	return block;
    }

    // (64:4) {#if card.type == "Cr√©ature" && card.stat("Maniement").value() > 1}
    function create_if_block_3$5(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Maniement").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Maniement : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 65, 8, 1756);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Maniement").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(64:4) {#if card.type == \\\"Cr√©ature\\\" && card.stat(\\\"Maniement\\\").value() > 1}",
    		ctx
    	});

    	return block;
    }

    // (69:4) {#if card.isUnit() && card.stat("Magie").value() > 0}
    function create_if_block_2$6(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Magie").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Magie : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 70, 8, 1885);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Magie").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(69:4) {#if card.isUnit() && card.stat(\\\"Magie\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (74:4) {#if card.isUnit() && card.stat("Intelligence").value() > 0}
    function create_if_block_1$a(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Intelligence").value() + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Intelligence : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 75, 8, 2035);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Intelligence").value() + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(74:4) {#if card.isUnit() && card.stat(\\\"Intelligence\\\").value() > 0}",
    		ctx
    	});

    	return block;
    }

    // (79:4) {#if card.stat("Perp√©tuit√©").current > 0}
    function create_if_block$f(ctx) {
    	let t0;
    	let t1_value = /*card*/ ctx[0].stat("Perp√©tuit√©").current + "";
    	let t1;
    	let t2;
    	let br;

    	const block = {
    		c: function create() {
    			t0 = text("Perp√©tuit√© : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			add_location(br, file$m, 80, 8, 2162);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*card*/ 1 && t1_value !== (t1_value = /*card*/ ctx[0].stat("Perp√©tuit√©").current + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(79:4) {#if card.stat(\\\"Perp√©tuit√©\\\").current > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;
    	let i;
    	let t1;
    	let br;
    	let t2;
    	let show_if_13 = /*card*/ ctx[0].isUnit();
    	let t3;
    	let show_if_12 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Endurance").value() > 0;
    	let t4;
    	let show_if_11 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("D√©fense").value() > 0;
    	let t5;
    	let show_if_10 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Esquive").value() > 0;
    	let t6;
    	let show_if_9 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Protection").value() > 0;
    	let t7;
    	let show_if_8 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Actions").value() > 1;
    	let t8;
    	let show_if_7 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Vitesse").value() > 0;
    	let t9;
    	let t10;
    	let show_if_6 = /*card*/ ctx[0].type == "Cr√©ature" && /*card*/ ctx[0].stat("Adresse").value() > 0;
    	let t11;
    	let show_if_5 = /*card*/ ctx[0].type == "Cr√©ature" && (/*card*/ ctx[0].stat("Critique").current > 0 || /*card*/ ctx[0].stat("Adresse").value() > 0);
    	let t12;
    	let show_if_4 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Multicoup").value() > 1;
    	let t13;
    	let show_if_3 = /*card*/ ctx[0].type == "Cr√©ature" && /*card*/ ctx[0].stat("Maniement").value() > 1;
    	let t14;
    	let show_if_2 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Magie").value() > 0;
    	let t15;
    	let show_if_1 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Intelligence").value() > 0;
    	let t16;
    	let show_if = /*card*/ ctx[0].stat("Perp√©tuit√©").current > 0;
    	let if_block0 = show_if_13 && create_if_block_14(ctx);
    	let if_block1 = show_if_12 && create_if_block_13(ctx);
    	let if_block2 = show_if_11 && create_if_block_12(ctx);
    	let if_block3 = show_if_10 && create_if_block_11(ctx);
    	let if_block4 = show_if_9 && create_if_block_10(ctx);
    	let if_block5 = show_if_8 && create_if_block_9(ctx);
    	let if_block6 = show_if_7 && create_if_block_8(ctx);
    	let if_block7 = /*card*/ ctx[0].type == "Cr√©ature" && create_if_block_7(ctx);
    	let if_block8 = show_if_6 && create_if_block_6$1(ctx);
    	let if_block9 = show_if_5 && create_if_block_5$2(ctx);
    	let if_block10 = show_if_4 && create_if_block_4$3(ctx);
    	let if_block11 = show_if_3 && create_if_block_3$5(ctx);
    	let if_block12 = show_if_2 && create_if_block_2$6(ctx);
    	let if_block13 = show_if_1 && create_if_block_1$a(ctx);
    	let if_block14 = show_if && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			i.textContent = "Statistiques";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			t5 = space();
    			if (if_block3) if_block3.c();
    			t6 = space();
    			if (if_block4) if_block4.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			t9 = space();
    			if (if_block7) if_block7.c();
    			t10 = space();
    			if (if_block8) if_block8.c();
    			t11 = space();
    			if (if_block9) if_block9.c();
    			t12 = space();
    			if (if_block10) if_block10.c();
    			t13 = space();
    			if (if_block11) if_block11.c();
    			t14 = space();
    			if (if_block12) if_block12.c();
    			t15 = space();
    			if (if_block13) if_block13.c();
    			t16 = space();
    			if (if_block14) if_block14.c();
    			add_location(i, file$m, 5, 4, 63);
    			add_location(br, file$m, 6, 4, 87);
    			attr_dev(div, "class", "box");
    			add_location(div, file$m, 4, 0, 41);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t4);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t5);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t6);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t7);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t8);
    			if (if_block6) if_block6.m(div, null);
    			append_dev(div, t9);
    			if (if_block7) if_block7.m(div, null);
    			append_dev(div, t10);
    			if (if_block8) if_block8.m(div, null);
    			append_dev(div, t11);
    			if (if_block9) if_block9.m(div, null);
    			append_dev(div, t12);
    			if (if_block10) if_block10.m(div, null);
    			append_dev(div, t13);
    			if (if_block11) if_block11.m(div, null);
    			append_dev(div, t14);
    			if (if_block12) if_block12.m(div, null);
    			append_dev(div, t15);
    			if (if_block13) if_block13.m(div, null);
    			append_dev(div, t16);
    			if (if_block14) if_block14.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*card*/ 1) show_if_13 = /*card*/ ctx[0].isUnit();

    			if (show_if_13) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_14(ctx);
    					if_block0.c();
    					if_block0.m(div, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_12 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Endurance").value() > 0;

    			if (show_if_12) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_13(ctx);
    					if_block1.c();
    					if_block1.m(div, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_11 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("D√©fense").value() > 0;

    			if (show_if_11) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_12(ctx);
    					if_block2.c();
    					if_block2.m(div, t5);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_10 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Esquive").value() > 0;

    			if (show_if_10) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_11(ctx);
    					if_block3.c();
    					if_block3.m(div, t6);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_9 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Protection").value() > 0;

    			if (show_if_9) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_10(ctx);
    					if_block4.c();
    					if_block4.m(div, t7);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_8 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Actions").value() > 1;

    			if (show_if_8) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_9(ctx);
    					if_block5.c();
    					if_block5.m(div, t8);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_7 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Vitesse").value() > 0;

    			if (show_if_7) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);
    				} else {
    					if_block6 = create_if_block_8(ctx);
    					if_block6.c();
    					if_block6.m(div, t9);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (/*card*/ ctx[0].type == "Cr√©ature") {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);
    				} else {
    					if_block7 = create_if_block_7(ctx);
    					if_block7.c();
    					if_block7.m(div, t10);
    				}
    			} else if (if_block7) {
    				if_block7.d(1);
    				if_block7 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_6 = /*card*/ ctx[0].type == "Cr√©ature" && /*card*/ ctx[0].stat("Adresse").value() > 0;

    			if (show_if_6) {
    				if (if_block8) {
    					if_block8.p(ctx, dirty);
    				} else {
    					if_block8 = create_if_block_6$1(ctx);
    					if_block8.c();
    					if_block8.m(div, t11);
    				}
    			} else if (if_block8) {
    				if_block8.d(1);
    				if_block8 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_5 = /*card*/ ctx[0].type == "Cr√©ature" && (/*card*/ ctx[0].stat("Critique").current > 0 || /*card*/ ctx[0].stat("Adresse").value() > 0);

    			if (show_if_5) {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);
    				} else {
    					if_block9 = create_if_block_5$2(ctx);
    					if_block9.c();
    					if_block9.m(div, t12);
    				}
    			} else if (if_block9) {
    				if_block9.d(1);
    				if_block9 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_4 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Multicoup").value() > 1;

    			if (show_if_4) {
    				if (if_block10) {
    					if_block10.p(ctx, dirty);
    				} else {
    					if_block10 = create_if_block_4$3(ctx);
    					if_block10.c();
    					if_block10.m(div, t13);
    				}
    			} else if (if_block10) {
    				if_block10.d(1);
    				if_block10 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_3 = /*card*/ ctx[0].type == "Cr√©ature" && /*card*/ ctx[0].stat("Maniement").value() > 1;

    			if (show_if_3) {
    				if (if_block11) {
    					if_block11.p(ctx, dirty);
    				} else {
    					if_block11 = create_if_block_3$5(ctx);
    					if_block11.c();
    					if_block11.m(div, t14);
    				}
    			} else if (if_block11) {
    				if_block11.d(1);
    				if_block11 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_2 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Magie").value() > 0;

    			if (show_if_2) {
    				if (if_block12) {
    					if_block12.p(ctx, dirty);
    				} else {
    					if_block12 = create_if_block_2$6(ctx);
    					if_block12.c();
    					if_block12.m(div, t15);
    				}
    			} else if (if_block12) {
    				if_block12.d(1);
    				if_block12 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_1 = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].stat("Intelligence").value() > 0;

    			if (show_if_1) {
    				if (if_block13) {
    					if_block13.p(ctx, dirty);
    				} else {
    					if_block13 = create_if_block_1$a(ctx);
    					if_block13.c();
    					if_block13.m(div, t16);
    				}
    			} else if (if_block13) {
    				if_block13.d(1);
    				if_block13 = null;
    			}

    			if (dirty & /*card*/ 1) show_if = /*card*/ ctx[0].stat("Perp√©tuit√©").current > 0;

    			if (show_if) {
    				if (if_block14) {
    					if_block14.p(ctx, dirty);
    				} else {
    					if_block14 = create_if_block$f(ctx);
    					if_block14.c();
    					if_block14.m(div, null);
    				}
    			} else if (if_block14) {
    				if_block14.d(1);
    				if_block14 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			if (if_block8) if_block8.d();
    			if (if_block9) if_block9.d();
    			if (if_block10) if_block10.d();
    			if (if_block11) if_block11.d();
    			if (if_block12) if_block12.d();
    			if (if_block13) if_block13.d();
    			if (if_block14) if_block14.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Stat', slots, []);
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Stat> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Stat> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ card });

    	$$self.$inject_state = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card];
    }

    class Stat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Stat",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get card() {
    		throw new Error("<Stat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Stat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/View/Trait.svelte generated by Svelte v3.59.2 */

    const file$l = "src/View/Trait.svelte";

    // (9:4) {#if card.trait("L√©gendaire").value()}
    function create_if_block_2$5(ctx) {
    	let t;
    	let br;

    	const block = {
    		c: function create() {
    			t = text("L√©gendaire\n        ");
    			br = element("br");
    			add_location(br, file$l, 10, 8, 159);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, br, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(9:4) {#if card.trait(\\\"L√©gendaire\\\").value()}",
    		ctx
    	});

    	return block;
    }

    // (14:4) {#if card.trait("Rare").value()}
    function create_if_block_1$9(ctx) {
    	let t;
    	let br;

    	const block = {
    		c: function create() {
    			t = text("Rare\n        ");
    			br = element("br");
    			add_location(br, file$l, 15, 8, 235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, br, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(14:4) {#if card.trait(\\\"Rare\\\").value()}",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#if card.isUnit() && card.trait("Inactif").value()}
    function create_if_block$e(ctx) {
    	let t;
    	let br;

    	const block = {
    		c: function create() {
    			t = text("Inactif\n        ");
    			br = element("br");
    			add_location(br, file$l, 20, 8, 334);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, br, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(19:4) {#if card.isUnit() && card.trait(\\\"Inactif\\\").value()}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let i;
    	let t1;
    	let br;
    	let t2;
    	let show_if_2 = /*card*/ ctx[0].trait("L√©gendaire").value();
    	let t3;
    	let show_if_1 = /*card*/ ctx[0].trait("Rare").value();
    	let t4;
    	let show_if = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].trait("Inactif").value();
    	let if_block0 = show_if_2 && create_if_block_2$5(ctx);
    	let if_block1 = show_if_1 && create_if_block_1$9(ctx);
    	let if_block2 = show_if && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			i.textContent = "Traits";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			add_location(i, file$l, 5, 4, 63);
    			add_location(br, file$l, 6, 4, 81);
    			attr_dev(div, "class", "box");
    			add_location(div, file$l, 4, 0, 41);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t3);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t4);
    			if (if_block2) if_block2.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*card*/ 1) show_if_2 = /*card*/ ctx[0].trait("L√©gendaire").value();

    			if (show_if_2) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_2$5(ctx);
    					if_block0.c();
    					if_block0.m(div, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*card*/ 1) show_if_1 = /*card*/ ctx[0].trait("Rare").value();

    			if (show_if_1) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_1$9(ctx);
    					if_block1.c();
    					if_block1.m(div, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*card*/ 1) show_if = /*card*/ ctx[0].isUnit() && /*card*/ ctx[0].trait("Inactif").value();

    			if (show_if) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block$e(ctx);
    					if_block2.c();
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Trait', slots, []);
    	let { card } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (card === undefined && !('card' in $$props || $$self.$$.bound[$$self.$$.props['card']])) {
    			console.warn("<Trait> was created without expected prop 'card'");
    		}
    	});

    	const writable_props = ['card'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Trait> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	$$self.$capture_state = () => ({ card });

    	$$self.$inject_state = $$props => {
    		if ('card' in $$props) $$invalidate(0, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [card];
    }

    class Trait extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { card: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Trait",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get card() {
    		throw new Error("<Trait>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set card(value) {
    		throw new Error("<Trait>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/View/Main.svelte generated by Svelte v3.59.2 */
    const file$k = "src/View/Main.svelte";

    // (19:0) {#if card != undefined}
    function create_if_block$d(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let div0;
    	let button;
    	let t1;
    	let switch_instance0;
    	let t2;
    	let t3;
    	let show_if_1 = /*card*/ ctx[1].hasTrait();
    	let t4;
    	let show_if = /*card*/ ctx[1].hasStat();
    	let t5;
    	let t6;
    	let br;
    	let t7;
    	let switch_instance1;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Caracteristics;

    	function switch_props(ctx) {
    		return {
    			props: { card: /*card*/ ctx[1] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	let if_block0 = /*card*/ ctx[1].text != undefined && create_if_block_4$2(ctx);
    	let if_block1 = show_if_1 && create_if_block_3$4(ctx);
    	let if_block2 = show_if && create_if_block_2$4(ctx);
    	let if_block3 = /*card*/ ctx[1].type == "Cr√©ature" && create_if_block_1$8(ctx);
    	var switch_value_1 = Description;

    	function switch_props_1(ctx) {
    		return {
    			props: { card: /*card*/ ctx[1] },
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			button = element("button");
    			button.textContent = "X";
    			t1 = space();
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			t5 = space();
    			if (if_block3) if_block3.c();
    			t6 = space();
    			br = element("br");
    			t7 = space();
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			attr_dev(button, "class", "close svelte-mce4f6");
    			add_location(button, file$k, 23, 20, 653);
    			set_style(div0, "text-align", "right");
    			add_location(div0, file$k, 22, 16, 601);
    			add_location(br, file$k, 43, 16, 1453);
    			attr_dev(div1, "id", "content");
    			attr_dev(div1, "class", "svelte-mce4f6");
    			add_location(div1, file$k, 21, 12, 566);
    			attr_dev(div2, "id", "body");
    			attr_dev(div2, "class", "svelte-mce4f6");
    			add_location(div2, file$k, 20, 8, 538);
    			attr_dev(div3, "id", "shadow");
    			attr_dev(div3, "class", "svelte-mce4f6");
    			add_location(div3, file$k, 19, 4, 512);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, button);
    			append_dev(div1, t1);
    			if (switch_instance0) mount_component(switch_instance0, div1, null);
    			append_dev(div1, t2);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t3);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t4);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t5);
    			if (if_block3) if_block3.m(div1, null);
    			append_dev(div1, t6);
    			append_dev(div1, br);
    			append_dev(div1, t7);
    			if (switch_instance1) mount_component(switch_instance1, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance0_changes = {};
    			if (dirty & /*card*/ 2) switch_instance0_changes.card = /*card*/ ctx[1];

    			if (switch_value !== (switch_value = Caracteristics)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, div1, t2);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			if (/*card*/ ctx[1].text != undefined) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*card*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t3);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*card*/ 2) show_if_1 = /*card*/ ctx[1].hasTrait();

    			if (show_if_1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*card*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t4);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*card*/ 2) show_if = /*card*/ ctx[1].hasStat();

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*card*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t5);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*card*/ ctx[1].type == "Cr√©ature") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*card*/ 2) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$8(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div1, t6);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*card*/ 2) switch_instance1_changes.card = /*card*/ ctx[1];

    			if (switch_value_1 !== (switch_value_1 = Description)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, div1, null);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (switch_instance0) destroy_component(switch_instance0);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (switch_instance1) destroy_component(switch_instance1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(19:0) {#if card != undefined}",
    		ctx
    	});

    	return block;
    }

    // (32:16) {#if card.text != undefined}
    function create_if_block_4$2(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Effet;

    	function switch_props(ctx) {
    		return {
    			props: { card: /*card*/ ctx[1] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*card*/ 2) switch_instance_changes.card = /*card*/ ctx[1];

    			if (switch_value !== (switch_value = Effet)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(32:16) {#if card.text != undefined}",
    		ctx
    	});

    	return block;
    }

    // (35:16) {#if card.hasTrait()}
    function create_if_block_3$4(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Trait;

    	function switch_props(ctx) {
    		return {
    			props: { card: /*card*/ ctx[1] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*card*/ 2) switch_instance_changes.card = /*card*/ ctx[1];

    			if (switch_value !== (switch_value = Trait)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(35:16) {#if card.hasTrait()}",
    		ctx
    	});

    	return block;
    }

    // (38:16) {#if card.hasStat()}
    function create_if_block_2$4(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Stat;

    	function switch_props(ctx) {
    		return {
    			props: { card: /*card*/ ctx[1] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*card*/ 2) switch_instance_changes.card = /*card*/ ctx[1];

    			if (switch_value !== (switch_value = Stat)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(38:16) {#if card.hasStat()}",
    		ctx
    	});

    	return block;
    }

    // (41:16) {#if card.type == "Cr√©ature"}
    function create_if_block_1$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Equipments;

    	function switch_props(ctx) {
    		return {
    			props: {
    				card: /*card*/ ctx[1],
    				System: /*System*/ ctx[0]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*card*/ 2) switch_instance_changes.card = /*card*/ ctx[1];
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = Equipments)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(41:16) {#if card.type == \\\"Cr√©ature\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*card*/ ctx[1] != undefined && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*card*/ ctx[1] != undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*card*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let card;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Main', slots, []);
    	let { System } = $$props;

    	function close() {
    		$$invalidate(0, System.view.card = undefined, System);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Main> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Main> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		close();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Caracteristics,
    		Description,
    		Effet,
    		Equipments,
    		Stat,
    		Trait,
    		System,
    		close,
    		card
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('card' in $$props) $$invalidate(1, card = $$props.card);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*System*/ 1) {
    			$$invalidate(1, card = System.view.quick == undefined
    			? System.view.card
    			: System.view.quick);
    		}
    	};

    	return [System, card, close, click_handler];
    }

    let Main$1 = class Main extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Main",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get System() {
    		throw new Error("<Main>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Main>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Menu/Library.svelte generated by Svelte v3.59.2 */
    const file$j = "src/Menu/Library.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    // (103:8) {#each cardList as card}
    function create_each_block$8(ctx) {
    	let div;
    	let button;
    	let t0_value = /*card*/ ctx[18].name + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[14](/*card*/ ctx[18]);
    	}

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[15](/*card*/ ctx[18]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$j, 104, 16, 2766);
    			attr_dev(div, "class", "preview");
    			add_location(div, file$j, 103, 12, 2728);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", click_handler_2, false, false, false, false),
    					listen_dev(button, "mouseenter", mouseenter_handler, false, false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[16], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*cardList*/ 128 && t0_value !== (t0_value = /*card*/ ctx[18].name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(103:8) {#each cardList as card}",
    		ctx
    	});

    	return block;
    }

    // (131:0) {#if filterWindow}
    function create_if_block$c(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Filter;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				levelSelect: /*levelSelect*/ ctx[3],
    				typeSelect: /*typeSelect*/ ctx[4],
    				familleSelect: /*familleSelect*/ ctx[5],
    				elementSelect: /*elementSelect*/ ctx[6],
    				sorting: /*sorting*/ ctx[9],
    				close: /*close*/ ctx[10]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*levelSelect*/ 8) switch_instance_changes.levelSelect = /*levelSelect*/ ctx[3];
    			if (dirty & /*typeSelect*/ 16) switch_instance_changes.typeSelect = /*typeSelect*/ ctx[4];
    			if (dirty & /*familleSelect*/ 32) switch_instance_changes.familleSelect = /*familleSelect*/ ctx[5];
    			if (dirty & /*elementSelect*/ 64) switch_instance_changes.elementSelect = /*elementSelect*/ ctx[6];

    			if (switch_value !== (switch_value = Filter)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(131:0) {#if filterWindow}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let button0;
    	let t1;
    	let div3;
    	let div1;
    	let div0;
    	let t2_value = /*System*/ ctx[0].several(/*cardList*/ ctx[7].length, "carte") + "";
    	let t2;
    	let t3;
    	let button1;
    	let t5;
    	let t6;
    	let switch_instance0;
    	let t7;
    	let div2;
    	let t8;
    	let div4;
    	let switch_instance1;
    	let t9;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Dropdown;

    	function switch_props(ctx) {
    		return {
    			props: {
    				array: ["Nom", "Niveau"],
    				selected: /*sortType*/ ctx[2],
    				selecting: /*func*/ ctx[13]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	let each_value = /*cardList*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	var switch_value_1 = Main$1;

    	function switch_props_1(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	let if_block = /*filterWindow*/ ctx[1] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			div3 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = text("\n            -\n            ");
    			button1 = element("button");
    			button1.textContent = "Filtrer";
    			t5 = text("\n            - Trier par");
    			t6 = space();
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t7 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			div4 = element("div");
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			t9 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$j, 69, 0, 1783);
    			add_location(button1, file$j, 81, 12, 2128);
    			set_style(div0, "transform", "translate(0,25%)");
    			set_style(div0, "margin-right", "1%");
    			add_location(div0, file$j, 78, 8, 1989);
    			set_style(div1, "display", "flex");
    			set_style(div1, "margin-bottom", "2%");
    			add_location(div1, file$j, 77, 4, 1936);
    			attr_dev(div2, "id", "list");
    			attr_dev(div2, "class", "scroll svelte-3xw88m");
    			add_location(div2, file$j, 101, 4, 2652);
    			attr_dev(div3, "id", "zone");
    			attr_dev(div3, "class", "svelte-3xw88m");
    			add_location(div3, file$j, 76, 0, 1916);
    			attr_dev(div4, "id", "view");
    			attr_dev(div4, "class", "svelte-3xw88m");
    			add_location(div4, file$j, 126, 0, 3455);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, button1);
    			append_dev(div0, t5);
    			append_dev(div1, t6);
    			if (switch_instance0) mount_component(switch_instance0, div1, null);
    			append_dev(div3, t7);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div2, null);
    				}
    			}

    			insert_dev(target, t8, anchor);
    			insert_dev(target, div4, anchor);
    			if (switch_instance1) mount_component(switch_instance1, div4, null);
    			insert_dev(target, t9, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[11], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[12], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*System, cardList*/ 129) && t2_value !== (t2_value = /*System*/ ctx[0].several(/*cardList*/ ctx[7].length, "carte") + "")) set_data_dev(t2, t2_value);
    			const switch_instance0_changes = {};
    			if (dirty & /*sortType*/ 4) switch_instance0_changes.selected = /*sortType*/ ctx[2];
    			if (dirty & /*sortType*/ 4) switch_instance0_changes.selecting = /*func*/ ctx[13];

    			if (switch_value !== (switch_value = Dropdown)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, div1, null);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			if (dirty & /*System, cardList, undefined*/ 129) {
    				each_value = /*cardList*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*System*/ 1) switch_instance1_changes.System = /*System*/ ctx[0];

    			if (switch_value_1 !== (switch_value_1 = Main$1)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, div4, null);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}

    			if (/*filterWindow*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*filterWindow*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (switch_instance0) destroy_component(switch_instance0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div4);
    			if (switch_instance1) destroy_component(switch_instance1);
    			if (detaching) detach_dev(t9);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Library', slots, []);
    	let { System } = $$props;
    	let filterWindow = false;
    	let sortType = "Nom";
    	let levelSelect = "Tous";
    	let typeSelect = "Tous";
    	let familleSelect = "Toutes";
    	let elementSelect = "Tous";
    	let cardList = [];
    	filter();

    	function filter() {
    		let tab = [];

    		for (const card of System.cards.instance) {
    			if (!card.trait("Rare").value() && (levelSelect == "Tous" || card.level == levelSelect) && (typeSelect == "Tous" || card.type == typeSelect) && (familleSelect == "Toutes" || card.familles.base.includes(familleSelect)) && (elementSelect == "Tous" || card.elements.includes(elementSelect))) {
    				tab.push(card);
    			}
    		}

    		tab = sort(tab);
    		$$invalidate(7, cardList = tab);
    	}

    	function sort(tab) {
    		if (sortType == "Niveau") {
    			for (let i = 0; i < tab.length; i++) {
    				let j = i;

    				while (j > 0 && tab[j].level < tab[j - 1].level) {
    					let swap = tab[j];
    					tab[j] = tab[j - 1];
    					tab[j - 1] = swap;
    					j--;
    				}
    			}
    		}

    		return tab;
    	}

    	function sorting(level, type, famille, element) {
    		$$invalidate(3, levelSelect = level);
    		$$invalidate(4, typeSelect = type);
    		$$invalidate(5, familleSelect = famille);
    		$$invalidate(6, elementSelect = element);
    		filter();
    		close();
    	}

    	function close() {
    		$$invalidate(1, filterWindow = false);
    		System.pages.change("Library");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Library> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Library> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.view.reset();
    		System.pages.change("Menu");
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, filterWindow = true);
    		System.pages.change("Library");
    	};

    	const func = function (element) {
    		$$invalidate(2, sortType = element);
    		filter();
    	};

    	const click_handler_2 = card => {
    		$$invalidate(0, System.view.card = card, System);
    		System.pages.change("Library");
    	};

    	const mouseenter_handler = card => {
    		$$invalidate(0, System.view.quick = card, System);
    		System.pages.change("Library");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Library");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Filter,
    		Dropdown,
    		View: Main$1,
    		System,
    		filterWindow,
    		sortType,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		filter,
    		sort,
    		sorting,
    		close
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('filterWindow' in $$props) $$invalidate(1, filterWindow = $$props.filterWindow);
    		if ('sortType' in $$props) $$invalidate(2, sortType = $$props.sortType);
    		if ('levelSelect' in $$props) $$invalidate(3, levelSelect = $$props.levelSelect);
    		if ('typeSelect' in $$props) $$invalidate(4, typeSelect = $$props.typeSelect);
    		if ('familleSelect' in $$props) $$invalidate(5, familleSelect = $$props.familleSelect);
    		if ('elementSelect' in $$props) $$invalidate(6, elementSelect = $$props.elementSelect);
    		if ('cardList' in $$props) $$invalidate(7, cardList = $$props.cardList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		filterWindow,
    		sortType,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		filter,
    		sorting,
    		close,
    		click_handler,
    		click_handler_1,
    		func,
    		click_handler_2,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class Library extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Library",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get System() {
    		throw new Error("<Library>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Library>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Menu/Profil.svelte generated by Svelte v3.59.2 */

    const file$i = "src/Menu/Profil.svelte";

    // (15:0) {#if name != System.account.name}
    function create_if_block$b(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Renommer";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$i, 15, 4, 275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[4], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(15:0) {#if name != System.account.name}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let button;
    	let t1;
    	let br0;
    	let br1;
    	let t2;
    	let input;
    	let t3;
    	let t4;
    	let br2;
    	let br3;
    	let t5;
    	let t6_value = /*System*/ ctx[0].account.matchs() + "";
    	let t6;
    	let t7;
    	let br4;
    	let t8;
    	let t9_value = /*System*/ ctx[0].account.victory() + "";
    	let t9;
    	let t10;
    	let br5;
    	let t11;
    	let t12_value = /*System*/ ctx[0].account.defeat() + "";
    	let t12;
    	let t13;
    	let br6;
    	let br7;
    	let t14;
    	let t15_value = /*System*/ ctx[0].account.aventure.total() + "";
    	let t15;
    	let t16;
    	let br8;
    	let t17;
    	let t18_value = /*System*/ ctx[0].account.aventure.victory + "";
    	let t18;
    	let t19;
    	let br9;
    	let t20;
    	let t21_value = /*System*/ ctx[0].account.aventure.defeat + "";
    	let t21;
    	let t22;
    	let br10;
    	let br11;
    	let t23;
    	let t24_value = /*System*/ ctx[0].account.construct.total() + "";
    	let t24;
    	let t25;
    	let br12;
    	let t26;
    	let t27_value = /*System*/ ctx[0].account.construct.victory + "";
    	let t27;
    	let t28;
    	let br13;
    	let t29;
    	let t30_value = /*System*/ ctx[0].account.construct.defeat + "";
    	let t30;
    	let mounted;
    	let dispose;
    	let if_block = /*name*/ ctx[1] != /*System*/ ctx[0].account.name && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "X";
    			t1 = space();
    			br0 = element("br");
    			br1 = element("br");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			br2 = element("br");
    			br3 = element("br");
    			t5 = text("\n\nTotal des parties : ");
    			t6 = text(t6_value);
    			t7 = space();
    			br4 = element("br");
    			t8 = text("\nVictoires : ");
    			t9 = text(t9_value);
    			t10 = space();
    			br5 = element("br");
    			t11 = text("\nD√©faites : ");
    			t12 = text(t12_value);
    			t13 = space();
    			br6 = element("br");
    			br7 = element("br");
    			t14 = text("\n\nMode aventure : ");
    			t15 = text(t15_value);
    			t16 = space();
    			br8 = element("br");
    			t17 = text("\nVictoires : ");
    			t18 = text(t18_value);
    			t19 = space();
    			br9 = element("br");
    			t20 = text("\nD√©faites : ");
    			t21 = text(t21_value);
    			t22 = space();
    			br10 = element("br");
    			br11 = element("br");
    			t23 = text("\n\nMode construit : ");
    			t24 = text(t24_value);
    			t25 = space();
    			br12 = element("br");
    			t26 = text("\nVictoires : ");
    			t27 = text(t27_value);
    			t28 = space();
    			br13 = element("br");
    			t29 = text("\nD√©faites : ");
    			t30 = text(t30_value);
    			attr_dev(button, "class", "close");
    			add_location(button, file$i, 6, 0, 80);
    			add_location(br0, file$i, 12, 0, 184);
    			add_location(br1, file$i, 12, 6, 190);
    			attr_dev(input, "type", "text");
    			add_location(input, file$i, 13, 0, 197);
    			add_location(br2, file$i, 24, 0, 457);
    			add_location(br3, file$i, 24, 6, 463);
    			add_location(br4, file$i, 27, 0, 517);
    			add_location(br5, file$i, 29, 0, 563);
    			add_location(br6, file$i, 32, 0, 608);
    			add_location(br7, file$i, 32, 6, 614);
    			add_location(br8, file$i, 35, 0, 672);
    			add_location(br9, file$i, 37, 0, 725);
    			add_location(br10, file$i, 40, 0, 777);
    			add_location(br11, file$i, 40, 6, 783);
    			add_location(br12, file$i, 43, 0, 843);
    			add_location(br13, file$i, 45, 0, 897);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br0, anchor);
    			insert_dev(target, br1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*name*/ ctx[1]);
    			insert_dev(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, br2, anchor);
    			insert_dev(target, br3, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, br4, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, br5, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, br6, anchor);
    			insert_dev(target, br7, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, br8, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, t18, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, br9, anchor);
    			insert_dev(target, t20, anchor);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, br10, anchor);
    			insert_dev(target, br11, anchor);
    			insert_dev(target, t23, anchor);
    			insert_dev(target, t24, anchor);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, br12, anchor);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, t27, anchor);
    			insert_dev(target, t28, anchor);
    			insert_dev(target, br13, anchor);
    			insert_dev(target, t29, anchor);
    			insert_dev(target, t30, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[3])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name*/ 2 && input.value !== /*name*/ ctx[1]) {
    				set_input_value(input, /*name*/ ctx[1]);
    			}

    			if (/*name*/ ctx[1] != /*System*/ ctx[0].account.name) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(t4.parentNode, t4);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*System*/ 1 && t6_value !== (t6_value = /*System*/ ctx[0].account.matchs() + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*System*/ 1 && t9_value !== (t9_value = /*System*/ ctx[0].account.victory() + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*System*/ 1 && t12_value !== (t12_value = /*System*/ ctx[0].account.defeat() + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*System*/ 1 && t15_value !== (t15_value = /*System*/ ctx[0].account.aventure.total() + "")) set_data_dev(t15, t15_value);
    			if (dirty & /*System*/ 1 && t18_value !== (t18_value = /*System*/ ctx[0].account.aventure.victory + "")) set_data_dev(t18, t18_value);
    			if (dirty & /*System*/ 1 && t21_value !== (t21_value = /*System*/ ctx[0].account.aventure.defeat + "")) set_data_dev(t21, t21_value);
    			if (dirty & /*System*/ 1 && t24_value !== (t24_value = /*System*/ ctx[0].account.construct.total() + "")) set_data_dev(t24, t24_value);
    			if (dirty & /*System*/ 1 && t27_value !== (t27_value = /*System*/ ctx[0].account.construct.victory + "")) set_data_dev(t27, t27_value);
    			if (dirty & /*System*/ 1 && t30_value !== (t30_value = /*System*/ ctx[0].account.construct.defeat + "")) set_data_dev(t30, t30_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br0);
    			if (detaching) detach_dev(br1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t3);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(br2);
    			if (detaching) detach_dev(br3);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(br4);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(br5);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(br6);
    			if (detaching) detach_dev(br7);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(br8);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(t18);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(br9);
    			if (detaching) detach_dev(t20);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(br10);
    			if (detaching) detach_dev(br11);
    			if (detaching) detach_dev(t23);
    			if (detaching) detach_dev(t24);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(br12);
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(t27);
    			if (detaching) detach_dev(t28);
    			if (detaching) detach_dev(br13);
    			if (detaching) detach_dev(t29);
    			if (detaching) detach_dev(t30);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Profil', slots, []);
    	let { System } = $$props;
    	let name = System.account.name;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Profil> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Profil> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("Menu");
    	};

    	function input_input_handler() {
    		name = this.value;
    		$$invalidate(1, name);
    	}

    	const click_handler_1 = () => {
    		$$invalidate(0, System.account.name = name, System);
    		System.pages.change("Profil");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, name });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('name' in $$props) $$invalidate(1, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, name, click_handler, input_input_handler, click_handler_1];
    }

    class Profil extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Profil",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get System() {
    		throw new Error("<Profil>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Profil>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Training/Entity.svelte generated by Svelte v3.59.2 */

    const file$h = "src/Training/Entity.svelte";

    function create_fragment$h(ctx) {
    	let div9;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let input0;
    	let t2;
    	let div5;
    	let div3;
    	let t4;
    	let div4;
    	let input1;
    	let t5;
    	let div8;
    	let div6;
    	let t7;
    	let div7;
    	let input2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "Vie :";
    			t1 = space();
    			div1 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div5 = element("div");
    			div3 = element("div");
    			div3.textContent = "Or :";
    			t4 = space();
    			div4 = element("div");
    			input1 = element("input");
    			t5 = space();
    			div8 = element("div");
    			div6 = element("div");
    			div6.textContent = "Flux :";
    			t7 = space();
    			div7 = element("div");
    			input2 = element("input");
    			add_location(div0, file$h, 10, 8, 183);
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "min", "1");
    			attr_dev(input0, "class", "svelte-fzntc3");
    			add_location(input0, file$h, 14, 12, 248);
    			add_location(div1, file$h, 13, 8, 230);
    			attr_dev(div2, "class", "container svelte-fzntc3");
    			add_location(div2, file$h, 9, 4, 151);
    			add_location(div3, file$h, 30, 8, 659);
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "min", "0");
    			attr_dev(input1, "class", "svelte-fzntc3");
    			add_location(input1, file$h, 34, 12, 723);
    			add_location(div4, file$h, 33, 8, 705);
    			attr_dev(div5, "class", "container svelte-fzntc3");
    			add_location(div5, file$h, 29, 4, 627);
    			add_location(div6, file$h, 50, 8, 1134);
    			attr_dev(input2, "type", "number");
    			attr_dev(input2, "min", "0");
    			attr_dev(input2, "class", "svelte-fzntc3");
    			add_location(input2, file$h, 54, 12, 1200);
    			add_location(div7, file$h, 53, 8, 1182);
    			attr_dev(div8, "class", "container svelte-fzntc3");
    			add_location(div8, file$h, 49, 4, 1102);
    			attr_dev(div9, "class", "zone svelte-fzntc3");
    			add_location(div9, file$h, 8, 0, 128);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, input0);
    			set_input_value(input0, /*life*/ ctx[1]);
    			append_dev(div9, t2);
    			append_dev(div9, div5);
    			append_dev(div5, div3);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			append_dev(div4, input1);
    			set_input_value(input1, /*gold*/ ctx[2]);
    			append_dev(div9, t5);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			append_dev(div8, t7);
    			append_dev(div8, div7);
    			append_dev(div7, input2);
    			set_input_value(input2, /*flux*/ ctx[3]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[4]),
    					listen_dev(input0, "change", /*change_handler*/ ctx[5], false, false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[6]),
    					listen_dev(input1, "change", /*change_handler_1*/ ctx[7], false, false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[8]),
    					listen_dev(input2, "change", /*change_handler_2*/ ctx[9], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*life*/ 2 && to_number(input0.value) !== /*life*/ ctx[1]) {
    				set_input_value(input0, /*life*/ ctx[1]);
    			}

    			if (dirty & /*gold*/ 4 && to_number(input1.value) !== /*gold*/ ctx[2]) {
    				set_input_value(input1, /*gold*/ ctx[2]);
    			}

    			if (dirty & /*flux*/ 8 && to_number(input2.value) !== /*flux*/ ctx[3]) {
    				set_input_value(input2, /*flux*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Entity', slots, []);
    	let { entity } = $$props;
    	let life = entity.life;
    	let gold = entity.gold;
    	let flux = entity.flux;

    	$$self.$$.on_mount.push(function () {
    		if (entity === undefined && !('entity' in $$props || $$self.$$.bound[$$self.$$.props['entity']])) {
    			console.warn("<Entity> was created without expected prop 'entity'");
    		}
    	});

    	const writable_props = ['entity'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Entity> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		life = to_number(this.value);
    		$$invalidate(1, life);
    	}

    	const change_handler = () => {
    		if (life < 1) {
    			$$invalidate(1, life = 1);
    		} else {
    			$$invalidate(0, entity.life = life, entity);
    		}
    	};

    	function input1_input_handler() {
    		gold = to_number(this.value);
    		$$invalidate(2, gold);
    	}

    	const change_handler_1 = () => {
    		if (gold < 1) {
    			$$invalidate(2, gold = 1);
    		} else {
    			$$invalidate(0, entity.gold = gold, entity);
    		}
    	};

    	function input2_input_handler() {
    		flux = to_number(this.value);
    		$$invalidate(3, flux);
    	}

    	const change_handler_2 = () => {
    		if (flux < 1) {
    			$$invalidate(3, flux = 1);
    		} else {
    			$$invalidate(0, entity.flux = flux, entity);
    		}
    	};

    	$$self.$$set = $$props => {
    		if ('entity' in $$props) $$invalidate(0, entity = $$props.entity);
    	};

    	$$self.$capture_state = () => ({ entity, life, gold, flux });

    	$$self.$inject_state = $$props => {
    		if ('entity' in $$props) $$invalidate(0, entity = $$props.entity);
    		if ('life' in $$props) $$invalidate(1, life = $$props.life);
    		if ('gold' in $$props) $$invalidate(2, gold = $$props.gold);
    		if ('flux' in $$props) $$invalidate(3, flux = $$props.flux);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		entity,
    		life,
    		gold,
    		flux,
    		input0_input_handler,
    		change_handler,
    		input1_input_handler,
    		change_handler_1,
    		input2_input_handler,
    		change_handler_2
    	];
    }

    let Entity$1 = class Entity extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { entity: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Entity",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get entity() {
    		throw new Error("<Entity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set entity(value) {
    		throw new Error("<Entity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Training/Zone.svelte generated by Svelte v3.59.2 */

    const file$g = "src/Training/Zone.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    // (11:4) {#if zone.name == "Boutique"}
    function create_if_block_3$3(ctx) {
    	let t;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t = text("Nv\n        ");
    			input = element("input");
    			attr_dev(input, "type", "number");
    			attr_dev(input, "min", "1");
    			attr_dev(input, "max", "20");
    			add_location(input, file$g, 12, 8, 204);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*level*/ ctx[3]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[4]),
    					listen_dev(input, "change", /*change_handler*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*level*/ 8 && to_number(input.value) !== /*level*/ ctx[3]) {
    				set_input_value(input, /*level*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(11:4) {#if zone.name == \\\"Boutique\\\"}",
    		ctx
    	});

    	return block;
    }

    // (74:12) {:else}
    function create_else_block$4(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let button;
    	let t1_value = /*card*/ ctx[15] + "";
    	let t1;
    	let mounted;
    	let dispose;
    	let if_block = (/*zone*/ ctx[1].name != "Lieux" || /*zone*/ ctx[1].cards.length > 1) && create_if_block_2$3(ctx);

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[12](/*card*/ ctx[15]);
    	}

    	function mouseenter_handler_1() {
    		return /*mouseenter_handler_1*/ ctx[13](/*card*/ ctx[15]);
    	}

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div1 = element("div");
    			button = element("button");
    			t1 = text(t1_value);
    			add_location(div0, file$g, 74, 16, 2306);
    			attr_dev(button, "class", "classic");
    			add_location(button, file$g, 86, 20, 2818);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$g, 85, 16, 2766);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if (if_block) if_block.m(div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", click_handler_4, false, false, false, false),
    					listen_dev(button, "mouseenter", mouseenter_handler_1, false, false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler_1*/ ctx[14], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*zone*/ ctx[1].name != "Lieux" || /*zone*/ ctx[1].cards.length > 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$3(ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zone*/ 2 && t1_value !== (t1_value = /*card*/ ctx[15] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(74:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:12) {#if entity == "player"}
    function create_if_block$a(ctx) {
    	let div0;
    	let button;
    	let t0_value = /*card*/ ctx[15] + "";
    	let t0;
    	let t1;
    	let div1;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[7](/*card*/ ctx[15]);
    	}

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[8](/*card*/ ctx[15]);
    	}

    	let if_block = (/*zone*/ ctx[1].name != "Lieux" || /*zone*/ ctx[1].cards.length > 1) && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$g, 46, 20, 1062);
    			add_location(div0, file$g, 45, 16, 1036);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$g, 62, 16, 1800);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button);
    			append_dev(button, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			if (if_block) if_block.m(div1, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", click_handler_1, false, false, false, false),
    					listen_dev(button, "mouseenter", mouseenter_handler, false, false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[9], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*zone*/ 2 && t0_value !== (t0_value = /*card*/ ctx[15] + "")) set_data_dev(t0, t0_value);

    			if (/*zone*/ ctx[1].name != "Lieux" || /*zone*/ ctx[1].cards.length > 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(45:12) {#if entity == \\\"player\\\"}",
    		ctx
    	});

    	return block;
    }

    // (76:20) {#if zone.name != "Lieux" || zone.cards.length > 1}
    function create_if_block_2$3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[11](/*i*/ ctx[17]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Enlever";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$g, 76, 24, 2408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_3, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(76:20) {#if zone.name != \\\"Lieux\\\" || zone.cards.length > 1}",
    		ctx
    	});

    	return block;
    }

    // (64:20) {#if zone.name != "Lieux" || zone.cards.length > 1}
    function create_if_block_1$7(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[10](/*i*/ ctx[17]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Enlever";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$g, 64, 24, 1928);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_2, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(64:20) {#if zone.name != \\\"Lieux\\\" || zone.cards.length > 1}",
    		ctx
    	});

    	return block;
    }

    // (43:4) {#each zone.cards as card, i}
    function create_each_block$7(ctx) {
    	let div;
    	let t;

    	function select_block_type(ctx, dirty) {
    		if (/*entity*/ ctx[2] == "player") return create_if_block$a;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			t = space();
    			attr_dev(div, "class", "preview svelte-1d79swz");
    			add_location(div, file$g, 43, 8, 961);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(43:4) {#each zone.cards as card, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div;
    	let t0_value = /*zone*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let t2;
    	let button;
    	let t4;
    	let mounted;
    	let dispose;
    	let if_block = /*zone*/ ctx[1].name == "Boutique" && create_if_block_3$3(ctx);
    	let each_value = /*zone*/ ctx[1].cards;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = text("\n    -\n    ");
    			button = element("button");
    			button.textContent = "Ajouter une carte";
    			t4 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(button, "class", "classic");
    			add_location(button, file$g, 31, 4, 638);
    			attr_dev(div, "class", "zone svelte-1d79swz");
    			add_location(div, file$g, 8, 0, 116);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t2);
    			append_dev(div, button);
    			append_dev(div, t4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[6], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*zone*/ 2 && t0_value !== (t0_value = /*zone*/ ctx[1].name + "")) set_data_dev(t0, t0_value);

    			if (/*zone*/ ctx[1].name == "Boutique") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$3(ctx);
    					if_block.c();
    					if_block.m(div, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zone, System, undefined, entity*/ 7) {
    				each_value = /*zone*/ ctx[1].cards;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Zone', slots, []);
    	let { System } = $$props;
    	let { zone } = $$props;
    	let { entity } = $$props;
    	let level = zone.level;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Zone> was created without expected prop 'System'");
    		}

    		if (zone === undefined && !('zone' in $$props || $$self.$$.bound[$$self.$$.props['zone']])) {
    			console.warn("<Zone> was created without expected prop 'zone'");
    		}

    		if (entity === undefined && !('entity' in $$props || $$self.$$.bound[$$self.$$.props['entity']])) {
    			console.warn("<Zone> was created without expected prop 'entity'");
    		}
    	});

    	const writable_props = ['System', 'zone', 'entity'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Zone> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		level = to_number(this.value);
    		$$invalidate(3, level);
    	}

    	const change_handler = () => {
    		if (level < 1) {
    			$$invalidate(3, level = 1);
    		} else if (level > 20) {
    			$$invalidate(3, level = 20);
    		} else {
    			$$invalidate(1, zone.level = level, zone);
    		}
    	};

    	const click_handler = () => {
    		System.view.reset();
    		$$invalidate(0, System.train.add.entity = entity, System);
    		$$invalidate(0, System.train.add.zone = zone, System);
    		System.pages.change("Training");
    	};

    	const click_handler_1 = card => {
    		$$invalidate(0, System.view.card = System.cards.getByName(card), System);
    		System.pages.change("Training");
    	};

    	const mouseenter_handler = card => {
    		$$invalidate(0, System.view.quick = System.cards.getByName(card), System);
    		System.pages.change("Training");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Training");
    	};

    	const click_handler_2 = i => {
    		zone.cards.splice(i, 1);
    		System.pages.change("Training");
    	};

    	const click_handler_3 = i => {
    		zone.cards.splice(i, 1);
    		System.pages.change("Training");
    	};

    	const click_handler_4 = card => {
    		$$invalidate(0, System.view.card = System.cards.getByName(card), System);
    		System.pages.change("Training");
    	};

    	const mouseenter_handler_1 = card => {
    		$$invalidate(0, System.view.quick = System.cards.getByName(card), System);
    		System.pages.change("Training");
    	};

    	const mouseleave_handler_1 = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Training");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('zone' in $$props) $$invalidate(1, zone = $$props.zone);
    		if ('entity' in $$props) $$invalidate(2, entity = $$props.entity);
    	};

    	$$self.$capture_state = () => ({ System, zone, entity, level });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('zone' in $$props) $$invalidate(1, zone = $$props.zone);
    		if ('entity' in $$props) $$invalidate(2, entity = $$props.entity);
    		if ('level' in $$props) $$invalidate(3, level = $$props.level);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		zone,
    		entity,
    		level,
    		input_input_handler,
    		change_handler,
    		click_handler,
    		click_handler_1,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		mouseenter_handler_1,
    		mouseleave_handler_1
    	];
    }

    class Zone extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { System: 0, zone: 1, entity: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Zone",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get System() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zone() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zone(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get entity() {
    		throw new Error("<Zone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set entity(value) {
    		throw new Error("<Zone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Training/Add.svelte generated by Svelte v3.59.2 */
    const file$f = "src/Training/Add.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (59:0) {#if System.train.add.zone != undefined}
    function create_if_block_1$6(ctx) {
    	let t0_value = /*filter*/ ctx[8]() + "";
    	let t0;
    	let t1;
    	let div2;
    	let button0;
    	let t3;
    	let div1;
    	let t4_value = /*System*/ ctx[0].several(/*cardList*/ ctx[6].length, "carte") + "";
    	let t4;
    	let t5;
    	let button1;
    	let t7;
    	let div0;
    	let t8;
    	let div3;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*cardList*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	var switch_value = Main$1;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "X";
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = text("\n            -\n            ");
    			button1 = element("button");
    			button1.textContent = "Filtrer";
    			t7 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			div3 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$f, 61, 8, 1841);
    			attr_dev(button1, "class", "classic");
    			add_location(button1, file$f, 70, 12, 2070);
    			attr_dev(div0, "id", "list");
    			attr_dev(div0, "class", "scroll svelte-1f1h7wy");
    			add_location(div0, file$f, 79, 12, 2329);
    			attr_dev(div1, "id", "side");
    			attr_dev(div1, "class", "svelte-1f1h7wy");
    			add_location(div1, file$f, 67, 8, 1973);
    			attr_dev(div2, "id", "body");
    			attr_dev(div2, "class", "svelte-1f1h7wy");
    			add_location(div2, file$f, 60, 4, 1817);
    			attr_dev(div3, "id", "view");
    			attr_dev(div3, "class", "svelte-1f1h7wy");
    			add_location(div3, file$f, 113, 4, 3784);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, button1);
    			append_dev(div1, t7);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			insert_dev(target, t8, anchor);
    			insert_dev(target, div3, anchor);
    			if (switch_instance) mount_component(switch_instance, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[11], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[12], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*System, cardList*/ 65) && t4_value !== (t4_value = /*System*/ ctx[0].several(/*cardList*/ ctx[6].length, "carte") + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*System, cardList, undefined*/ 65) {
    				each_value = /*cardList*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = Main$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div3, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div3);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(59:0) {#if System.train.add.zone != undefined}",
    		ctx
    	});

    	return block;
    }

    // (81:16) {#each cardList as card}
    function create_each_block$6(ctx) {
    	let div2;
    	let div0;
    	let button0;
    	let t0_value = /*card*/ ctx[17].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let button1;
    	let t3;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[13](/*card*/ ctx[17]);
    	}

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[14](/*card*/ ctx[17]);
    	}

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[16](/*card*/ ctx[17]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Ajouter";
    			t3 = space();
    			attr_dev(button0, "class", "classic");
    			add_location(button0, file$f, 83, 28, 2501);
    			add_location(div0, file$f, 82, 24, 2467);
    			attr_dev(button1, "class", "classic");
    			add_location(button1, file$f, 100, 28, 3384);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$f, 99, 24, 3324);
    			attr_dev(div2, "class", "preview svelte-1f1h7wy");
    			add_location(div2, file$f, 81, 20, 2421);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			append_dev(button0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, button1);
    			append_dev(div2, t3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", click_handler_2, false, false, false, false),
    					listen_dev(button0, "mouseenter", mouseenter_handler, false, false, false, false),
    					listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[15], false, false, false, false),
    					listen_dev(button1, "click", click_handler_3, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*cardList*/ 64 && t0_value !== (t0_value = /*card*/ ctx[17].name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(81:16) {#each cardList as card}",
    		ctx
    	});

    	return block;
    }

    // (119:0) {#if filterWindow}
    function create_if_block$9(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Filter;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				levelSelect: /*levelSelect*/ ctx[2],
    				typeSelect: /*typeSelect*/ ctx[3],
    				familleSelect: /*familleSelect*/ ctx[4],
    				elementSelect: /*elementSelect*/ ctx[5],
    				sorting: /*sorting*/ ctx[9],
    				close: /*closing*/ ctx[10]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*levelSelect*/ 4) switch_instance_changes.levelSelect = /*levelSelect*/ ctx[2];
    			if (dirty & /*typeSelect*/ 8) switch_instance_changes.typeSelect = /*typeSelect*/ ctx[3];
    			if (dirty & /*familleSelect*/ 16) switch_instance_changes.familleSelect = /*familleSelect*/ ctx[4];
    			if (dirty & /*elementSelect*/ 32) switch_instance_changes.elementSelect = /*elementSelect*/ ctx[5];

    			if (switch_value !== (switch_value = Filter)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(119:0) {#if filterWindow}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*System*/ ctx[0].train.add.zone != undefined && create_if_block_1$6(ctx);
    	let if_block1 = /*filterWindow*/ ctx[1] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*System*/ ctx[0].train.add.zone != undefined) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*System*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*filterWindow*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*filterWindow*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Add', slots, []);
    	let { System } = $$props;

    	function close() {
    		$$invalidate(1, filterWindow = false);
    		System.view.reset();
    		System.train.add.reset();
    		System.pages.change("Training");
    	}

    	let filterWindow = false;
    	let levelSelect = "Tous";
    	let typeSelect = "Tous";
    	let familleSelect = "Toutes";
    	let elementSelect = "Tous";
    	let cardList = [];

    	function filter() {
    		let tab = [];

    		for (const card of System.cards.instance) {
    			if (!card.trait("Rare").value() && (!card.trait("L√©gendaire").value() || System.train.add.entity == "bot") && (levelSelect == "Tous" || card.level == levelSelect) && (typeSelect == "Tous" || card.type == typeSelect) && (card.type == "Lieu" || System.train.add.zone != undefined && System.train.add.zone.name != "Lieux") && (card.isUnit() || System.train.add.zone != undefined && System.train.add.zone.name != "Terrain") && (familleSelect == "Toutes" || card.familles.base.includes(familleSelect)) && (elementSelect == "Tous" || card.elements.includes(elementSelect))) {
    				tab.push(card);
    			}
    		}

    		$$invalidate(6, cardList = tab);
    		return "";
    	}

    	function sorting(level, type, famille, element) {
    		$$invalidate(2, levelSelect = level);
    		$$invalidate(3, typeSelect = type);
    		$$invalidate(4, familleSelect = famille);
    		$$invalidate(5, elementSelect = element);
    		filter();
    		closing();
    	}

    	function closing() {
    		$$invalidate(1, filterWindow = false);
    		System.pages.change("Training");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Add> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Add> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		close();
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, filterWindow = true);
    		System.pages.change("Training");
    	};

    	const click_handler_2 = card => {
    		$$invalidate(0, System.view.card = card, System);
    		System.pages.change("Training");
    	};

    	const mouseenter_handler = card => {
    		$$invalidate(0, System.view.quick = card, System);
    		System.pages.change("Training");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Training");
    	};

    	const click_handler_3 = card => {
    		System.train.add.zone.cards.push(card.name);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		View: Main$1,
    		Filter,
    		System,
    		close,
    		filterWindow,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		filter,
    		sorting,
    		closing
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('filterWindow' in $$props) $$invalidate(1, filterWindow = $$props.filterWindow);
    		if ('levelSelect' in $$props) $$invalidate(2, levelSelect = $$props.levelSelect);
    		if ('typeSelect' in $$props) $$invalidate(3, typeSelect = $$props.typeSelect);
    		if ('familleSelect' in $$props) $$invalidate(4, familleSelect = $$props.familleSelect);
    		if ('elementSelect' in $$props) $$invalidate(5, elementSelect = $$props.elementSelect);
    		if ('cardList' in $$props) $$invalidate(6, cardList = $$props.cardList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		filterWindow,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		close,
    		filter,
    		sorting,
    		closing,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_3
    	];
    }

    let Add$1 = class Add extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Add",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get System() {
    		throw new Error("<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* src/Training/Main.svelte generated by Svelte v3.59.2 */
    const file$e = "src/Training/Main.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (36:4) {#each System.train.bot.zones as zone, i}
    function create_each_block$5(ctx) {
    	let div;
    	let switch_instance0;
    	let t0;
    	let switch_instance1;
    	let t1;
    	let current;
    	var switch_value = Zone;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: "player",
    				zone: /*System*/ ctx[0].train.player.zones[/*i*/ ctx[5]]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	var switch_value_1 = Zone;

    	function switch_props_1(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: "bot",
    				zone: /*zone*/ ctx[3]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t0 = space();
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			t1 = space();
    			attr_dev(div, "class", "bi-zone svelte-1qwkybe");
    			add_location(div, file$e, 36, 8, 1027);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (switch_instance0) mount_component(switch_instance0, div, null);
    			append_dev(div, t0);
    			if (switch_instance1) mount_component(switch_instance1, div, null);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance0_changes = {};
    			if (dirty & /*System*/ 1) switch_instance0_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance0_changes.zone = /*System*/ ctx[0].train.player.zones[/*i*/ ctx[5]];

    			if (switch_value !== (switch_value = Zone)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, div, t0);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*System*/ 1) switch_instance1_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance1_changes.zone = /*zone*/ ctx[3];

    			if (switch_value_1 !== (switch_value_1 = Zone)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, div, t1);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance0) destroy_component(switch_instance0);
    			if (switch_instance1) destroy_component(switch_instance1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(36:4) {#each System.train.bot.zones as zone, i}",
    		ctx
    	});

    	return block;
    }

    // (46:0) {#if System.train.add.zone == undefined}
    function create_if_block$8(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	var switch_value = Main$1;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "center");
    			add_location(div, file$e, 46, 4, 1349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (switch_instance) mount_component(switch_instance, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = Main$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(46:0) {#if System.train.add.zone == undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div1;
    	let button0;
    	let t1;
    	let div0;
    	let button1;
    	let t3;
    	let div3;
    	let div2;
    	let switch_instance0;
    	let t4;
    	let switch_instance1;
    	let t5;
    	let t6;
    	let switch_instance2;
    	let t7;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = Entity$1;

    	function switch_props(ctx) {
    		return {
    			props: { entity: /*System*/ ctx[0].train.player },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	var switch_value_1 = Entity$1;

    	function switch_props_1(ctx) {
    		return {
    			props: { entity: /*System*/ ctx[0].train.bot },
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	let each_value = /*System*/ ctx[0].train.bot.zones;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	var switch_value_2 = Add$1;

    	function switch_props_2(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value_2) {
    		switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    	}

    	let if_block = /*System*/ ctx[0].train.add.zone == undefined && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			div0 = element("div");
    			button1 = element("button");
    			button1.textContent = "Jouer";
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t4 = space();
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			if (switch_instance2) create_component(switch_instance2.$$.fragment);
    			t7 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$e, 10, 4, 252);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$e, 18, 8, 453);
    			set_style(div0, "text-align", "center");
    			add_location(div0, file$e, 17, 4, 413);
    			add_location(div1, file$e, 9, 0, 242);
    			attr_dev(div2, "class", "bi-zone svelte-1qwkybe");
    			add_location(div2, file$e, 31, 4, 799);
    			attr_dev(div3, "id", "body");
    			attr_dev(div3, "class", "scroll svelte-1qwkybe");
    			add_location(div3, file$e, 30, 0, 764);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, button1);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			if (switch_instance0) mount_component(switch_instance0, div2, null);
    			append_dev(div2, t4);
    			if (switch_instance1) mount_component(switch_instance1, div2, null);
    			append_dev(div3, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div3, null);
    				}
    			}

    			insert_dev(target, t6, anchor);
    			if (switch_instance2) mount_component(switch_instance2, target, anchor);
    			insert_dev(target, t7, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance0_changes = {};
    			if (dirty & /*System*/ 1) switch_instance0_changes.entity = /*System*/ ctx[0].train.player;

    			if (switch_value !== (switch_value = Entity$1)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, div2, t4);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*System*/ 1) switch_instance1_changes.entity = /*System*/ ctx[0].train.bot;

    			if (switch_value_1 !== (switch_value_1 = Entity$1)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, div2, null);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}

    			if (dirty & /*Zone, System*/ 1) {
    				each_value = /*System*/ ctx[0].train.bot.zones;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const switch_instance2_changes = {};
    			if (dirty & /*System*/ 1) switch_instance2_changes.System = /*System*/ ctx[0];

    			if (switch_value_2 !== (switch_value_2 = Add$1)) {
    				if (switch_instance2) {
    					group_outros();
    					const old_component = switch_instance2;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_2) {
    					switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    					create_component(switch_instance2.$$.fragment);
    					transition_in(switch_instance2.$$.fragment, 1);
    					mount_component(switch_instance2, t7.parentNode, t7);
    				} else {
    					switch_instance2 = null;
    				}
    			} else if (switch_value_2) {
    				switch_instance2.$set(switch_instance2_changes);
    			}

    			if (/*System*/ ctx[0].train.add.zone == undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*System*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			if (switch_instance2) transition_in(switch_instance2.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (switch_instance2) transition_out(switch_instance2.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div3);
    			if (switch_instance0) destroy_component(switch_instance0);
    			if (switch_instance1) destroy_component(switch_instance1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t6);
    			if (switch_instance2) destroy_component(switch_instance2, detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Main', slots, []);
    	let { System } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Main> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Main> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.view.reset();
    		System.pages.change("Play");
    	};

    	const click_handler_1 = () => {
    		System.view.reset();
    		$$invalidate(0, System.game = new Game$1(System, "Entra√Ænement"), System);
    		$$invalidate(0, System.game.deck = System.train.deck, System);
    		System.game.init();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Entity: Entity$1, Zone, Add: Add$1, View: Main$1, Game: Game$1, System });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, click_handler, click_handler_1];
    }

    class Main extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Main",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get System() {
    		throw new Error("<Main>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Main>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Zone2.svelte generated by Svelte v3.59.2 */
    const file$d = "src/Zone2.svelte";

    function create_fragment$d(ctx) {
    	let div1;
    	let switch_instance0;
    	let t;
    	let div0;
    	let switch_instance1;
    	let current;
    	var switch_value = Zone$1;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.player,
    				zone: /*System*/ ctx[0].game.player.zone(/*zone*/ ctx[1]),
    				condition: undefined,
    				fonction: undefined
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	var switch_value_1 = Zone$1;

    	function switch_props_1(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.bot,
    				zone: /*System*/ ctx[0].game.bot.zone(/*zone*/ ctx[1]),
    				condition: undefined,
    				fonction: undefined
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t = space();
    			div0 = element("div");
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			set_style(div0, "text-align", "right");
    			add_location(div0, file$d, 15, 4, 332);
    			attr_dev(div1, "class", "zones svelte-16cbsky");
    			add_location(div1, file$d, 6, 0, 102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (switch_instance0) mount_component(switch_instance0, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			if (switch_instance1) mount_component(switch_instance1, div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance0_changes = {};
    			if (dirty & /*System*/ 1) switch_instance0_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance0_changes.entity = /*System*/ ctx[0].game.player;
    			if (dirty & /*System, zone*/ 3) switch_instance0_changes.zone = /*System*/ ctx[0].game.player.zone(/*zone*/ ctx[1]);

    			if (switch_value !== (switch_value = Zone$1)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, div1, t);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*System*/ 1) switch_instance1_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance1_changes.entity = /*System*/ ctx[0].game.bot;
    			if (dirty & /*System, zone*/ 3) switch_instance1_changes.zone = /*System*/ ctx[0].game.bot.zone(/*zone*/ ctx[1]);

    			if (switch_value_1 !== (switch_value_1 = Zone$1)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, div0, null);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (switch_instance0) destroy_component(switch_instance0);
    			if (switch_instance1) destroy_component(switch_instance1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Zone2', slots, []);
    	let { System } = $$props;
    	let { zone } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Zone2> was created without expected prop 'System'");
    		}

    		if (zone === undefined && !('zone' in $$props || $$self.$$.bound[$$self.$$.props['zone']])) {
    			console.warn("<Zone2> was created without expected prop 'zone'");
    		}
    	});

    	const writable_props = ['System', 'zone'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Zone2> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('zone' in $$props) $$invalidate(1, zone = $$props.zone);
    	};

    	$$self.$capture_state = () => ({ Zone: Zone$1, System, zone });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('zone' in $$props) $$invalidate(1, zone = $$props.zone);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, zone];
    }

    class Zone2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { System: 0, zone: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Zone2",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get System() {
    		throw new Error("<Zone2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Zone2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zone() {
    		throw new Error("<Zone2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zone(value) {
    		throw new Error("<Zone2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Entity.svelte generated by Svelte v3.59.2 */

    const file$c = "src/Entity.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (9:4) {#if System.game.phase == "Pr√©paration"}
    function create_if_block$7(ctx) {
    	let t;
    	let if_block_anchor;
    	let each_value = /*entity*/ ctx[1].ressources;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	let if_block = /*entity*/ ctx[1] == /*System*/ ctx[0].game.player && /*entity*/ ctx[1].flux > 0 && create_if_block_1$5(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*entity*/ 2) {
    				each_value = /*entity*/ ctx[1].ressources;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*entity*/ ctx[1] == /*System*/ ctx[0].game.player && /*entity*/ ctx[1].flux > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$5(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(9:4) {#if System.game.phase == \\\"Pr√©paration\\\"}",
    		ctx
    	});

    	return block;
    }

    // (11:12) {#if ressource.current > 0 || ressource.max > 0 || ressource.stock > 0}
    function create_if_block_2$2(ctx) {
    	let t0_value = /*ressource*/ ctx[3].name + "";
    	let t0;
    	let t1;
    	let t2_value = /*ressource*/ ctx[3].current + "";
    	let t2;
    	let t3;
    	let t4_value = /*ressource*/ ctx[3].max + "";
    	let t4;
    	let t5;
    	let t6;
    	let br;
    	let if_block = /*ressource*/ ctx[3].stock > 0 && create_if_block_3$2(ctx);

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = text(" : ");
    			t2 = text(t2_value);
    			t3 = text(" / ");
    			t4 = text(t4_value);
    			t5 = space();
    			if (if_block) if_block.c();
    			t6 = space();
    			br = element("br");
    			add_location(br, file$c, 15, 16, 521);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*entity*/ 2 && t0_value !== (t0_value = /*ressource*/ ctx[3].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*entity*/ 2 && t2_value !== (t2_value = /*ressource*/ ctx[3].current + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*entity*/ 2 && t4_value !== (t4_value = /*ressource*/ ctx[3].max + "")) set_data_dev(t4, t4_value);

    			if (/*ressource*/ ctx[3].stock > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$2(ctx);
    					if_block.c();
    					if_block.m(t6.parentNode, t6);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(t5);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(11:12) {#if ressource.current > 0 || ressource.max > 0 || ressource.stock > 0}",
    		ctx
    	});

    	return block;
    }

    // (13:16) {#if ressource.stock > 0}
    function create_if_block_3$2(ctx) {
    	let t0;
    	let t1_value = /*ressource*/ ctx[3].stock + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("+ ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*entity*/ 2 && t1_value !== (t1_value = /*ressource*/ ctx[3].stock + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(13:16) {#if ressource.stock > 0}",
    		ctx
    	});

    	return block;
    }

    // (10:8) {#each entity.ressources as ressource}
    function create_each_block$4(ctx) {
    	let if_block_anchor;
    	let if_block = (/*ressource*/ ctx[3].current > 0 || /*ressource*/ ctx[3].max > 0 || /*ressource*/ ctx[3].stock > 0) && create_if_block_2$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*ressource*/ ctx[3].current > 0 || /*ressource*/ ctx[3].max > 0 || /*ressource*/ ctx[3].stock > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(10:8) {#each entity.ressources as ressource}",
    		ctx
    	});

    	return block;
    }

    // (19:8) {#if entity == System.game.player && entity.flux > 0}
    function create_if_block_1$5(ctx) {
    	let t0;
    	let t1_value = /*entity*/ ctx[1].flux + "";
    	let t1;
    	let t2;
    	let br;
    	let t3;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("Flux : ");
    			t1 = text(t1_value);
    			t2 = space();
    			br = element("br");
    			t3 = space();
    			button = element("button");
    			button.textContent = "G√©rer les √©l√©ments";
    			add_location(br, file$c, 20, 12, 669);
    			attr_dev(button, "class", "classic");
    			add_location(button, file$c, 21, 12, 688);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*entity*/ 2 && t1_value !== (t1_value = /*entity*/ ctx[1].flux + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(19:8) {#if entity == System.game.player && entity.flux > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*entity*/ ctx[1].life.current + "";
    	let t1;
    	let t2;
    	let t3_value = /*entity*/ ctx[1].life.max + "";
    	let t3;
    	let t4;
    	let br;
    	let t5;
    	let if_block = /*System*/ ctx[0].game.phase == "Pr√©paration" && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Vie : ");
    			t1 = text(t1_value);
    			t2 = text(" / ");
    			t3 = text(t3_value);
    			t4 = space();
    			br = element("br");
    			t5 = space();
    			if (if_block) if_block.c();
    			add_location(br, file$c, 7, 4, 145);
    			attr_dev(div, "id", "player-info");
    			attr_dev(div, "class", "svelte-10auntg");
    			add_location(div, file$c, 5, 0, 66);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    			append_dev(div, br);
    			append_dev(div, t5);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*entity*/ 2 && t1_value !== (t1_value = /*entity*/ ctx[1].life.current + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*entity*/ 2 && t3_value !== (t3_value = /*entity*/ ctx[1].life.max + "")) set_data_dev(t3, t3_value);

    			if (/*System*/ ctx[0].game.phase == "Pr√©paration") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Entity', slots, []);
    	let { System } = $$props;
    	let { entity } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Entity> was created without expected prop 'System'");
    		}

    		if (entity === undefined && !('entity' in $$props || $$self.$$.bound[$$self.$$.props['entity']])) {
    			console.warn("<Entity> was created without expected prop 'entity'");
    		}
    	});

    	const writable_props = ['System', 'entity'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Entity> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(0, System.game.flux = true, System);
    		System.pages.change("Game");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('entity' in $$props) $$invalidate(1, entity = $$props.entity);
    	};

    	$$self.$capture_state = () => ({ System, entity });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('entity' in $$props) $$invalidate(1, entity = $$props.entity);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, entity, click_handler];
    }

    class Entity extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { System: 0, entity: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Entity",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get System() {
    		throw new Error("<Entity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Entity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get entity() {
    		throw new Error("<Entity>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set entity(value) {
    		throw new Error("<Entity>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Use.svelte generated by Svelte v3.59.2 */

    const file$b = "src/Use.svelte";

    // (10:0) {#if System.game.use.card != undefined}
    function create_if_block$6(ctx) {
    	let div1;
    	let button;
    	let t1;
    	let br0;
    	let t2;
    	let br1;
    	let t3;
    	let div0;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*System*/ ctx[0].game.use.svelte;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "X";
    			t1 = space();
    			br0 = element("br");
    			t2 = space();
    			br1 = element("br");
    			t3 = space();
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(button, "class", "close");
    			add_location(button, file$b, 11, 8, 211);
    			add_location(br0, file$b, 17, 8, 343);
    			add_location(br1, file$b, 18, 8, 358);
    			attr_dev(div0, "id", "side");
    			attr_dev(div0, "class", "svelte-12e1y01");
    			add_location(div0, file$b, 19, 8, 373);
    			attr_dev(div1, "id", "body");
    			attr_dev(div1, "class", "svelte-12e1y01");
    			add_location(div1, file$b, 10, 4, 187);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(div1, t1);
    			append_dev(div1, br0);
    			append_dev(div1, t2);
    			append_dev(div1, br1);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			if (switch_instance) mount_component(switch_instance, div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (dirty & /*System*/ 1 && switch_value !== (switch_value = /*System*/ ctx[0].game.use.svelte)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(10:0) {#if System.game.use.card != undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*System*/ ctx[0].game.use.card != undefined && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*System*/ ctx[0].game.use.card != undefined) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*System*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Use', slots, []);
    	let { System } = $$props;

    	function close() {
    		System.game.use.reset();
    		System.pages.change("Game");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Use> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Use> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		close();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, close });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, close, click_handler];
    }

    class Use extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Use",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get System() {
    		throw new Error("<Use>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Use>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Flux.svelte generated by Svelte v3.59.2 */

    const file$a = "src/Flux.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (25:0) {#if System.game.flux}
    function create_if_block$5(ctx) {
    	let div2;
    	let div0;
    	let button;
    	let t1;
    	let br;
    	let t2;
    	let div1;
    	let mounted;
    	let dispose;
    	let each_value = /*tab*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button = element("button");
    			button.textContent = "X";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(button, "class", "close");
    			add_location(button, file$a, 27, 12, 481);
    			set_style(div0, "text-align", "right");
    			add_location(div0, file$a, 26, 8, 437);
    			add_location(br, file$a, 34, 8, 648);
    			attr_dev(div1, "class", "container svelte-1kb2ojw");
    			add_location(div1, file$a, 35, 8, 663);
    			attr_dev(div2, "id", "body");
    			attr_dev(div2, "class", "center svelte-1kb2ojw");
    			add_location(div2, file$a, 25, 4, 398);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button);
    			append_dev(div2, t1);
    			append_dev(div2, br);
    			append_dev(div2, t2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div1, null);
    				}
    			}

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*System, tab*/ 5) {
    				each_value = /*tab*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(25:0) {#if System.game.flux}",
    		ctx
    	});

    	return block;
    }

    // (37:12) {#each tab as ressource}
    function create_each_block$3(ctx) {
    	let div;
    	let button;
    	let t0_value = /*ressource*/ ctx[5] + "";
    	let t0;
    	let t1;
    	let br;
    	let t2;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[4](/*ressource*/ ctx[5]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			attr_dev(button, "class", "big svelte-1kb2ojw");
    			add_location(button, file$a, 38, 20, 784);
    			add_location(br, file$a, 47, 20, 1276);
    			attr_dev(div, "class", "ressource svelte-1kb2ojw");
    			add_location(div, file$a, 37, 16, 740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t0);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_1, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(37:12) {#each tab as ressource}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let if_block_anchor;
    	let if_block = /*System*/ ctx[0].game.flux && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*System*/ ctx[0].game.flux) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Flux', slots, []);
    	let { System } = $$props;

    	function close() {
    		$$invalidate(0, System.game.flux = false, System);
    		System.pages.change("Game");
    	}

    	let tab = [
    		"Feu",
    		"Terre",
    		"V√©g√©tal",
    		"Eau",
    		"Air",
    		"Mort",
    		"Metal",
    		"Foudre",
    		"Lumi√®re",
    		"Arcane",
    		"Glace",
    		"Ombre"
    	];

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Flux> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Flux> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		close();
    	};

    	const click_handler_1 = ressource => {
    		System.game.player.ressource(ressource).current++;
    		System.game.player.ressource(ressource).max++;
    		$$invalidate(0, System.game.player.flux--, System);

    		if (System.game.player.flux == 0) {
    			$$invalidate(0, System.game.flux = false, System);
    		}

    		System.pages.change("Game");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, close, tab });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('tab' in $$props) $$invalidate(2, tab = $$props.tab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, close, tab, click_handler, click_handler_1];
    }

    class Flux extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Flux",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get System() {
    		throw new Error("<Flux>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Flux>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Pause.svelte generated by Svelte v3.59.2 */

    const file$9 = "src/Pause.svelte";

    // (10:0) {#if System.game.pause}
    function create_if_block$4(ctx) {
    	let div1;
    	let div0;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let br;
    	let t4;
    	let t5;
    	let button2;
    	let mounted;
    	let dispose;
    	let if_block = /*System*/ ctx[0].game.mode == "Entra√Ænement" && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Options";
    			t3 = space();
    			br = element("br");
    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();
    			button2 = element("button");
    			button2.textContent = "Quitter la partie";
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$9, 12, 12, 257);
    			set_style(div0, "text-align", "right");
    			add_location(div0, file$9, 11, 8, 213);
    			attr_dev(button1, "class", "big");
    			add_location(button1, file$9, 19, 8, 424);
    			add_location(br, file$9, 25, 8, 584);
    			attr_dev(button2, "class", "big");
    			add_location(button2, file$9, 37, 8, 967);
    			attr_dev(div1, "id", "body");
    			attr_dev(div1, "class", "center svelte-yu2xp");
    			add_location(div1, file$9, 10, 4, 174);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(div1, t1);
    			append_dev(div1, button1);
    			append_dev(div1, t3);
    			append_dev(div1, br);
    			append_dev(div1, t4);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t5);
    			append_dev(div1, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_3*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*System*/ ctx[0].game.mode == "Entra√Ænement") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					if_block.m(div1, t5);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(10:0) {#if System.game.pause}",
    		ctx
    	});

    	return block;
    }

    // (27:8) {#if System.game.mode == "Entra√Ænement"}
    function create_if_block_1$4(ctx) {
    	let button;
    	let t1;
    	let br;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Configurer l'entra√Ænement";
    			t1 = space();
    			br = element("br");
    			attr_dev(button, "class", "big");
    			add_location(button, file$9, 27, 12, 651);
    			add_location(br, file$9, 35, 12, 939);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[4], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(27:8) {#if System.game.mode == \\\"Entra√Ænement\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let if_block_anchor;
    	let if_block = /*System*/ ctx[0].game.pause && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*System*/ ctx[0].game.pause) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Pause', slots, []);
    	let { System } = $$props;

    	function close() {
    		$$invalidate(0, System.game.pause = false, System);
    		System.pages.change("Game");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Pause> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pause> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		close();
    	};

    	const click_handler_1 = () => {
    		System.pages.change("Settings");
    	};

    	const click_handler_2 = () => {
    		System.view.reset();
    		System.pages.change("Training");
    		$$invalidate(0, System.game = undefined, System);
    	};

    	const click_handler_3 = () => {
    		System.view.reset();
    		System.pages.change("Menu");
    		$$invalidate(0, System.game = undefined, System);
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, close });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		close,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Pause extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pause",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get System() {
    		throw new Error("<Pause>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Pause>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Game.svelte generated by Svelte v3.59.2 */
    const file$8 = "src/Game.svelte";

    // (13:8) {#if System.game.mode != "Entra√Ænement"}
    function create_if_block_5$1(ctx) {
    	let t0;
    	let t1_value = /*System*/ ctx[0].game.chapter.number + "";
    	let t1;
    	let t2;
    	let t3_value = /*System*/ ctx[0].game.player.step + "";
    	let t3;
    	let t4;
    	let t5_value = /*System*/ ctx[0].game.chapter.steps.length + "";
    	let t5;
    	let t6;

    	const block = {
    		c: function create() {
    			t0 = text("Chapitre ");
    			t1 = text(t1_value);
    			t2 = text(" - √âtape ");
    			t3 = text(t3_value);
    			t4 = text(" / ");
    			t5 = text(t5_value);
    			t6 = text(" -");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, t6, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*System*/ 1 && t1_value !== (t1_value = /*System*/ ctx[0].game.chapter.number + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*System*/ 1 && t3_value !== (t3_value = /*System*/ ctx[0].game.player.step + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*System*/ 1 && t5_value !== (t5_value = /*System*/ ctx[0].game.chapter.steps.length + "")) set_data_dev(t5, t5_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(t6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(13:8) {#if System.game.mode != \\\"Entra√Ænement\\\"}",
    		ctx
    	});

    	return block;
    }

    // (46:12) {:else}
    function create_else_block$3(ctx) {
    	let t0;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("Combat fini -\n                ");
    			button = element("button");
    			button.textContent = "R√©sultats";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$8, 47, 16, 1611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[4], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(46:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:12) {#if !System.game.isEndBattle()}
    function create_if_block_4$1(ctx) {
    	let t0;
    	let t1_value = /*System*/ ctx[0].game.turn + "";
    	let t1;
    	let t2;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("Tour de combat ");
    			t1 = text(t1_value);
    			t2 = text("\n                -\n                ");
    			button = element("button");
    			button.textContent = "Prochaine action";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$8, 38, 16, 1300);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_2*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*System*/ 1 && t1_value !== (t1_value = /*System*/ ctx[0].game.turn + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(36:12) {#if !System.game.isEndBattle()}",
    		ctx
    	});

    	return block;
    }

    // (16:8) {#if !System.game.isBattle()}
    function create_if_block_2$1(ctx) {
    	let button;
    	let t1;
    	let if_block_anchor;
    	let mounted;
    	let dispose;
    	let if_block = /*System*/ ctx[0].game.mode == "Entra√Ænement" && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Combattre";
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$8, 16, 12, 547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*System*/ ctx[0].game.mode == "Entra√Ænement") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(16:8) {#if !System.game.isBattle()}",
    		ctx
    	});

    	return block;
    }

    // (24:12) {#if System.game.mode == "Entra√Ænement"}
    function create_if_block_3$1(ctx) {
    	let t0;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("-\n                ");
    			button = element("button");
    			button.textContent = "Tour de l'ordi";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$8, 25, 16, 845);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(24:12) {#if System.game.mode == \\\"Entra√Ænement\\\"}",
    		ctx
    	});

    	return block;
    }

    // (85:4) {#if !System.game.isBattle()}
    function create_if_block_1$3(ctx) {
    	let switch_instance0;
    	let t0;
    	let switch_instance1;
    	let t1;
    	let switch_instance2;
    	let switch_instance2_anchor;
    	let current;
    	var switch_value = Zone2;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0], zone: "Lieux" },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	var switch_value_1 = Zone2;

    	function switch_props_1(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				zone: "Boutique"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	var switch_value_2 = Zone2;

    	function switch_props_2(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0], zone: "Main" },
    			$$inline: true
    		};
    	}

    	if (switch_value_2) {
    		switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t0 = space();
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			t1 = space();
    			if (switch_instance2) create_component(switch_instance2.$$.fragment);
    			switch_instance2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance0) mount_component(switch_instance0, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (switch_instance1) mount_component(switch_instance1, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (switch_instance2) mount_component(switch_instance2, target, anchor);
    			insert_dev(target, switch_instance2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance0_changes = {};
    			if (dirty & /*System*/ 1) switch_instance0_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = Zone2)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, t0.parentNode, t0);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*System*/ 1) switch_instance1_changes.System = /*System*/ ctx[0];

    			if (switch_value_1 !== (switch_value_1 = Zone2)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, t1.parentNode, t1);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}

    			const switch_instance2_changes = {};
    			if (dirty & /*System*/ 1) switch_instance2_changes.System = /*System*/ ctx[0];

    			if (switch_value_2 !== (switch_value_2 = Zone2)) {
    				if (switch_instance2) {
    					group_outros();
    					const old_component = switch_instance2;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_2) {
    					switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    					create_component(switch_instance2.$$.fragment);
    					transition_in(switch_instance2.$$.fragment, 1);
    					mount_component(switch_instance2, switch_instance2_anchor.parentNode, switch_instance2_anchor);
    				} else {
    					switch_instance2 = null;
    				}
    			} else if (switch_value_2) {
    				switch_instance2.$set(switch_instance2_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			if (switch_instance2) transition_in(switch_instance2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			if (switch_instance2) transition_out(switch_instance2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (switch_instance0) destroy_component(switch_instance0, detaching);
    			if (detaching) detach_dev(t0);
    			if (switch_instance1) destroy_component(switch_instance1, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(switch_instance2_anchor);
    			if (switch_instance2) destroy_component(switch_instance2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(85:4) {#if !System.game.isBattle()}",
    		ctx
    	});

    	return block;
    }

    // (93:4) {#if !System.game.isBattle()}
    function create_if_block$3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Zone2;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				zone: "D√©fausse"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = Zone2)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(93:4) {#if !System.game.isBattle()}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let show_if_2;
    	let show_if_3;
    	let t1;
    	let div1;
    	let button;
    	let t3;
    	let br;
    	let t4;
    	let div6;
    	let div5;
    	let div3;
    	let switch_instance0;
    	let t5;
    	let div4;
    	let switch_instance1;
    	let t6;
    	let show_if_1 = !/*System*/ ctx[0].game.isBattle();
    	let t7;
    	let switch_instance2;
    	let t8;
    	let show_if = !/*System*/ ctx[0].game.isBattle();
    	let t9;
    	let switch_instance3;
    	let t10;
    	let switch_instance4;
    	let t11;
    	let div7;
    	let switch_instance5;
    	let t12;
    	let switch_instance6;
    	let switch_instance6_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*System*/ ctx[0].game.mode != "Entra√Ænement" && create_if_block_5$1(ctx);

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*System*/ 1) show_if_2 = null;
    		if (dirty & /*System*/ 1) show_if_3 = null;
    		if (show_if_2 == null) show_if_2 = !!!/*System*/ ctx[0].game.isBattle();
    		if (show_if_2) return create_if_block_2$1;
    		if (show_if_3 == null) show_if_3 = !!!/*System*/ ctx[0].game.isEndBattle();
    		if (show_if_3) return create_if_block_4$1;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block1 = current_block_type(ctx);
    	var switch_value = Entity;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.player
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	var switch_value_1 = Entity;

    	function switch_props_1(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				entity: /*System*/ ctx[0].game.bot
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_1) {
    		switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    	}

    	let if_block2 = show_if_1 && create_if_block_1$3(ctx);
    	var switch_value_2 = Zone2;

    	function switch_props_2(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				zone: "Terrain"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value_2) {
    		switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    	}

    	let if_block3 = show_if && create_if_block$3(ctx);
    	var switch_value_3 = Use;

    	function switch_props_3(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value_3) {
    		switch_instance3 = construct_svelte_component_dev(switch_value_3, switch_props_3(ctx));
    	}

    	var switch_value_4 = Flux;

    	function switch_props_4(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value_4) {
    		switch_instance4 = construct_svelte_component_dev(switch_value_4, switch_props_4(ctx));
    	}

    	var switch_value_5 = Main$1;

    	function switch_props_5(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value_5) {
    		switch_instance5 = construct_svelte_component_dev(switch_value_5, switch_props_5(ctx));
    	}

    	var switch_value_6 = Pause;

    	function switch_props_6(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value_6) {
    		switch_instance6 = construct_svelte_component_dev(switch_value_6, switch_props_6(ctx));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Pause";
    			t3 = space();
    			br = element("br");
    			t4 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			if (switch_instance0) create_component(switch_instance0.$$.fragment);
    			t5 = space();
    			div4 = element("div");
    			if (switch_instance1) create_component(switch_instance1.$$.fragment);
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			if (switch_instance2) create_component(switch_instance2.$$.fragment);
    			t8 = space();
    			if (if_block3) if_block3.c();
    			t9 = space();
    			if (switch_instance3) create_component(switch_instance3.$$.fragment);
    			t10 = space();
    			if (switch_instance4) create_component(switch_instance4.$$.fragment);
    			t11 = space();
    			div7 = element("div");
    			if (switch_instance5) create_component(switch_instance5.$$.fragment);
    			t12 = space();
    			if (switch_instance6) create_component(switch_instance6.$$.fragment);
    			switch_instance6_anchor = empty();
    			add_location(div0, file$8, 11, 4, 305);
    			attr_dev(button, "class", "classic");
    			add_location(button, file$8, 58, 8, 1935);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$8, 57, 4, 1896);
    			attr_dev(div2, "id", "taskbar");
    			attr_dev(div2, "class", "svelte-sgxsu5");
    			add_location(div2, file$8, 10, 0, 282);
    			add_location(br, file$8, 68, 0, 2146);
    			add_location(div3, file$8, 72, 8, 2221);
    			set_style(div4, "text-align", "right");
    			add_location(div4, file$8, 79, 8, 2394);
    			attr_dev(div5, "class", "zone svelte-sgxsu5");
    			add_location(div5, file$8, 71, 4, 2194);
    			attr_dev(div6, "id", "container");
    			attr_dev(div6, "class", "scroll svelte-sgxsu5");
    			add_location(div6, file$8, 70, 0, 2154);
    			attr_dev(div7, "class", "center");
    			add_location(div7, file$8, 101, 0, 3050);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if_block1.m(div0, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, button);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			if (switch_instance0) mount_component(switch_instance0, div3, null);
    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			if (switch_instance1) mount_component(switch_instance1, div4, null);
    			append_dev(div6, t6);
    			if (if_block2) if_block2.m(div6, null);
    			append_dev(div6, t7);
    			if (switch_instance2) mount_component(switch_instance2, div6, null);
    			append_dev(div6, t8);
    			if (if_block3) if_block3.m(div6, null);
    			insert_dev(target, t9, anchor);
    			if (switch_instance3) mount_component(switch_instance3, target, anchor);
    			insert_dev(target, t10, anchor);
    			if (switch_instance4) mount_component(switch_instance4, target, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div7, anchor);
    			if (switch_instance5) mount_component(switch_instance5, div7, null);
    			insert_dev(target, t12, anchor);
    			if (switch_instance6) mount_component(switch_instance6, target, anchor);
    			insert_dev(target, switch_instance6_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_4*/ ctx[5], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*System*/ ctx[0].game.mode != "Entra√Ænement") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			}

    			const switch_instance0_changes = {};
    			if (dirty & /*System*/ 1) switch_instance0_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance0_changes.entity = /*System*/ ctx[0].game.player;

    			if (switch_value !== (switch_value = Entity)) {
    				if (switch_instance0) {
    					group_outros();
    					const old_component = switch_instance0;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance0.$$.fragment);
    					transition_in(switch_instance0.$$.fragment, 1);
    					mount_component(switch_instance0, div3, null);
    				} else {
    					switch_instance0 = null;
    				}
    			} else if (switch_value) {
    				switch_instance0.$set(switch_instance0_changes);
    			}

    			const switch_instance1_changes = {};
    			if (dirty & /*System*/ 1) switch_instance1_changes.System = /*System*/ ctx[0];
    			if (dirty & /*System*/ 1) switch_instance1_changes.entity = /*System*/ ctx[0].game.bot;

    			if (switch_value_1 !== (switch_value_1 = Entity)) {
    				if (switch_instance1) {
    					group_outros();
    					const old_component = switch_instance1;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_1) {
    					switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
    					create_component(switch_instance1.$$.fragment);
    					transition_in(switch_instance1.$$.fragment, 1);
    					mount_component(switch_instance1, div4, null);
    				} else {
    					switch_instance1 = null;
    				}
    			} else if (switch_value_1) {
    				switch_instance1.$set(switch_instance1_changes);
    			}

    			if (dirty & /*System*/ 1) show_if_1 = !/*System*/ ctx[0].game.isBattle();

    			if (show_if_1) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*System*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$3(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div6, t7);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			const switch_instance2_changes = {};
    			if (dirty & /*System*/ 1) switch_instance2_changes.System = /*System*/ ctx[0];

    			if (switch_value_2 !== (switch_value_2 = Zone2)) {
    				if (switch_instance2) {
    					group_outros();
    					const old_component = switch_instance2;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_2) {
    					switch_instance2 = construct_svelte_component_dev(switch_value_2, switch_props_2(ctx));
    					create_component(switch_instance2.$$.fragment);
    					transition_in(switch_instance2.$$.fragment, 1);
    					mount_component(switch_instance2, div6, t8);
    				} else {
    					switch_instance2 = null;
    				}
    			} else if (switch_value_2) {
    				switch_instance2.$set(switch_instance2_changes);
    			}

    			if (dirty & /*System*/ 1) show_if = !/*System*/ ctx[0].game.isBattle();

    			if (show_if) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*System*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div6, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			const switch_instance3_changes = {};
    			if (dirty & /*System*/ 1) switch_instance3_changes.System = /*System*/ ctx[0];

    			if (switch_value_3 !== (switch_value_3 = Use)) {
    				if (switch_instance3) {
    					group_outros();
    					const old_component = switch_instance3;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_3) {
    					switch_instance3 = construct_svelte_component_dev(switch_value_3, switch_props_3(ctx));
    					create_component(switch_instance3.$$.fragment);
    					transition_in(switch_instance3.$$.fragment, 1);
    					mount_component(switch_instance3, t10.parentNode, t10);
    				} else {
    					switch_instance3 = null;
    				}
    			} else if (switch_value_3) {
    				switch_instance3.$set(switch_instance3_changes);
    			}

    			const switch_instance4_changes = {};
    			if (dirty & /*System*/ 1) switch_instance4_changes.System = /*System*/ ctx[0];

    			if (switch_value_4 !== (switch_value_4 = Flux)) {
    				if (switch_instance4) {
    					group_outros();
    					const old_component = switch_instance4;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_4) {
    					switch_instance4 = construct_svelte_component_dev(switch_value_4, switch_props_4(ctx));
    					create_component(switch_instance4.$$.fragment);
    					transition_in(switch_instance4.$$.fragment, 1);
    					mount_component(switch_instance4, t11.parentNode, t11);
    				} else {
    					switch_instance4 = null;
    				}
    			} else if (switch_value_4) {
    				switch_instance4.$set(switch_instance4_changes);
    			}

    			const switch_instance5_changes = {};
    			if (dirty & /*System*/ 1) switch_instance5_changes.System = /*System*/ ctx[0];

    			if (switch_value_5 !== (switch_value_5 = Main$1)) {
    				if (switch_instance5) {
    					group_outros();
    					const old_component = switch_instance5;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_5) {
    					switch_instance5 = construct_svelte_component_dev(switch_value_5, switch_props_5(ctx));
    					create_component(switch_instance5.$$.fragment);
    					transition_in(switch_instance5.$$.fragment, 1);
    					mount_component(switch_instance5, div7, null);
    				} else {
    					switch_instance5 = null;
    				}
    			} else if (switch_value_5) {
    				switch_instance5.$set(switch_instance5_changes);
    			}

    			const switch_instance6_changes = {};
    			if (dirty & /*System*/ 1) switch_instance6_changes.System = /*System*/ ctx[0];

    			if (switch_value_6 !== (switch_value_6 = Pause)) {
    				if (switch_instance6) {
    					group_outros();
    					const old_component = switch_instance6;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value_6) {
    					switch_instance6 = construct_svelte_component_dev(switch_value_6, switch_props_6(ctx));
    					create_component(switch_instance6.$$.fragment);
    					transition_in(switch_instance6.$$.fragment, 1);
    					mount_component(switch_instance6, switch_instance6_anchor.parentNode, switch_instance6_anchor);
    				} else {
    					switch_instance6 = null;
    				}
    			} else if (switch_value_6) {
    				switch_instance6.$set(switch_instance6_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
    			transition_in(if_block2);
    			if (switch_instance2) transition_in(switch_instance2.$$.fragment, local);
    			transition_in(if_block3);
    			if (switch_instance3) transition_in(switch_instance3.$$.fragment, local);
    			if (switch_instance4) transition_in(switch_instance4.$$.fragment, local);
    			if (switch_instance5) transition_in(switch_instance5.$$.fragment, local);
    			if (switch_instance6) transition_in(switch_instance6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
    			if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
    			transition_out(if_block2);
    			if (switch_instance2) transition_out(switch_instance2.$$.fragment, local);
    			transition_out(if_block3);
    			if (switch_instance3) transition_out(switch_instance3.$$.fragment, local);
    			if (switch_instance4) transition_out(switch_instance4.$$.fragment, local);
    			if (switch_instance5) transition_out(switch_instance5.$$.fragment, local);
    			if (switch_instance6) transition_out(switch_instance6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div6);
    			if (switch_instance0) destroy_component(switch_instance0);
    			if (switch_instance1) destroy_component(switch_instance1);
    			if (if_block2) if_block2.d();
    			if (switch_instance2) destroy_component(switch_instance2);
    			if (if_block3) if_block3.d();
    			if (detaching) detach_dev(t9);
    			if (switch_instance3) destroy_component(switch_instance3, detaching);
    			if (detaching) detach_dev(t10);
    			if (switch_instance4) destroy_component(switch_instance4, detaching);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div7);
    			if (switch_instance5) destroy_component(switch_instance5);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(switch_instance6_anchor);
    			if (switch_instance6) destroy_component(switch_instance6, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Game', slots, []);
    	let { System } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Game> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Game> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.view.reset();
    		System.game.newBattle();
    	};

    	const click_handler_1 = () => {
    		System.view.reset();
    		System.game.bot.play();
    		System.pages.change("Game");
    	};

    	const click_handler_2 = () => {
    		System.view.reset();
    		System.game.actionBattle();
    	};

    	const click_handler_3 = () => {
    		System.view.reset();
    		System.game.actionBattle();
    	};

    	const click_handler_4 = () => {
    		$$invalidate(0, System.game.pause = true, System);
    		System.pages.change("Game");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Zone2,
    		Entity,
    		View: Main$1,
    		Use,
    		Flux,
    		Pause,
    		System
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4
    	];
    }

    class Game extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Game",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get System() {
    		throw new Error("<Game>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Game>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Settings.svelte generated by Svelte v3.59.2 */

    const file$7 = "src/Settings.svelte";

    function create_fragment$7(ctx) {
    	let button;
    	let t1;
    	let br;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "X";
    			t1 = space();
    			br = element("br");
    			attr_dev(button, "class", "close");
    			add_location(button, file$7, 13, 0, 231);
    			add_location(br, file$7, 19, 0, 315);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Settings', slots, []);
    	let { System } = $$props;

    	function close() {
    		if (System.game == undefined) {
    			System.pages.change("Menu");
    		} else {
    			System.pages.change("Game");
    		}
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Settings> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		close();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System, close });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(1, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [close, System, click_handler];
    }

    class Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { System: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get System() {
    		throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Dialog.svelte generated by Svelte v3.59.2 */

    const file$6 = "src/Dialog.svelte";

    function create_fragment$6(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*System*/ ctx[0].game.chapter.number + "";
    	let t1;
    	let t2;
    	let t3_value = /*System*/ ctx[0].game.player.step + "";
    	let t3;
    	let t4;
    	let t5_value = /*System*/ ctx[0].game.chapter.steps.length + "";
    	let t5;
    	let t6;
    	let br0;
    	let br1;
    	let t7;
    	let t8_value = /*System*/ ctx[0].game.chapter.steps[/*System*/ ctx[0].game.player.step - 1].dialogs[/*System*/ ctx[0].game.chapter.dialog] + "";
    	let t8;
    	let t9;
    	let br2;
    	let br3;
    	let t10;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Chapitre ");
    			t1 = text(t1_value);
    			t2 = text(" - √âtape ");
    			t3 = text(t3_value);
    			t4 = text(" / ");
    			t5 = text(t5_value);
    			t6 = space();
    			br0 = element("br");
    			br1 = element("br");
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			br2 = element("br");
    			br3 = element("br");
    			t10 = space();
    			button = element("button");
    			button.textContent = "Suivant";
    			add_location(br0, file$6, 6, 4, 191);
    			add_location(br1, file$6, 6, 10, 197);
    			add_location(br2, file$6, 8, 4, 305);
    			add_location(br3, file$6, 8, 10, 311);
    			attr_dev(button, "class", "big");
    			add_location(button, file$6, 9, 4, 322);
    			attr_dev(div, "id", "body");
    			attr_dev(div, "class", "center svelte-s3a26v");
    			add_location(div, file$6, 4, 0, 43);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    			append_dev(div, t5);
    			append_dev(div, t6);
    			append_dev(div, br0);
    			append_dev(div, br1);
    			append_dev(div, t7);
    			append_dev(div, t8);
    			append_dev(div, t9);
    			append_dev(div, br2);
    			append_dev(div, br3);
    			append_dev(div, t10);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*System*/ 1 && t1_value !== (t1_value = /*System*/ ctx[0].game.chapter.number + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*System*/ 1 && t3_value !== (t3_value = /*System*/ ctx[0].game.player.step + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*System*/ 1 && t5_value !== (t5_value = /*System*/ ctx[0].game.chapter.steps.length + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*System*/ 1 && t8_value !== (t8_value = /*System*/ ctx[0].game.chapter.steps[/*System*/ ctx[0].game.player.step - 1].dialogs[/*System*/ ctx[0].game.chapter.dialog] + "")) set_data_dev(t8, t8_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dialog', slots, []);
    	let { System } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Dialog> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dialog> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.game.chapter.nextDialog();
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, click_handler];
    }

    class Dialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialog",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get System() {
    		throw new Error("<Dialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Dialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Finish.svelte generated by Svelte v3.59.2 */

    const file$5 = "src/Finish.svelte";

    function create_fragment$5(ctx) {
    	let div;
    	let t0;
    	let br0;
    	let br1;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("L'histoire est arriv√©e √† son terme\n    ");
    			br0 = element("br");
    			br1 = element("br");
    			t1 = space();
    			button = element("button");
    			button.textContent = "Retour √† l'√©cran titre";
    			add_location(br0, file$5, 6, 4, 102);
    			add_location(br1, file$5, 6, 10, 108);
    			attr_dev(button, "class", "big");
    			add_location(button, file$5, 7, 4, 119);
    			attr_dev(div, "id", "body");
    			attr_dev(div, "class", "svelte-110pffl");
    			add_location(div, file$5, 4, 0, 43);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, br0);
    			append_dev(div, br1);
    			append_dev(div, t1);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Finish', slots, []);
    	let { System } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Finish> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Finish> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("Menu");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, click_handler];
    }

    class Finish extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Finish",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get System() {
    		throw new Error("<Finish>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Finish>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/GameOver.svelte generated by Svelte v3.59.2 */

    const file$4 = "src/GameOver.svelte";

    function create_fragment$4(ctx) {
    	let div;
    	let t0;
    	let br0;
    	let br1;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("L'histoire s'arr√™te ici...\n    ");
    			br0 = element("br");
    			br1 = element("br");
    			t1 = space();
    			button = element("button");
    			button.textContent = "Retour √† l'√©cran titre";
    			add_location(br0, file$4, 6, 4, 94);
    			add_location(br1, file$4, 6, 10, 100);
    			attr_dev(button, "class", "big");
    			add_location(button, file$4, 7, 4, 111);
    			attr_dev(div, "id", "body");
    			attr_dev(div, "class", "svelte-110pffl");
    			add_location(div, file$4, 4, 0, 43);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, br0);
    			append_dev(div, br1);
    			append_dev(div, t1);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GameOver', slots, []);
    	let { System } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<GameOver> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GameOver> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.pages.change("Menu");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ System });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [System, click_handler];
    }

    class GameOver extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GameOver",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get System() {
    		throw new Error("<GameOver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<GameOver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Decks/List.svelte generated by Svelte v3.59.2 */
    const file$3 = "src/Decks/List.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (72:20) {:else}
    function create_else_block_1$1(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñ≤";
    			attr_dev(button, "class", "classic useless svelte-1mhqeym");
    			add_location(button, file$3, 72, 24, 2386);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(72:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (62:20) {#if i > 0}
    function create_if_block_1$2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[8](/*i*/ ctx[12], /*deck*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñ≤";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$3, 62, 24, 1922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_4, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(62:20) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (85:20) {:else}
    function create_else_block$2(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñº";
    			attr_dev(button, "class", "classic useless svelte-1mhqeym");
    			add_location(button, file$3, 85, 24, 3002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(85:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:20) {#if i < System.decks.length - 1}
    function create_if_block$2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[9](/*i*/ ctx[12], /*deck*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñº";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$3, 75, 24, 2538);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_5, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(75:20) {#if i < System.decks.length - 1}",
    		ctx
    	});

    	return block;
    }

    // (32:8) {#each System.decks as deck, i}
    function create_each_block$2(ctx) {
    	let div2;
    	let div0;
    	let button0;
    	let t0_value = /*deck*/ ctx[10].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let button1;
    	let t3;
    	let t4;
    	let t5;
    	let mounted;
    	let dispose;

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[4](/*deck*/ ctx[10]);
    	}

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[6](/*deck*/ ctx[10]);
    	}

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[7](/*deck*/ ctx[10]);
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*i*/ ctx[12] > 0) return create_if_block_1$2;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*i*/ ctx[12] < /*System*/ ctx[0].decks.length - 1) return create_if_block$2;
    		return create_else_block$2;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			button1 = element("button");
    			button1.textContent = "Modifier";
    			t3 = space();
    			if_block0.c();
    			t4 = space();
    			if_block1.c();
    			t5 = space();
    			attr_dev(button0, "class", "classic");
    			add_location(button0, file$3, 34, 20, 788);
    			add_location(div0, file$3, 33, 16, 762);
    			add_location(button1, file$3, 52, 20, 1550);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$3, 51, 16, 1499);
    			attr_dev(div2, "class", "preview svelte-1mhqeym");
    			add_location(div2, file$3, 32, 12, 724);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			append_dev(button0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, button1);
    			append_dev(div1, t3);
    			if_block0.m(div1, null);
    			append_dev(div1, t4);
    			if_block1.m(div1, null);
    			append_dev(div2, t5);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "mouseenter", mouseenter_handler, false, false, false, false),
    					listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[5], false, false, false, false),
    					listen_dev(button0, "click", click_handler_2, false, false, false, false),
    					listen_dev(button1, "click", click_handler_3, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*System*/ 1 && t0_value !== (t0_value = /*deck*/ ctx[10].name + "")) set_data_dev(t0, t0_value);
    			if_block0.p(ctx, dirty);

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block0.d();
    			if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(32:8) {#each System.decks as deck, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let button0;
    	let t1;
    	let br0;
    	let t2;
    	let div1;
    	let t3_value = /*System*/ ctx[0].several(/*System*/ ctx[0].decks.length, "deck") + "";
    	let t3;
    	let t4;
    	let button1;
    	let t6;
    	let br1;
    	let t7;
    	let div0;
    	let t8;
    	let div2;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*System*/ ctx[0].decks;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	var switch_value = View;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			br0 = element("br");
    			t2 = space();
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = text(" -\n    ");
    			button1 = element("button");
    			button1.textContent = "Cr√©er un nouveau deck";
    			t6 = space();
    			br1 = element("br");
    			t7 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			div2 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$3, 13, 0, 286);
    			add_location(br0, file$3, 20, 0, 419);
    			attr_dev(button1, "class", "classic");
    			add_location(button1, file$3, 23, 4, 498);
    			add_location(br1, file$3, 29, 4, 630);
    			attr_dev(div0, "id", "list");
    			attr_dev(div0, "class", "scroll svelte-1mhqeym");
    			add_location(div0, file$3, 30, 4, 641);
    			attr_dev(div1, "id", "zone");
    			attr_dev(div1, "class", "svelte-1mhqeym");
    			add_location(div1, file$3, 21, 0, 426);
    			attr_dev(div2, "id", "view");
    			attr_dev(div2, "class", "svelte-1mhqeym");
    			add_location(div2, file$3, 93, 0, 3153);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div1, button1);
    			append_dev(div1, t6);
    			append_dev(div1, br1);
    			append_dev(div1, t7);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			insert_dev(target, t8, anchor);
    			insert_dev(target, div2, anchor);
    			if (switch_instance) mount_component(switch_instance, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*System*/ 1) && t3_value !== (t3_value = /*System*/ ctx[0].several(/*System*/ ctx[0].decks.length, "deck") + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*System, undefined*/ 1) {
    				each_value = /*System*/ ctx[0].decks;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = View)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div2, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div2);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('List', slots, []);
    	let { System } = $$props;

    	function newDeck() {
    		let deck = new Deck$1(System);
    		System.decks.push(deck);
    		$$invalidate(0, System.deck = deck, System);
    		System.pages.change("Deck");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<List> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<List> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.view.reset();
    		System.pages.change("Menu");
    	};

    	const click_handler_1 = () => {
    		newDeck();
    	};

    	const mouseenter_handler = deck => {
    		$$invalidate(0, System.view.quick = deck, System);
    		System.pages.change("Decks");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Decks");
    	};

    	const click_handler_2 = deck => {
    		$$invalidate(0, System.view.card = deck, System);
    		System.pages.change("Decks");
    	};

    	const click_handler_3 = deck => {
    		$$invalidate(0, System.deck = deck, System);
    		System.view.reset();
    		System.pages.change("Deck");
    	};

    	const click_handler_4 = (i, deck) => {
    		let temp = System.decks[i - 1];
    		$$invalidate(0, System.decks[i - 1] = deck, System);
    		$$invalidate(0, System.decks[i] = temp, System);
    		System.pages.change("Decks");
    	};

    	const click_handler_5 = (i, deck) => {
    		let temp = System.decks[i + 1];
    		$$invalidate(0, System.decks[i + 1] = deck, System);
    		$$invalidate(0, System.decks[i] = temp, System);
    		System.pages.change("Decks");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({ Deck: Deck$1, View, System, newDeck });

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		newDeck,
    		click_handler,
    		click_handler_1,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get System() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Decks/Deck.svelte generated by Svelte v3.59.2 */
    const file$2 = "src/Decks/Deck.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	child_ctx[29] = i;
    	return child_ctx;
    }

    // (70:8) {#if name != System.deck.name}
    function create_if_block_6(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Renommer";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 70, 12, 1763);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[14], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(70:8) {#if name != System.deck.name}",
    		ctx
    	});

    	return block;
    }

    // (112:4) {#if System.deck.canModify()}
    function create_if_block_4(ctx) {
    	let t0;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*move*/ ctx[3]) return create_if_block_5;
    		return create_else_block_3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			t0 = text("-\n        ");
    			if_block.c();
    			t1 = text("\n        -\n        ");
    			button = element("button");
    			button.textContent = "Ajouter une carte";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 131, 8, 3303);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_7*/ ctx[20], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t1.parentNode, t1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(112:4) {#if System.deck.canModify()}",
    		ctx
    	});

    	return block;
    }

    // (122:8) {:else}
    function create_else_block_3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "D√©placer";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 122, 12, 3065);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_6*/ ctx[19], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(122:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (114:8) {#if move}
    function create_if_block_5(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Enlever";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 114, 12, 2831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_5*/ ctx[18], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(114:8) {#if move}",
    		ctx
    	});

    	return block;
    }

    // (190:20) {:else}
    function create_else_block_2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_11() {
    		return /*click_handler_11*/ ctx[26](/*card*/ ctx[27]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Enlever";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 190, 24, 5921);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_11, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(190:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (161:20) {#if move}
    function create_if_block_1$1(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*i*/ ctx[29] > 0) return create_if_block_3;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*i*/ ctx[29] < /*System*/ ctx[0].deck.cards.length - 1) return create_if_block_2;
    		return create_else_block$1;
    	}

    	let current_block_type_1 = select_block_type_3(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if_block0.p(ctx, dirty);

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(161:20) {#if move}",
    		ctx
    	});

    	return block;
    }

    // (173:24) {:else}
    function create_else_block_1(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñ≤";
    			attr_dev(button, "class", "classic useless svelte-k9miyh");
    			add_location(button, file$2, 173, 28, 5059);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(173:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (162:24) {#if i > 0}
    function create_if_block_3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_9() {
    		return /*click_handler_9*/ ctx[24](/*i*/ ctx[29], /*card*/ ctx[27]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñ≤";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 162, 28, 4496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_9, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(162:24) {#if i > 0}",
    		ctx
    	});

    	return block;
    }

    // (187:24) {:else}
    function create_else_block$1(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñº";
    			attr_dev(button, "class", "classic useless svelte-k9miyh");
    			add_location(button, file$2, 187, 28, 5791);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(187:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (176:24) {#if i < System.deck.cards.length - 1}
    function create_if_block_2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_10() {
    		return /*click_handler_10*/ ctx[25](/*i*/ ctx[29], /*card*/ ctx[27]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "‚ñº";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 176, 28, 5228);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_10, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(176:24) {#if i < System.deck.cards.length - 1}",
    		ctx
    	});

    	return block;
    }

    // (141:8) {#each cardList as card, i}
    function create_each_block$1(ctx) {
    	let div2;
    	let div0;
    	let button;
    	let t0_value = /*card*/ ctx[27] + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let mounted;
    	let dispose;

    	function click_handler_8() {
    		return /*click_handler_8*/ ctx[21](/*card*/ ctx[27]);
    	}

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[22](/*card*/ ctx[27]);
    	}

    	function select_block_type_1(ctx, dirty) {
    		if (/*move*/ ctx[3]) return create_if_block_1$1;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			if_block.c();
    			t2 = space();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$2, 143, 20, 3643);
    			add_location(div0, file$2, 142, 16, 3617);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$2, 159, 16, 4369);
    			attr_dev(div2, "class", "preview svelte-k9miyh");
    			add_location(div2, file$2, 141, 12, 3579);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button);
    			append_dev(button, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			if_block.m(div1, null);
    			append_dev(div2, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", click_handler_8, false, false, false, false),
    					listen_dev(button, "mouseenter", mouseenter_handler, false, false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[23], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*cardList*/ 256 && t0_value !== (t0_value = /*card*/ ctx[27] + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(141:8) {#each cardList as card, i}",
    		ctx
    	});

    	return block;
    }

    // (210:0) {#if sorted}
    function create_if_block$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Filter;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				levelSelect: /*levelSelect*/ ctx[4],
    				typeSelect: /*typeSelect*/ ctx[5],
    				familleSelect: /*familleSelect*/ ctx[6],
    				elementSelect: /*elementSelect*/ ctx[7],
    				sorting: /*sorting*/ ctx[10],
    				closing: /*closing*/ ctx[11]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*levelSelect*/ 16) switch_instance_changes.levelSelect = /*levelSelect*/ ctx[4];
    			if (dirty & /*typeSelect*/ 32) switch_instance_changes.typeSelect = /*typeSelect*/ ctx[5];
    			if (dirty & /*familleSelect*/ 64) switch_instance_changes.familleSelect = /*familleSelect*/ ctx[6];
    			if (dirty & /*elementSelect*/ 128) switch_instance_changes.elementSelect = /*elementSelect*/ ctx[7];

    			if (switch_value !== (switch_value = Filter)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(210:0) {#if sorted}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let button0;
    	let t1;
    	let br0;
    	let t2;
    	let div2;
    	let div0;
    	let input;
    	let t3;
    	let t4;
    	let br1;
    	let t5;
    	let button1;
    	let t7;
    	let div1;
    	let button2;
    	let t9;
    	let div4;
    	let t10_value = /*cardList*/ ctx[8].length + "";
    	let t10;
    	let t11;
    	let t12_value = /*System*/ ctx[0].several(/*System*/ ctx[0].deck.cards.length, "carte") + "";
    	let t12;
    	let t13;
    	let button3;
    	let t15;
    	let show_if = /*System*/ ctx[0].deck.canModify();
    	let t16;
    	let div3;
    	let t17;
    	let div5;
    	let switch_instance;
    	let t18;
    	let if_block2_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*name*/ ctx[1] != /*System*/ ctx[0].deck.name && create_if_block_6(ctx);
    	let if_block1 = show_if && create_if_block_4(ctx);
    	let each_value = /*cardList*/ ctx[8];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	var switch_value = Main$1;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	let if_block2 = /*sorted*/ ctx[2] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			br0 = element("br");
    			t2 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			br1 = element("br");
    			t5 = space();
    			button1 = element("button");
    			button1.textContent = "Cloner";
    			t7 = space();
    			div1 = element("div");
    			button2 = element("button");
    			button2.textContent = "Supprimer";
    			t9 = space();
    			div4 = element("div");
    			t10 = text(t10_value);
    			t11 = text("\n    /\n    ");
    			t12 = text(t12_value);
    			t13 = text("\n    -\n    ");
    			button3 = element("button");
    			button3.textContent = "Filtrer";
    			t15 = space();
    			if (if_block1) if_block1.c();
    			t16 = space();
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t17 = space();
    			div5 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t18 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$2, 58, 0, 1484);
    			add_location(br0, file$2, 65, 0, 1618);
    			attr_dev(input, "type", "text");
    			add_location(input, file$2, 68, 8, 1672);
    			add_location(br1, file$2, 78, 8, 2011);
    			attr_dev(button1, "class", "classic");
    			add_location(button1, file$2, 79, 8, 2026);
    			add_location(div0, file$2, 67, 4, 1658);
    			attr_dev(button2, "class", "classic delete svelte-k9miyh");
    			add_location(button2, file$2, 88, 8, 2261);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$2, 87, 4, 2221);
    			attr_dev(div2, "id", "head");
    			attr_dev(div2, "class", "zone svelte-k9miyh");
    			add_location(div2, file$2, 66, 0, 1625);
    			attr_dev(button3, "class", "classic");
    			add_location(button3, file$2, 102, 4, 2583);
    			attr_dev(div3, "id", "list");
    			attr_dev(div3, "class", "svelte-k9miyh");
    			add_location(div3, file$2, 139, 4, 3515);
    			attr_dev(div4, "class", "zone svelte-k9miyh");
    			add_location(div4, file$2, 97, 0, 2470);
    			attr_dev(div5, "id", "view");
    			attr_dev(div5, "class", "svelte-k9miyh");
    			add_location(div5, file$2, 205, 0, 6355);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*name*/ ctx[1]);
    			append_dev(div0, t3);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t4);
    			append_dev(div0, br1);
    			append_dev(div0, t5);
    			append_dev(div0, button1);
    			append_dev(div2, t7);
    			append_dev(div2, div1);
    			append_dev(div1, button2);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, t10);
    			append_dev(div4, t11);
    			append_dev(div4, t12);
    			append_dev(div4, t13);
    			append_dev(div4, button3);
    			append_dev(div4, t15);
    			if (if_block1) if_block1.m(div4, null);
    			append_dev(div4, t16);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div3, null);
    				}
    			}

    			insert_dev(target, t17, anchor);
    			insert_dev(target, div5, anchor);
    			if (switch_instance) mount_component(switch_instance, div5, null);
    			insert_dev(target, t18, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[12], false, false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[13]),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[15], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_3*/ ctx[16], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_4*/ ctx[17], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name*/ 2 && input.value !== /*name*/ ctx[1]) {
    				set_input_value(input, /*name*/ ctx[1]);
    			}

    			if (/*name*/ ctx[1] != /*System*/ ctx[0].deck.name) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6(ctx);
    					if_block0.c();
    					if_block0.m(div0, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || dirty & /*cardList*/ 256) && t10_value !== (t10_value = /*cardList*/ ctx[8].length + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*System*/ 1) && t12_value !== (t12_value = /*System*/ ctx[0].several(/*System*/ ctx[0].deck.cards.length, "carte") + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*System*/ 1) show_if = /*System*/ ctx[0].deck.canModify();

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(div4, t16);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*System, cardList, cards, move, undefined*/ 777) {
    				each_value = /*cardList*/ ctx[8];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = Main$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div5, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (/*sorted*/ ctx[2]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*sorted*/ 4) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div4);
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div5);
    			if (switch_instance) destroy_component(switch_instance);
    			if (detaching) detach_dev(t18);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Deck', slots, []);
    	let { System } = $$props;
    	let name = System.deck.name;
    	let sorted = false;
    	let move;

    	if (System.deck.canModify()) {
    		move = false;
    	} else {
    		move = true;
    	}

    	let levelSelect = "Tous";
    	let typeSelect = "Tous";
    	let familleSelect = "Toutes";
    	let elementSelect = "Tous";
    	let cardList = [];
    	cards();

    	function cards() {
    		let tab = [];

    		for (const cardName of System.deck.cards) {
    			let card = System.cards.getByName(cardName);

    			if (!card.onlyBot && card.playable && (levelSelect == "Tous" || card.level == levelSelect) && (typeSelect == "Tous" || card.type == typeSelect) && (familleSelect == "Toutes" || card.familles.base.includes(familleSelect)) && (elementSelect == "Tous" || card.elements.includes(elementSelect))) {
    				tab.push(cardName);
    			}
    		}

    		$$invalidate(8, cardList = tab);
    	}

    	function sorting(level, type, famille, element) {
    		$$invalidate(4, levelSelect = level);
    		$$invalidate(5, typeSelect = type);
    		$$invalidate(6, familleSelect = famille);
    		$$invalidate(7, elementSelect = element);
    		cards();
    		closing();
    	}

    	function closing() {
    		$$invalidate(2, sorted = false);
    		System.pages.change("Deck");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Deck> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Deck> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.view.reset();
    		System.pages.change("Decks");
    	};

    	function input_input_handler() {
    		name = this.value;
    		$$invalidate(1, name);
    	}

    	const click_handler_1 = () => {
    		System.deck.changeName(name, 0);
    		System.pages.change("Deck");
    	};

    	const click_handler_2 = () => {
    		System.view.reset();
    		System.deck.clone();
    	};

    	const click_handler_3 = () => {
    		System.view.reset();
    		System.deck.delete();
    	};

    	const click_handler_4 = () => {
    		$$invalidate(2, sorted = true);
    		System.pages.change("Deck");
    	};

    	const click_handler_5 = () => {
    		$$invalidate(3, move = false);
    		System.pages.change("Deck");
    	};

    	const click_handler_6 = () => {
    		$$invalidate(3, move = true);
    		System.pages.change("Deck");
    	};

    	const click_handler_7 = () => {
    		System.view.reset();
    		System.pages.change("Add");
    	};

    	const click_handler_8 = card => {
    		$$invalidate(0, System.view.card = System.cards.getByName(card), System);
    		System.pages.change("Deck");
    	};

    	const mouseenter_handler = card => {
    		$$invalidate(0, System.view.quick = System.cards.getByName(card), System);
    		System.pages.change("Deck");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Deck");
    	};

    	const click_handler_9 = (i, card) => {
    		let temp = System.deck.cards[i - 1];
    		$$invalidate(0, System.deck.cards[i - 1] = card, System);
    		$$invalidate(0, System.deck.cards[i] = temp, System);
    		cards();
    		System.pages.change("Deck");
    	};

    	const click_handler_10 = (i, card) => {
    		let temp = System.deck.cards[i + 1];
    		$$invalidate(0, System.deck.cards[i + 1] = card, System);
    		$$invalidate(0, System.deck.cards[i] = temp, System);
    		cards();
    		System.pages.change("Deck");
    	};

    	const click_handler_11 = card => {
    		System.deck.remove(card);
    		cards();
    		System.pages.change("Deck");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Filter,
    		View: Main$1,
    		System,
    		name,
    		sorted,
    		move,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		cards,
    		sorting,
    		closing
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('name' in $$props) $$invalidate(1, name = $$props.name);
    		if ('sorted' in $$props) $$invalidate(2, sorted = $$props.sorted);
    		if ('move' in $$props) $$invalidate(3, move = $$props.move);
    		if ('levelSelect' in $$props) $$invalidate(4, levelSelect = $$props.levelSelect);
    		if ('typeSelect' in $$props) $$invalidate(5, typeSelect = $$props.typeSelect);
    		if ('familleSelect' in $$props) $$invalidate(6, familleSelect = $$props.familleSelect);
    		if ('elementSelect' in $$props) $$invalidate(7, elementSelect = $$props.elementSelect);
    		if ('cardList' in $$props) $$invalidate(8, cardList = $$props.cardList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		name,
    		sorted,
    		move,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		cards,
    		sorting,
    		closing,
    		click_handler,
    		input_input_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_9,
    		click_handler_10,
    		click_handler_11
    	];
    }

    class Deck extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Deck",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get System() {
    		throw new Error("<Deck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Deck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Decks/Add.svelte generated by Svelte v3.59.2 */
    const file$1 = "src/Decks/Add.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (98:20) {:else}
    function create_else_block(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[15](/*card*/ ctx[17]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Enlever";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1, 98, 24, 2985);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_4, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(98:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:20) {#if !System.deck.check(card.name)}
    function create_if_block_1(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[14](/*card*/ ctx[17]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Ajouter";
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1, 91, 24, 2702);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_3, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(91:20) {#if !System.deck.check(card.name)}",
    		ctx
    	});

    	return block;
    }

    // (71:8) {#each cardList as card}
    function create_each_block(ctx) {
    	let div2;
    	let div0;
    	let button;
    	let t0_value = /*card*/ ctx[17].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let show_if;
    	let t2;
    	let div2_class_value;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[11](/*card*/ ctx[17]);
    	}

    	function mouseenter_handler() {
    		return /*mouseenter_handler*/ ctx[12](/*card*/ ctx[17]);
    	}

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*System, cardList*/ 65) show_if = null;
    		if (show_if == null) show_if = !!!/*System*/ ctx[0].deck.check(/*card*/ ctx[17].name);
    		if (show_if) return create_if_block_1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			if_block.c();
    			t2 = space();
    			attr_dev(button, "class", "classic");
    			add_location(button, file$1, 73, 20, 1910);
    			add_location(div0, file$1, 72, 16, 1884);
    			set_style(div1, "text-align", "right");
    			add_location(div1, file$1, 89, 16, 2590);

    			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty((/*System*/ ctx[0].deck.check(/*card*/ ctx[17].name)
    			? "present "
    			: "") + "preview") + " svelte-1q97uxg"));

    			add_location(div2, file$1, 71, 12, 1793);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, button);
    			append_dev(button, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			if_block.m(div1, null);
    			append_dev(div2, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", click_handler_2, false, false, false, false),
    					listen_dev(button, "mouseenter", mouseenter_handler, false, false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[13], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*cardList*/ 64 && t0_value !== (t0_value = /*card*/ ctx[17].name + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			}

    			if (dirty & /*System, cardList*/ 65 && div2_class_value !== (div2_class_value = "" + (null_to_empty((/*System*/ ctx[0].deck.check(/*card*/ ctx[17].name)
    			? "present "
    			: "") + "preview") + " svelte-1q97uxg"))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(71:8) {#each cardList as card}",
    		ctx
    	});

    	return block;
    }

    // (117:0) {#if filterWindow}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = Filter;

    	function switch_props(ctx) {
    		return {
    			props: {
    				System: /*System*/ ctx[0],
    				levelSelect: /*levelSelect*/ ctx[2],
    				typeSelect: /*typeSelect*/ ctx[3],
    				familleSelect: /*familleSelect*/ ctx[4],
    				elementSelect: /*elementSelect*/ ctx[5],
    				sorting: /*sorting*/ ctx[7],
    				close: /*close*/ ctx[8]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];
    			if (dirty & /*levelSelect*/ 4) switch_instance_changes.levelSelect = /*levelSelect*/ ctx[2];
    			if (dirty & /*typeSelect*/ 8) switch_instance_changes.typeSelect = /*typeSelect*/ ctx[3];
    			if (dirty & /*familleSelect*/ 16) switch_instance_changes.familleSelect = /*familleSelect*/ ctx[4];
    			if (dirty & /*elementSelect*/ 32) switch_instance_changes.elementSelect = /*elementSelect*/ ctx[5];

    			if (switch_value !== (switch_value = Filter)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(117:0) {#if filterWindow}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let button0;
    	let t1;
    	let br;
    	let t2;
    	let div1;
    	let t3_value = /*System*/ ctx[0].several(/*cardList*/ ctx[6].length, "carte") + "";
    	let t3;
    	let t4;
    	let button1;
    	let t6;
    	let div0;
    	let t7;
    	let div2;
    	let switch_instance;
    	let t8;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*cardList*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	var switch_value = Main$1;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	let if_block = /*filterWindow*/ ctx[1] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "X";
    			t1 = space();
    			br = element("br");
    			t2 = space();
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = text("\n    -\n    ");
    			button1 = element("button");
    			button1.textContent = "Filtrer";
    			t6 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			div2 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t8 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(button0, "class", "close");
    			add_location(button0, file$1, 49, 0, 1322);
    			add_location(br, file$1, 56, 0, 1455);
    			attr_dev(button1, "class", "classic");
    			add_location(button1, file$1, 60, 4, 1535);
    			attr_dev(div0, "id", "list");
    			attr_dev(div0, "class", "scroll svelte-1q97uxg");
    			add_location(div0, file$1, 69, 4, 1717);
    			attr_dev(div1, "id", "zone");
    			attr_dev(div1, "class", "svelte-1q97uxg");
    			add_location(div1, file$1, 57, 0, 1462);
    			attr_dev(div2, "id", "view");
    			attr_dev(div2, "class", "svelte-1q97uxg");
    			add_location(div2, file$1, 112, 0, 3382);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div1, button1);
    			append_dev(div1, t6);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			if (switch_instance) mount_component(switch_instance, div2, null);
    			insert_dev(target, t8, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[9], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[10], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*System, cardList*/ 65) && t3_value !== (t3_value = /*System*/ ctx[0].several(/*cardList*/ ctx[6].length, "carte") + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*System, cardList, undefined*/ 65) {
    				each_value = /*cardList*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (switch_value !== (switch_value = Main$1)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div2, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (/*filterWindow*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*filterWindow*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    			if (switch_instance) destroy_component(switch_instance);
    			if (detaching) detach_dev(t8);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Add', slots, []);
    	let { System } = $$props;
    	let filterWindow = false;
    	let levelSelect = "Tous";
    	let typeSelect = "Tous";
    	let familleSelect = "Toutes";
    	let elementSelect = "Tous";
    	let cardList = [];
    	filter();

    	function filter() {
    		let tab = [];

    		for (const card of System.cards.instance) {
    			if (!card.trait("Rare").value() && !card.trait("L√©gendaire").value() && (levelSelect == "Tous" || card.level == levelSelect) && (typeSelect == "Tous" || card.type == typeSelect) && (familleSelect == "Toutes" || card.familles.base.includes(familleSelect)) && (elementSelect == "Tous" || card.elements.includes(elementSelect))) {
    				tab.push(card);
    			}
    		}

    		$$invalidate(6, cardList = tab);
    	}

    	function sorting(level, type, famille, element) {
    		$$invalidate(2, levelSelect = level);
    		$$invalidate(3, typeSelect = type);
    		$$invalidate(4, familleSelect = famille);
    		$$invalidate(5, elementSelect = element);
    		filter();
    		closing();
    	}

    	function close() {
    		$$invalidate(1, filterWindow = false);
    		System.pages.change("Add");
    	}

    	$$self.$$.on_mount.push(function () {
    		if (System === undefined && !('System' in $$props || $$self.$$.bound[$$self.$$.props['System']])) {
    			console.warn("<Add> was created without expected prop 'System'");
    		}
    	});

    	const writable_props = ['System'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Add> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		System.view.reset();
    		System.pages.change("Deck");
    	};

    	const click_handler_1 = () => {
    		$$invalidate(1, filterWindow = true);
    		System.pages.change("Add");
    	};

    	const click_handler_2 = card => {
    		$$invalidate(0, System.view.card = card, System);
    		System.pages.change("Add");
    	};

    	const mouseenter_handler = card => {
    		$$invalidate(0, System.view.quick = card, System);
    		System.pages.change("Add");
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(0, System.view.quick = undefined, System);
    		System.pages.change("Add");
    	};

    	const click_handler_3 = card => {
    		System.deck.add(card.name);
    	};

    	const click_handler_4 = card => {
    		System.deck.remove(card.name);
    		System.pages.change("Add");
    	};

    	$$self.$$set = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    	};

    	$$self.$capture_state = () => ({
    		Filter,
    		View: Main$1,
    		System,
    		filterWindow,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		filter,
    		sorting,
    		close
    	});

    	$$self.$inject_state = $$props => {
    		if ('System' in $$props) $$invalidate(0, System = $$props.System);
    		if ('filterWindow' in $$props) $$invalidate(1, filterWindow = $$props.filterWindow);
    		if ('levelSelect' in $$props) $$invalidate(2, levelSelect = $$props.levelSelect);
    		if ('typeSelect' in $$props) $$invalidate(3, typeSelect = $$props.typeSelect);
    		if ('familleSelect' in $$props) $$invalidate(4, familleSelect = $$props.familleSelect);
    		if ('elementSelect' in $$props) $$invalidate(5, elementSelect = $$props.elementSelect);
    		if ('cardList' in $$props) $$invalidate(6, cardList = $$props.cardList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		System,
    		filterWindow,
    		levelSelect,
    		typeSelect,
    		familleSelect,
    		elementSelect,
    		cardList,
    		sorting,
    		close,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_3,
    		click_handler_4
    	];
    }

    class Add extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Add",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get System() {
    		throw new Error("<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set System(value) {
    		throw new Error("<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.59.2 */

    const { Object: Object_1, console: console_1 } = globals;
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let div1;
    	let div0;
    	let switch_instance;
    	let current;
    	var switch_value = /*System*/ ctx[0].pages.actual.svelte;

    	function switch_props(ctx) {
    		return {
    			props: { System: /*System*/ ctx[0] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div0, "id", "body");
    			attr_dev(div0, "class", "svelte-1ntjw4u");
    			add_location(div0, file, 302, 1, 7075);
    			attr_dev(div1, "id", "html");
    			attr_dev(div1, "class", "svelte-1ntjw4u");
    			add_location(div1, file, 301, 0, 7058);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (switch_instance) mount_component(switch_instance, div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*System*/ 1) switch_instance_changes.System = /*System*/ ctx[0];

    			if (dirty & /*System*/ 1 && switch_value !== (switch_value = /*System*/ ctx[0].pages.actual.svelte)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	const System = {
    		pages: {
    			actual: {},
    			list: [],
    			add(name, svelte) {
    				System.pages.list.push({ name, svelte });
    			},
    			getByName(name) {
    				for (const page of System.pages.list) {
    					if (page.name == name) {
    						return page;
    					}
    				}
    			},
    			change(name) {
    				$$invalidate(0, System.pages.actual = System.pages.getByName(name), System);
    			}
    		},
    		ressources: [
    			"Or",
    			"Feu",
    			"Eau",
    			"Terre",
    			"Air",
    			"V√©g√©tal",
    			"Mort",
    			"Metal",
    			"Arcane",
    			"Foudre",
    			"Glace",
    			"Lumi√®re",
    			"Ombre",
    			"Mana"
    		],
    		cards: {
    			class: [],
    			instance: [],
    			getByName(name) {
    				for (let i = 0; i < this.instance.length; i++) {
    					if (this.instance[i].name == name) {
    						return new this.class[i](System);
    					}
    				}

    				return undefined;
    			}
    		},
    		chapters: {
    			class: [],
    			instance: [],
    			getRandom(number) {
    				let level = parseInt((number - 1) / 5) + 1;
    				return new this.class[level][parseInt(Math.random() * this.class[level].length)](System, number);
    			}
    		},
    		bosses: {
    			class: [],
    			instance: [],
    			getRandom(number) {
    				let level = parseInt((number - 1) / 10) + 1;
    				return new this.class[level][parseInt(Math.random() * this.class[level].length)](System, number);
    			}
    		},
    		sort: {
    			levels: ["Tous"],
    			types: ["Tous", "Action", "B√¢timent", "Cr√©ature", "Objet", "Lieu"],
    			familles: ["Toutes"],
    			elements: ["Tous"]
    		},
    		copy(array) {
    			let tab = [];

    			for (const element of array) {
    				tab.push(element);
    			}

    			return tab;
    		},
    		shuffle(array) {
    			let i = array.length;

    			while (i != 0) {
    				let j = Math.floor(Math.random() * i);
    				i--;
    				[array[i], array[j]] = [array[j], array[i]];
    			}
    		},
    		several(value, name) {
    			let text = "";
    			text += value + " " + name;

    			if (value > 1) {
    				text += "s";
    			}

    			return text;
    		},
    		view: {
    			quick: undefined,
    			card: undefined,
    			reset() {
    				this.quick = undefined;
    				this.card = undefined;
    			}
    		},
    		decks: [],
    		train: new Train(),
    		game: undefined,
    		music: {
    			current: undefined,
    			volume: 0.5,
    			list: [],
    			slot: 0,
    			number: 4,
    			init() {
    				for (let i = 1; i < System.music.number; i++) {
    					System.music.list.push(i);
    				}

    				System.shuffle(System.music.list);
    			},
    			play() {
    				if (this.slot < this.list.length - 1) {
    					this.current = new Audio("./Music/" + this.list[this.slot] + ".mp3");

    					this.current.addEventListener("ended", function () {
    						this.play();
    					});

    					this.current.volume = this.volume;
    					this.current.play();
    					this.slot++;
    				} else {
    					this.slot = 0;
    					this.play();
    				}
    			}
    		}
    	};

    	for (let i = 0; i < 20; i++) {
    		System.sort.levels.push(i + 1);
    	}

    	for (const element of System.ressources) {
    		if (element == "Or") {
    			System.sort.elements.push("Neutre");
    		} else if (element != "Mana") {
    			System.sort.elements.push(element);
    		}
    	}

    	for (const card of Object.keys(cards)) {
    		let cardClass = cards[card];
    		let cardInstance = new cardClass(System);

    		for (const famille of cardInstance.familles.base) {
    			if (!System.sort.familles.includes(famille)) {
    				System.sort.familles.push(famille);
    			}
    		}

    		System.cards.class.push(cardClass);
    		System.cards.instance.push(cardInstance);
    	}

    	for (let i = 0; i < System.sort.familles.length; i++) {
    		let j = i;

    		while (j > 1 && System.sort.familles[j - 1].localeCompare(System.sort.familles[j]) > 0) {
    			let swap = System.sort.familles[j];
    			System.sort.familles[j] = System.sort.familles[j - 1];
    			System.sort.familles[j - 1] = swap;
    			j--;
    		}
    	}

    	for (let i = 0; i <= 20; i++) {
    		System.chapters.class.push([]);
    		System.chapters.instance.push([]);
    	}

    	for (let i = 0; i <= 10; i++) {
    		System.bosses.class.push([]);
    		System.bosses.instance.push([]);
    	}

    	for (const chapter of Object.keys(chapters)) {
    		let chapterClass = chapters[chapter];
    		let chapterInstance = new chapterClass(System, 0);
    		let error = false;

    		for (const step of chapterInstance.steps) {
    			let ressources = [];

    			for (const ressource of System.ressources) {
    				ressources.push({ name: ressource, value: 0 });
    			}

    			for (const card of step.cards) {
    				if (System.cards.getByName(card) == undefined) {
    					console.log("Invalid card in a chapter : " + card);
    					error = true;
    				} else {
    					for (let i = 0; i < System.cards.getByName(card).cout.length; i++) {
    						ressources[i].value += System.cards.getByName(card).cout[i].value();
    					}
    				}
    			}

    			for (const ressource of chapterInstance.ressources) {
    				for (const cout of ressources) {
    					if (cout.name == ressource.name && cout.value > ressource.value) {
    						console.log("Invalid ressources in a chapter : " + ressource.name + " " + (cout.value - ressource.value));
    						error = true;
    					}
    				}
    			}
    		}

    		let level = chapterInstance.getLevel();

    		if (chapterInstance.boss) {
    			System.bosses.class[level / 2].push(chapterClass);
    			System.bosses.instance[level / 2].push(chapterInstance);
    		} else {
    			System.chapters.class[level].push(chapterClass);
    			System.chapters.instance[level].push(chapterInstance);
    		}

    		if (error) {
    			console.log(chapterClass);
    		}
    	}

    	System.pages.add("BlackScreen", BlackScreen);
    	System.pages.add("TitleScreen", TitleScreen);
    	System.pages.add("Login", Login);
    	System.pages.add("Register", Register);
    	System.pages.add("Menu", Menu);
    	System.pages.add("Play", Play);
    	System.pages.add("Construit", Construit);
    	System.pages.add("Library", Library);
    	System.pages.add("Profil", Profil);
    	System.pages.add("Training", Main);
    	System.pages.add("Game", Game);
    	System.pages.add("Settings", Settings);
    	System.pages.add("Dialog", Dialog);
    	System.pages.add("Finish", Finish);
    	System.pages.add("GameOver", GameOver);
    	System.pages.add("Decks", List);
    	System.pages.add("Deck", Deck);
    	System.pages.add("Add", Add);
    	System.pages.change("BlackScreen");
    	System.music.init();
    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Train,
    		System,
    		cards,
    		chapters,
    		BlackScreen,
    		TitleScreen,
    		Login,
    		Register,
    		Menu,
    		Play,
    		Construit,
    		Library,
    		Profil,
    		Training: Main,
    		Game,
    		Settings,
    		Dialog,
    		Finish,
    		GameOver,
    		Decks: List,
    		Deck,
    		Add
    	});

    	return [System];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { System: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get System() {
    		return this.$$.ctx[0];
    	}

    	set System(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var app = new App({
    	target: document.body
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
